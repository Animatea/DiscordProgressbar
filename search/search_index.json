{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Python-Multibar! Project: python-multibar License: Apache 2.0 About: Tool for static progress bars writing. OS: Independent Python: 3.9+ Typing: Typed Topic: Utilities We are on PyPi \u00b7 Report Bug \u00b7 Request Feature Navigation menu FAQ Quickstart Python-Multibar Go to documentation Python-Multibar Minimap classDiagram PInterface < |-- ProgressbarWriter : Implements SAbstraction < |-- Sector : Implements CAbstraction < |-- CalculationService : Implements SignatureSegment < -- Signature : Uses by default Signature --> PSProtocol : Matches SignatureSegment --> SSProtocol : Matches Sector --o ProgressbarWriter : By default CalculationService --o ProgressbarWriter : By default Signature --o ProgressbarWriter : By default PCInterface < |-- ProgressbarClient : Implements HInterface < |-- Hooks : Implements CMInterface < |-- ContractManager : Implements CMInterface --> ContractInterface : Interacts with Hooks --o ProgressbarClient : By default ContractManager --o ProgressbarClient : By default ProgressbarWriter --o ProgressbarClient : By default Acknowledgments Choose an Open Source License Img Shields GitHub Pages Python Python Community MkDocs MkDocs Material MkDocs mermaid2 MkDocs pymdown MkDocs mkdocstrings MkDocs auto-refs Isaac Muse","title":"Index"},{"location":"about/","text":"Python-Multibar Installation \u00a4 Install with PyPi Install with Poetry Install with Git+Pip # Unix/macOS users should use $ python -m pip install -U python-multibar # Windows users should use $ py -m pip install -U python-multibar $ poetry add python-multibar # Unix/macOS users should use $ python -m pip install git+https://github.com/Animatea/python-multibar.git # Windows users should use $ py -m pip install git+https://github.com/Animatea/python-multibar.git Style \u00a4 Python-Multibar, like many other projects, has its own code style, which we will describe below. Code \u00a4 For code formatting we use black , the configuration of which is in pyproject.toml For imports formatting we use isort , the configuration of which is in pyproject.toml For static annotations check we use mypy , the configuration of which is in pyproject.toml For static code check we use flake8 , the configuration of which is in pyproject.toml Docstrings \u00a4 For docstrings we use numpy doctstring style Contributing \u00a4 Contributions are what make the open source community such an amazing place to learn, inspire, and create. Any contributions you make are greatly appreciated . If you have a suggestion that would make this better, please fork the repo and create a pull request. You can also simply open an issue with the tag \"enhancement\". Don't forget to give the project a star! Thanks again! Fork the Project Create your Feature Branch ( git checkout -b feature/AmazingFeature ) Commit your Changes ( git commit -m 'Add some AmazingFeature' ) Push to the Branch ( git push origin feature/AmazingFeature ) Open a Pull Request NOTE: before creating a pull request, you first need to install the project's dependencies: pip3 install -r dev-requirements.txt -r requirements.txt Then go to the root directory of the project ...\\python-multibar> and start all nox pipelines using the nox command. If all sessions are completed successfully, then feel free to create a pull request. Thanks for your PR's!","title":"About"},{"location":"about/#installation","text":"Install with PyPi Install with Poetry Install with Git+Pip # Unix/macOS users should use $ python -m pip install -U python-multibar # Windows users should use $ py -m pip install -U python-multibar $ poetry add python-multibar # Unix/macOS users should use $ python -m pip install git+https://github.com/Animatea/python-multibar.git # Windows users should use $ py -m pip install git+https://github.com/Animatea/python-multibar.git","title":"Installation"},{"location":"about/#style","text":"Python-Multibar, like many other projects, has its own code style, which we will describe below.","title":"Style"},{"location":"about/#code","text":"For code formatting we use black , the configuration of which is in pyproject.toml For imports formatting we use isort , the configuration of which is in pyproject.toml For static annotations check we use mypy , the configuration of which is in pyproject.toml For static code check we use flake8 , the configuration of which is in pyproject.toml","title":"Code"},{"location":"about/#docstrings","text":"For docstrings we use numpy doctstring style","title":"Docstrings"},{"location":"about/#contributing","text":"Contributions are what make the open source community such an amazing place to learn, inspire, and create. Any contributions you make are greatly appreciated . If you have a suggestion that would make this better, please fork the repo and create a pull request. You can also simply open an issue with the tag \"enhancement\". Don't forget to give the project a star! Thanks again! Fork the Project Create your Feature Branch ( git checkout -b feature/AmazingFeature ) Commit your Changes ( git commit -m 'Add some AmazingFeature' ) Push to the Branch ( git push origin feature/AmazingFeature ) Open a Pull Request NOTE: before creating a pull request, you first need to install the project's dependencies: pip3 install -r dev-requirements.txt -r requirements.txt Then go to the root directory of the project ...\\python-multibar> and start all nox pipelines using the nox command. If all sessions are completed successfully, then feel free to create a pull request. Thanks for your PR's!","title":"Contributing"},{"location":"errors/","text":"multibar.errors \u00a4 Module with Python-Multibar errors. __all__ = ( 'MultibarError' , 'ContractError' , 'ContractResponseError' , 'UnsignedContractError' , 'TerminatedContractError' ) module-attribute \u00a4 ContractError \u00a4 Bases: MultibarError Base contracts error. Source code in multibar\\errors.py 41 42 43 44 class ContractError ( MultibarError ): \"\"\"Base contracts error.\"\"\" pass ContractResponseError \u00a4 Bases: ContractError Error that parses contract response. Source code in multibar\\errors.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class ContractResponseError ( ContractError ): \"\"\"Error that parses contract response.\"\"\" __slots__ = ( \"contract_check\" ,) def __init__ ( self , check : contracts . ContractCheck , / ) -> None : \"\"\" Parameters ---------- check : ContractCheck Broken contract check response. \"\"\" self . contract_check = check super () . __init__ ( self . _process_check ()) def _process_check ( self ) -> str : messages = self . contract_check . errors + self . contract_check . warnings return \" & \" . join ( messages ) __slots__ = ( 'contract_check' ) class-attribute \u00a4 contract_check = check instance-attribute \u00a4 __init__ ( check ) \u00a4 PARAMETER DESCRIPTION check Broken contract check response. TYPE: ContractCheck Source code in multibar\\errors.py 52 53 54 55 56 57 58 59 60 def __init__ ( self , check : contracts . ContractCheck , / ) -> None : \"\"\" Parameters ---------- check : ContractCheck Broken contract check response. \"\"\" self . contract_check = check super () . __init__ ( self . _process_check ()) MultibarError \u00a4 Bases: Exception Base multibar error. You can use this error to catch any error from Python-Multibar. Source code in multibar\\errors.py 33 34 35 36 37 38 class MultibarError ( Exception ): \"\"\"Base multibar error. You can use this error to catch any error from Python-Multibar. \"\"\" pass TerminatedContractError \u00a4 Bases: ContractResponseError Raises if contract is broken. Source code in multibar\\errors.py 73 74 75 76 class TerminatedContractError ( ContractResponseError ): \"\"\"Raises if contract is broken.\"\"\" pass UnsignedContractError \u00a4 Bases: ContractError Raises if contract manager is not subscribed for specify contract. Source code in multibar\\errors.py 67 68 69 70 class UnsignedContractError ( ContractError ): \"\"\"Raises if contract manager is not subscribed for specify contract.\"\"\" pass","title":"Errors"},{"location":"errors/#multibar.errors","text":"Module with Python-Multibar errors.","title":"errors"},{"location":"errors/#multibar.errors.__all__","text":"","title":"__all__"},{"location":"errors/#multibar.errors.ContractError","text":"Bases: MultibarError Base contracts error. Source code in multibar\\errors.py 41 42 43 44 class ContractError ( MultibarError ): \"\"\"Base contracts error.\"\"\" pass","title":"ContractError"},{"location":"errors/#multibar.errors.ContractResponseError","text":"Bases: ContractError Error that parses contract response. Source code in multibar\\errors.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class ContractResponseError ( ContractError ): \"\"\"Error that parses contract response.\"\"\" __slots__ = ( \"contract_check\" ,) def __init__ ( self , check : contracts . ContractCheck , / ) -> None : \"\"\" Parameters ---------- check : ContractCheck Broken contract check response. \"\"\" self . contract_check = check super () . __init__ ( self . _process_check ()) def _process_check ( self ) -> str : messages = self . contract_check . errors + self . contract_check . warnings return \" & \" . join ( messages )","title":"ContractResponseError"},{"location":"errors/#multibar.errors.ContractResponseError.__slots__","text":"","title":"__slots__"},{"location":"errors/#multibar.errors.ContractResponseError.contract_check","text":"","title":"contract_check"},{"location":"errors/#multibar.errors.ContractResponseError.__init__","text":"PARAMETER DESCRIPTION check Broken contract check response. TYPE: ContractCheck Source code in multibar\\errors.py 52 53 54 55 56 57 58 59 60 def __init__ ( self , check : contracts . ContractCheck , / ) -> None : \"\"\" Parameters ---------- check : ContractCheck Broken contract check response. \"\"\" self . contract_check = check super () . __init__ ( self . _process_check ())","title":"__init__()"},{"location":"errors/#multibar.errors.MultibarError","text":"Bases: Exception Base multibar error. You can use this error to catch any error from Python-Multibar. Source code in multibar\\errors.py 33 34 35 36 37 38 class MultibarError ( Exception ): \"\"\"Base multibar error. You can use this error to catch any error from Python-Multibar. \"\"\" pass","title":"MultibarError"},{"location":"errors/#multibar.errors.TerminatedContractError","text":"Bases: ContractResponseError Raises if contract is broken. Source code in multibar\\errors.py 73 74 75 76 class TerminatedContractError ( ContractResponseError ): \"\"\"Raises if contract is broken.\"\"\" pass","title":"TerminatedContractError"},{"location":"errors/#multibar.errors.UnsignedContractError","text":"Bases: ContractError Raises if contract manager is not subscribed for specify contract. Source code in multibar\\errors.py 67 68 69 70 class UnsignedContractError ( ContractError ): \"\"\"Raises if contract manager is not subscribed for specify contract.\"\"\" pass","title":"UnsignedContractError"},{"location":"faq/","text":"FAQ \u00a4 What is the difference between Writer and Client \u00a4 Writer aggregates certain attributes in the same way as Client , that can be accessed via properties. See the documentation for a list of all properties. Note Client aggregates Writer with other customization logic. Information Writer is slightly faster than Client because Client has Contract Manager that checks all contracts and Hooks , which are also triggers when progress generates. The difference in speed is not big, but it is. The Client works on an abstraction higher than the Writer . TL;DR Client can enable validation when generating progress and trigger pre/post/on-error hooks. Writer can only interact with progressbar logic (like signature, sectors, math operations). How hooks work \u00a4 In Client implementation hooks called thrice: Quote def get_progress ( ... ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: call_metadata : progress_types . ProgressMetadataType = { ... } # <-- Validation call #1 --> self . _validate_contracts ( self . _writer , metadata = call_metadata ) # <-- Pre-execution call with metadata #2 --> self . _hooks . trigger_pre_execution ( self , metadata = call_metadata ) # Generates progressbar progressbar = self . _writer . write ( start_value , end_value , length = length ) # Sets progressbar to metadata call_metadata [ \"progressbar\" ] = progressbar # <-- Triggers Post-execution with progressbar in metadata #3 --> self . _hooks . trigger_post_execution ( self , metadata = call_metadata ) ... Post-execution is called with metadata, that stores progressbar object, where it can transform (in post-execution) . For example, this is how hooks.WRITER_HOOKS works. What is a contract manager \u00a4 The contract manager is a class that is responsible for various checks related to the progress bar. For more details see: - Contracts in documentation. - Examples on github How the progressbar works \u00a4 Progressbar - a collection that consists of sectors (objects that represent 1 character of the progress bar, but have an additional methods). Example import multibar progressbar = multibar . ProgressbarWriter () . write ( 100 , 100 ) assert type ( progressbar ) is multibar . Progressbar # Writer returns progressbar first_sector = progressbar [ 0 ] # Supports __getitem__ assert type ( first_sector ) is multibar . Sector # Progressbar consists of sectors How the Python-Multibar global settings work \u00a4 Note Python-Multibar settings is Singleton . For more details see in documentation: click","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#what-is-the-difference-between-writer-and-client","text":"Writer aggregates certain attributes in the same way as Client , that can be accessed via properties. See the documentation for a list of all properties. Note Client aggregates Writer with other customization logic. Information Writer is slightly faster than Client because Client has Contract Manager that checks all contracts and Hooks , which are also triggers when progress generates. The difference in speed is not big, but it is. The Client works on an abstraction higher than the Writer . TL;DR Client can enable validation when generating progress and trigger pre/post/on-error hooks. Writer can only interact with progressbar logic (like signature, sectors, math operations).","title":"What is the difference between Writer and Client"},{"location":"faq/#how-hooks-work","text":"In Client implementation hooks called thrice: Quote def get_progress ( ... ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: call_metadata : progress_types . ProgressMetadataType = { ... } # <-- Validation call #1 --> self . _validate_contracts ( self . _writer , metadata = call_metadata ) # <-- Pre-execution call with metadata #2 --> self . _hooks . trigger_pre_execution ( self , metadata = call_metadata ) # Generates progressbar progressbar = self . _writer . write ( start_value , end_value , length = length ) # Sets progressbar to metadata call_metadata [ \"progressbar\" ] = progressbar # <-- Triggers Post-execution with progressbar in metadata #3 --> self . _hooks . trigger_post_execution ( self , metadata = call_metadata ) ... Post-execution is called with metadata, that stores progressbar object, where it can transform (in post-execution) . For example, this is how hooks.WRITER_HOOKS works.","title":"How hooks work"},{"location":"faq/#what-is-a-contract-manager","text":"The contract manager is a class that is responsible for various checks related to the progress bar. For more details see: - Contracts in documentation. - Examples on github","title":"What is a contract manager"},{"location":"faq/#how-the-progressbar-works","text":"Progressbar - a collection that consists of sectors (objects that represent 1 character of the progress bar, but have an additional methods). Example import multibar progressbar = multibar . ProgressbarWriter () . write ( 100 , 100 ) assert type ( progressbar ) is multibar . Progressbar # Writer returns progressbar first_sector = progressbar [ 0 ] # Supports __getitem__ assert type ( first_sector ) is multibar . Sector # Progressbar consists of sectors","title":"How the progressbar works"},{"location":"faq/#how-the-python-multibar-global-settings-work","text":"Note Python-Multibar settings is Singleton . For more details see in documentation: click","title":"How the Python-Multibar global settings work"},{"location":"output/","text":"multibar.output \u00a4 This module implements the prebound method pattern to create a simple api output to the console. COLORS : typing . Final [ dict [ OutputTypes , ColorsType ]] = { ERROR : 'red' , SUCCESS : 'green' , WARNING : 'yellow' } module-attribute \u00a4 Constant that stores dict, in which key is print status and value is print color. ColorsType : typing_extensions . TypeAlias = typing . Literal [ 'red' , 'green' , 'yellow' ] module-attribute \u00a4 ERROR : ErrorType = 'error' module-attribute \u00a4 Error literal identifier. ErrorType : typing_extensions . TypeAlias = typing . Literal [ 'error' ] module-attribute \u00a4 HEADING_LEVEL_ONE : HeadingLevelOneType = 1 module-attribute \u00a4 First level heading identifier. HEADING_LEVEL_THREE : HeadingLevelThreeType = 3 module-attribute \u00a4 Third level heading identifier. HEADING_LEVEL_TWO : HeadingLevelTwoType = 2 module-attribute \u00a4 Second level heading identifier. HEADING_MAP : typing . Final [ dict [ HeadingLevelsType , tuple [ str , bool ]]] = { HEADING_LEVEL_ONE : ( '=' , True ), HEADING_LEVEL_TWO : ( '-' , True ), HEADING_LEVEL_THREE : ( '-' , False )} module-attribute \u00a4 Constant that stores dict, in which key is heading level and value is header metadata. HeadingLevelOneType : typing_extensions . TypeAlias = typing . Literal [ 1 ] module-attribute \u00a4 HeadingLevelThreeType : typing_extensions . TypeAlias = typing . Literal [ 3 ] module-attribute \u00a4 HeadingLevelTwoType : typing_extensions . TypeAlias = typing . Literal [ 2 ] module-attribute \u00a4 HeadingLevelsType : typing_extensions . TypeAlias = typing . Union [ HeadingLevelOneType , HeadingLevelTwoType , HeadingLevelThreeType ] module-attribute \u00a4 OutputTypes : typing_extensions . TypeAlias = typing . Union [ ErrorType , WarningType , SuccessType ] module-attribute \u00a4 SUCCESS : SuccessType = 'success' module-attribute \u00a4 Success literal identifier. SuccessType : typing_extensions . TypeAlias = typing . Literal [ 'success' ] module-attribute \u00a4 WARNING : WarningType = 'warning' module-attribute \u00a4 Warning literal identifier. WarningType : typing_extensions . TypeAlias = typing . Literal [ 'warning' ] module-attribute \u00a4 __all__ = ( 'PrinterAware' , 'TermcolorPrinter' , 'print' , 'new_line' , 'print_success' , 'print_warning' , 'print_heading' , 'print_error' ) module-attribute \u00a4 new_line = _output . new_line module-attribute \u00a4 Prints new line in console. print = _output . print module-attribute \u00a4 Prints text in console. Expand example of prebound pattern usage >>> from multibar import output >>> output . print_heading ( \"Testing complete\" , level = 1 , indent = False ) >>> output . print_success ( \"Checks passed: N.\" ) ========================= Testing complete ========================= Checks passed: N. print_error = _output . print_error module-attribute \u00a4 Prints text as error. print_heading = _output . print_heading module-attribute \u00a4 Prints headings in console. print_success = _output . print_success module-attribute \u00a4 Prints text as success. print_warning = _output . print_warning module-attribute \u00a4 Prints text as warning. Output \u00a4 Class that represents console printer. Note @returns . io . impure decorator shadows the underlying signature of a function, which makes it difficult to work with the IDE because it's easy to miss out on required arguments when calling a function. Therefore, we use an explicit return IO ( None ) to maintain the logic of the project. Source code in multibar\\output.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 class Output : \"\"\"Class that represents console printer. !!! note `#!py @returns.io.impure` decorator shadows the underlying signature of a function, which makes it difficult to work with the IDE because it's easy to miss out on required arguments when calling a function. Therefore, we use an explicit `#!py return IO(None)` to maintain the logic of the project. \"\"\" def print ( self , text : str = \"\" , / , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console. Parameters ---------- text : str = \"\" Text to print. bold : bool = False If true, will make text bold. color : typing.Optional[str] = None Changes text output color. newline : bool = True If true, will print new line after `text`. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , bold = bold , color = color , newline = newline , ) return IO ( None ) def new_line ( self ) -> IO [ None ]: \"\"\"Prints new line in console. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print () return IO ( None ) def print_heading ( self , text : str , / , * , level : HeadingLevelsType , style : typing . Optional [ OutputTypes ] = None , indent : bool = True , ) -> IO [ None ]: \"\"\"Prints headings in console. Parameters ---------- text : str Text to header. level : HeadingLevelsType Header level. style : typing.Optional[OutputTypes] = None If is not None, will change header style. indent : bool = True If True, will print new line after text. Returns ------- IO[None] Displays text in console. \"\"\" color = COLORS [ style ] if style else None line_char , show_line_above = HEADING_MAP [ level ] heading_line = line_char * len ( text ) if show_line_above : self . printer . print ( heading_line , bold = True , color = color ) self . printer . print ( text , bold = True , color = color ) self . printer . print ( heading_line , bold = True , color = color ) if indent : self . printer . print () return IO ( None ) def print_success ( self , text : str , / , * , bold : bool = True ) -> IO [ None ]: \"\"\"Prints text as success. Parameters ---------- text: str Text to print. bold: bool = True If True, will print text as bold. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , color = COLORS [ SUCCESS ], bold = bold ) return IO ( None ) def print_error ( self , text : str , / , * , bold : bool = True ) -> IO [ None ]: \"\"\"Prints text as error. Parameters ---------- text: str Text to print. bold: bool = True If True, will print text as bold. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , color = COLORS [ ERROR ], bold = bold ) return IO ( None ) def print_warning ( self , text : str , / ) -> IO [ None ]: \"\"\"Prints text as warning. Parameters ---------- text: str Text to print. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , color = COLORS [ WARNING ]) return IO ( None ) def update_printer ( self ) -> None : \"\"\"Updates cache for printer cached_property. !!! info For example of usage see `cached_property` class. Returns ------- None \"\"\" utils . cached_property . update_cache_for ( self , \"printer\" ) @utils . cached_property def printer ( self ) -> PrinterAware : \"\"\"Cached property that returns printer implementation. Returns ------- PrinterAware Printer implementation. \"\"\" if _PRINTER_KEY in settings . settings : return settings . settings [ _PRINTER_KEY ] return _PRINTER_STATE new_line () \u00a4 Prints new line in console. RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 240 241 242 243 244 245 246 247 248 249 def new_line ( self ) -> IO [ None ]: \"\"\"Prints new line in console. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print () return IO ( None ) print ( text = '' , / , * , bold = False , color = None , newline = True ) \u00a4 Prints text in console. PARAMETER DESCRIPTION text Text to print. TYPE: str DEFAULT: '' bold If true, will make text bold. TYPE: bool DEFAULT: False color Changes text output color. TYPE: typing . Optional [ str ] DEFAULT: None newline If true, will print new line after text . TYPE: bool DEFAULT: True RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def print ( self , text : str = \"\" , / , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console. Parameters ---------- text : str = \"\" Text to print. bold : bool = False If true, will make text bold. color : typing.Optional[str] = None Changes text output color. newline : bool = True If true, will print new line after `text`. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , bold = bold , color = color , newline = newline , ) return IO ( None ) print_error ( text , / , * , bold = True ) \u00a4 Prints text as error. PARAMETER DESCRIPTION text Text to print. TYPE: str bold If True, will print text as bold. TYPE: bool DEFAULT: True RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def print_error ( self , text : str , / , * , bold : bool = True ) -> IO [ None ]: \"\"\"Prints text as error. Parameters ---------- text: str Text to print. bold: bool = True If True, will print text as bold. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , color = COLORS [ ERROR ], bold = bold ) return IO ( None ) print_heading ( text , / , * , level , style = None , indent = True ) \u00a4 Prints headings in console. PARAMETER DESCRIPTION text Text to header. TYPE: str level Header level. TYPE: HeadingLevelsType style If is not None, will change header style. TYPE: typing . Optional [ OutputTypes ] DEFAULT: None indent If True, will print new line after text. TYPE: bool DEFAULT: True RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def print_heading ( self , text : str , / , * , level : HeadingLevelsType , style : typing . Optional [ OutputTypes ] = None , indent : bool = True , ) -> IO [ None ]: \"\"\"Prints headings in console. Parameters ---------- text : str Text to header. level : HeadingLevelsType Header level. style : typing.Optional[OutputTypes] = None If is not None, will change header style. indent : bool = True If True, will print new line after text. Returns ------- IO[None] Displays text in console. \"\"\" color = COLORS [ style ] if style else None line_char , show_line_above = HEADING_MAP [ level ] heading_line = line_char * len ( text ) if show_line_above : self . printer . print ( heading_line , bold = True , color = color ) self . printer . print ( text , bold = True , color = color ) self . printer . print ( heading_line , bold = True , color = color ) if indent : self . printer . print () return IO ( None ) print_success ( text , / , * , bold = True ) \u00a4 Prints text as success. PARAMETER DESCRIPTION text Text to print. TYPE: str bold If True, will print text as bold. TYPE: bool DEFAULT: True RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def print_success ( self , text : str , / , * , bold : bool = True ) -> IO [ None ]: \"\"\"Prints text as success. Parameters ---------- text: str Text to print. bold: bool = True If True, will print text as bold. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , color = COLORS [ SUCCESS ], bold = bold ) return IO ( None ) print_warning ( text ) \u00a4 Prints text as warning. PARAMETER DESCRIPTION text Text to print. TYPE: str RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def print_warning ( self , text : str , / ) -> IO [ None ]: \"\"\"Prints text as warning. Parameters ---------- text: str Text to print. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , color = COLORS [ WARNING ]) return IO ( None ) printer () \u00a4 Cached property that returns printer implementation. RETURNS DESCRIPTION PrinterAware Printer implementation. Source code in multibar\\output.py 357 358 359 360 361 362 363 364 365 366 367 368 @utils . cached_property def printer ( self ) -> PrinterAware : \"\"\"Cached property that returns printer implementation. Returns ------- PrinterAware Printer implementation. \"\"\" if _PRINTER_KEY in settings . settings : return settings . settings [ _PRINTER_KEY ] return _PRINTER_STATE update_printer () \u00a4 Updates cache for printer cached_property. Info For example of usage see cached_property class. RETURNS DESCRIPTION None Source code in multibar\\output.py 345 346 347 348 349 350 351 352 353 354 355 def update_printer ( self ) -> None : \"\"\"Updates cache for printer cached_property. !!! info For example of usage see `cached_property` class. Returns ------- None \"\"\" utils . cached_property . update_cache_for ( self , \"printer\" ) PrinterAware \u00a4 Bases: abc . ABC Interface for printer implementations. Source code in multibar\\output.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class PrinterAware ( abc . ABC ): \"\"\"Interface for printer implementations.\"\"\" @typing . overload @abc . abstractmethod def print ( self ) -> IO [ None ]: ... @typing . overload @abc . abstractmethod def print ( self , text : str ) -> IO [ None ]: ... @typing . overload @abc . abstractmethod def print ( self , text : str , * , bold : bool , color : typing . Optional [ str ], newline : bool , ) -> IO [ None ]: ... @abc . abstractmethod def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console. Parameters ---------- text : str = \"\" Text to print. bold : bool = False If true, will make text bold. color : typing.Optional[str] = None Changes text output color. newline : bool = True If true, will print new line after `text`. Returns ------- IO[None] Displays text in console. \"\"\" ... print ( text = '' , * , bold = False , color = None , newline = True ) abstractmethod \u00a4 Prints text in console. PARAMETER DESCRIPTION text Text to print. TYPE: str DEFAULT: '' bold If true, will make text bold. TYPE: bool DEFAULT: False color Changes text output color. TYPE: typing . Optional [ str ] DEFAULT: None newline If true, will print new line after text . TYPE: bool DEFAULT: True RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @abc . abstractmethod def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console. Parameters ---------- text : str = \"\" Text to print. bold : bool = False If true, will make text bold. color : typing.Optional[str] = None Changes text output color. newline : bool = True If true, will print new line after `text`. Returns ------- IO[None] Displays text in console. \"\"\" ... TermcolorPrinter \u00a4 Bases: PrinterAware Implementation of printer interface. Source code in multibar\\output.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class TermcolorPrinter ( PrinterAware ): \"\"\"Implementation of printer interface.\"\"\" def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console. !!! note Documentation duplicated for mkdocs auto-reference plugin. Parameters ---------- text : str = \"\" Text to print. bold : bool = False If true, will make text bold. color : typing.Optional[str] = None Changes text output color. newline : bool = True If true, will print new line after `text`. Returns ------- IO[None] Displays text in console. \"\"\" termcolor_attrs : list [ str ] = [] if bold : termcolor_attrs . append ( \"bold\" ) if newline : text += \" \\n \" termcolor . cprint ( text , color , attrs = termcolor_attrs ) return IO ( None ) print ( text = '' , * , bold = False , color = None , newline = True ) \u00a4 Prints text in console. Note Documentation duplicated for mkdocs auto-reference plugin. PARAMETER DESCRIPTION text Text to print. TYPE: str DEFAULT: '' bold If true, will make text bold. TYPE: bool DEFAULT: False color Changes text output color. TYPE: typing . Optional [ str ] DEFAULT: None newline If true, will print new line after text . TYPE: bool DEFAULT: True RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console. !!! note Documentation duplicated for mkdocs auto-reference plugin. Parameters ---------- text : str = \"\" Text to print. bold : bool = False If true, will make text bold. color : typing.Optional[str] = None Changes text output color. newline : bool = True If true, will print new line after `text`. Returns ------- IO[None] Displays text in console. \"\"\" termcolor_attrs : list [ str ] = [] if bold : termcolor_attrs . append ( \"bold\" ) if newline : text += \" \\n \" termcolor . cprint ( text , color , attrs = termcolor_attrs ) return IO ( None )","title":"Console"},{"location":"output/#multibar.output","text":"This module implements the prebound method pattern to create a simple api output to the console.","title":"output"},{"location":"output/#multibar.output.COLORS","text":"Constant that stores dict, in which key is print status and value is print color.","title":"COLORS"},{"location":"output/#multibar.output.ColorsType","text":"","title":"ColorsType"},{"location":"output/#multibar.output.ERROR","text":"Error literal identifier.","title":"ERROR"},{"location":"output/#multibar.output.ErrorType","text":"","title":"ErrorType"},{"location":"output/#multibar.output.HEADING_LEVEL_ONE","text":"First level heading identifier.","title":"HEADING_LEVEL_ONE"},{"location":"output/#multibar.output.HEADING_LEVEL_THREE","text":"Third level heading identifier.","title":"HEADING_LEVEL_THREE"},{"location":"output/#multibar.output.HEADING_LEVEL_TWO","text":"Second level heading identifier.","title":"HEADING_LEVEL_TWO"},{"location":"output/#multibar.output.HEADING_MAP","text":"Constant that stores dict, in which key is heading level and value is header metadata.","title":"HEADING_MAP"},{"location":"output/#multibar.output.HeadingLevelOneType","text":"","title":"HeadingLevelOneType"},{"location":"output/#multibar.output.HeadingLevelThreeType","text":"","title":"HeadingLevelThreeType"},{"location":"output/#multibar.output.HeadingLevelTwoType","text":"","title":"HeadingLevelTwoType"},{"location":"output/#multibar.output.HeadingLevelsType","text":"","title":"HeadingLevelsType"},{"location":"output/#multibar.output.OutputTypes","text":"","title":"OutputTypes"},{"location":"output/#multibar.output.SUCCESS","text":"Success literal identifier.","title":"SUCCESS"},{"location":"output/#multibar.output.SuccessType","text":"","title":"SuccessType"},{"location":"output/#multibar.output.WARNING","text":"Warning literal identifier.","title":"WARNING"},{"location":"output/#multibar.output.WarningType","text":"","title":"WarningType"},{"location":"output/#multibar.output.__all__","text":"","title":"__all__"},{"location":"output/#multibar.output.new_line","text":"Prints new line in console.","title":"new_line"},{"location":"output/#multibar.output.print","text":"Prints text in console. Expand example of prebound pattern usage >>> from multibar import output >>> output . print_heading ( \"Testing complete\" , level = 1 , indent = False ) >>> output . print_success ( \"Checks passed: N.\" ) ========================= Testing complete ========================= Checks passed: N.","title":"print"},{"location":"output/#multibar.output.print_error","text":"Prints text as error.","title":"print_error"},{"location":"output/#multibar.output.print_heading","text":"Prints headings in console.","title":"print_heading"},{"location":"output/#multibar.output.print_success","text":"Prints text as success.","title":"print_success"},{"location":"output/#multibar.output.print_warning","text":"Prints text as warning.","title":"print_warning"},{"location":"output/#multibar.output.Output","text":"Class that represents console printer. Note @returns . io . impure decorator shadows the underlying signature of a function, which makes it difficult to work with the IDE because it's easy to miss out on required arguments when calling a function. Therefore, we use an explicit return IO ( None ) to maintain the logic of the project. Source code in multibar\\output.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 class Output : \"\"\"Class that represents console printer. !!! note `#!py @returns.io.impure` decorator shadows the underlying signature of a function, which makes it difficult to work with the IDE because it's easy to miss out on required arguments when calling a function. Therefore, we use an explicit `#!py return IO(None)` to maintain the logic of the project. \"\"\" def print ( self , text : str = \"\" , / , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console. Parameters ---------- text : str = \"\" Text to print. bold : bool = False If true, will make text bold. color : typing.Optional[str] = None Changes text output color. newline : bool = True If true, will print new line after `text`. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , bold = bold , color = color , newline = newline , ) return IO ( None ) def new_line ( self ) -> IO [ None ]: \"\"\"Prints new line in console. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print () return IO ( None ) def print_heading ( self , text : str , / , * , level : HeadingLevelsType , style : typing . Optional [ OutputTypes ] = None , indent : bool = True , ) -> IO [ None ]: \"\"\"Prints headings in console. Parameters ---------- text : str Text to header. level : HeadingLevelsType Header level. style : typing.Optional[OutputTypes] = None If is not None, will change header style. indent : bool = True If True, will print new line after text. Returns ------- IO[None] Displays text in console. \"\"\" color = COLORS [ style ] if style else None line_char , show_line_above = HEADING_MAP [ level ] heading_line = line_char * len ( text ) if show_line_above : self . printer . print ( heading_line , bold = True , color = color ) self . printer . print ( text , bold = True , color = color ) self . printer . print ( heading_line , bold = True , color = color ) if indent : self . printer . print () return IO ( None ) def print_success ( self , text : str , / , * , bold : bool = True ) -> IO [ None ]: \"\"\"Prints text as success. Parameters ---------- text: str Text to print. bold: bool = True If True, will print text as bold. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , color = COLORS [ SUCCESS ], bold = bold ) return IO ( None ) def print_error ( self , text : str , / , * , bold : bool = True ) -> IO [ None ]: \"\"\"Prints text as error. Parameters ---------- text: str Text to print. bold: bool = True If True, will print text as bold. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , color = COLORS [ ERROR ], bold = bold ) return IO ( None ) def print_warning ( self , text : str , / ) -> IO [ None ]: \"\"\"Prints text as warning. Parameters ---------- text: str Text to print. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , color = COLORS [ WARNING ]) return IO ( None ) def update_printer ( self ) -> None : \"\"\"Updates cache for printer cached_property. !!! info For example of usage see `cached_property` class. Returns ------- None \"\"\" utils . cached_property . update_cache_for ( self , \"printer\" ) @utils . cached_property def printer ( self ) -> PrinterAware : \"\"\"Cached property that returns printer implementation. Returns ------- PrinterAware Printer implementation. \"\"\" if _PRINTER_KEY in settings . settings : return settings . settings [ _PRINTER_KEY ] return _PRINTER_STATE","title":"Output"},{"location":"output/#multibar.output.Output.new_line","text":"Prints new line in console. RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 240 241 242 243 244 245 246 247 248 249 def new_line ( self ) -> IO [ None ]: \"\"\"Prints new line in console. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print () return IO ( None )","title":"new_line()"},{"location":"output/#multibar.output.Output.print","text":"Prints text in console. PARAMETER DESCRIPTION text Text to print. TYPE: str DEFAULT: '' bold If true, will make text bold. TYPE: bool DEFAULT: False color Changes text output color. TYPE: typing . Optional [ str ] DEFAULT: None newline If true, will print new line after text . TYPE: bool DEFAULT: True RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def print ( self , text : str = \"\" , / , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console. Parameters ---------- text : str = \"\" Text to print. bold : bool = False If true, will make text bold. color : typing.Optional[str] = None Changes text output color. newline : bool = True If true, will print new line after `text`. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , bold = bold , color = color , newline = newline , ) return IO ( None )","title":"print()"},{"location":"output/#multibar.output.Output.print_error","text":"Prints text as error. PARAMETER DESCRIPTION text Text to print. TYPE: str bold If True, will print text as bold. TYPE: bool DEFAULT: True RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def print_error ( self , text : str , / , * , bold : bool = True ) -> IO [ None ]: \"\"\"Prints text as error. Parameters ---------- text: str Text to print. bold: bool = True If True, will print text as bold. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , color = COLORS [ ERROR ], bold = bold ) return IO ( None )","title":"print_error()"},{"location":"output/#multibar.output.Output.print_heading","text":"Prints headings in console. PARAMETER DESCRIPTION text Text to header. TYPE: str level Header level. TYPE: HeadingLevelsType style If is not None, will change header style. TYPE: typing . Optional [ OutputTypes ] DEFAULT: None indent If True, will print new line after text. TYPE: bool DEFAULT: True RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def print_heading ( self , text : str , / , * , level : HeadingLevelsType , style : typing . Optional [ OutputTypes ] = None , indent : bool = True , ) -> IO [ None ]: \"\"\"Prints headings in console. Parameters ---------- text : str Text to header. level : HeadingLevelsType Header level. style : typing.Optional[OutputTypes] = None If is not None, will change header style. indent : bool = True If True, will print new line after text. Returns ------- IO[None] Displays text in console. \"\"\" color = COLORS [ style ] if style else None line_char , show_line_above = HEADING_MAP [ level ] heading_line = line_char * len ( text ) if show_line_above : self . printer . print ( heading_line , bold = True , color = color ) self . printer . print ( text , bold = True , color = color ) self . printer . print ( heading_line , bold = True , color = color ) if indent : self . printer . print () return IO ( None )","title":"print_heading()"},{"location":"output/#multibar.output.Output.print_success","text":"Prints text as success. PARAMETER DESCRIPTION text Text to print. TYPE: str bold If True, will print text as bold. TYPE: bool DEFAULT: True RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def print_success ( self , text : str , / , * , bold : bool = True ) -> IO [ None ]: \"\"\"Prints text as success. Parameters ---------- text: str Text to print. bold: bool = True If True, will print text as bold. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , color = COLORS [ SUCCESS ], bold = bold ) return IO ( None )","title":"print_success()"},{"location":"output/#multibar.output.Output.print_warning","text":"Prints text as warning. PARAMETER DESCRIPTION text Text to print. TYPE: str RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def print_warning ( self , text : str , / ) -> IO [ None ]: \"\"\"Prints text as warning. Parameters ---------- text: str Text to print. Returns ------- IO[None] Displays text in console. \"\"\" self . printer . print ( text , color = COLORS [ WARNING ]) return IO ( None )","title":"print_warning()"},{"location":"output/#multibar.output.Output.printer","text":"Cached property that returns printer implementation. RETURNS DESCRIPTION PrinterAware Printer implementation. Source code in multibar\\output.py 357 358 359 360 361 362 363 364 365 366 367 368 @utils . cached_property def printer ( self ) -> PrinterAware : \"\"\"Cached property that returns printer implementation. Returns ------- PrinterAware Printer implementation. \"\"\" if _PRINTER_KEY in settings . settings : return settings . settings [ _PRINTER_KEY ] return _PRINTER_STATE","title":"printer()"},{"location":"output/#multibar.output.Output.update_printer","text":"Updates cache for printer cached_property. Info For example of usage see cached_property class. RETURNS DESCRIPTION None Source code in multibar\\output.py 345 346 347 348 349 350 351 352 353 354 355 def update_printer ( self ) -> None : \"\"\"Updates cache for printer cached_property. !!! info For example of usage see `cached_property` class. Returns ------- None \"\"\" utils . cached_property . update_cache_for ( self , \"printer\" )","title":"update_printer()"},{"location":"output/#multibar.output.PrinterAware","text":"Bases: abc . ABC Interface for printer implementations. Source code in multibar\\output.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class PrinterAware ( abc . ABC ): \"\"\"Interface for printer implementations.\"\"\" @typing . overload @abc . abstractmethod def print ( self ) -> IO [ None ]: ... @typing . overload @abc . abstractmethod def print ( self , text : str ) -> IO [ None ]: ... @typing . overload @abc . abstractmethod def print ( self , text : str , * , bold : bool , color : typing . Optional [ str ], newline : bool , ) -> IO [ None ]: ... @abc . abstractmethod def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console. Parameters ---------- text : str = \"\" Text to print. bold : bool = False If true, will make text bold. color : typing.Optional[str] = None Changes text output color. newline : bool = True If true, will print new line after `text`. Returns ------- IO[None] Displays text in console. \"\"\" ...","title":"PrinterAware"},{"location":"output/#multibar.output.PrinterAware.print","text":"Prints text in console. PARAMETER DESCRIPTION text Text to print. TYPE: str DEFAULT: '' bold If true, will make text bold. TYPE: bool DEFAULT: False color Changes text output color. TYPE: typing . Optional [ str ] DEFAULT: None newline If true, will print new line after text . TYPE: bool DEFAULT: True RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @abc . abstractmethod def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console. Parameters ---------- text : str = \"\" Text to print. bold : bool = False If true, will make text bold. color : typing.Optional[str] = None Changes text output color. newline : bool = True If true, will print new line after `text`. Returns ------- IO[None] Displays text in console. \"\"\" ...","title":"print()"},{"location":"output/#multibar.output.TermcolorPrinter","text":"Bases: PrinterAware Implementation of printer interface. Source code in multibar\\output.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class TermcolorPrinter ( PrinterAware ): \"\"\"Implementation of printer interface.\"\"\" def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console. !!! note Documentation duplicated for mkdocs auto-reference plugin. Parameters ---------- text : str = \"\" Text to print. bold : bool = False If true, will make text bold. color : typing.Optional[str] = None Changes text output color. newline : bool = True If true, will print new line after `text`. Returns ------- IO[None] Displays text in console. \"\"\" termcolor_attrs : list [ str ] = [] if bold : termcolor_attrs . append ( \"bold\" ) if newline : text += \" \\n \" termcolor . cprint ( text , color , attrs = termcolor_attrs ) return IO ( None )","title":"TermcolorPrinter"},{"location":"output/#multibar.output.TermcolorPrinter.print","text":"Prints text in console. Note Documentation duplicated for mkdocs auto-reference plugin. PARAMETER DESCRIPTION text Text to print. TYPE: str DEFAULT: '' bold If true, will make text bold. TYPE: bool DEFAULT: False color Changes text output color. TYPE: typing . Optional [ str ] DEFAULT: None newline If true, will print new line after text . TYPE: bool DEFAULT: True RETURNS DESCRIPTION IO [None] Displays text in console. Source code in multibar\\output.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console. !!! note Documentation duplicated for mkdocs auto-reference plugin. Parameters ---------- text : str = \"\" Text to print. bold : bool = False If true, will make text bold. color : typing.Optional[str] = None Changes text output color. newline : bool = True If true, will print new line after `text`. Returns ------- IO[None] Displays text in console. \"\"\" termcolor_attrs : list [ str ] = [] if bold : termcolor_attrs . append ( \"bold\" ) if newline : text += \" \\n \" termcolor . cprint ( text , color , attrs = termcolor_attrs ) return IO ( None )","title":"print()"},{"location":"quickstart/","text":"Quickstart \u00a4 If you haven't installed the library yet, then you should start with this section: how to install python-multibar Minimal progressbar \u00a4 Using writer \u00a4 import multibar writer = multibar . ProgressbarWriter () progressbar = writer . write ( 50 , 100 , length = 10 ) assert str ( progressbar ) == \"+++++-----\" # Default signature, that You can change. assert type ( progressbar ) is multibar . Progressbar # Default progressbar collection, that You can change. Using client \u00a4 client = multibar . ProgressbarClient () client . set_hooks ( multibar . WRITER_HOOKS ) # This hooks allows You to work with `start` and `end` characters of the progress bar. progressbar = client . get_progress ( 100 , 100 , length = 10 ) assert str ( progressbar ) == \"<++++++++>\" # Default signature, that You can change. Error The following code will raise multibar.errors.TerminatedContractError ! progressbar = client . get_progress ( 200 , 100 ) # Start value more that end value Because by default ProgressbarClient() is subscribed to the multibar.WRITE_PROGRESS_CONTRACT contract, that checks if start_value is not more than end_value and if length is more that zero. How to terminate multibar.WRITE_PROGRESS_CONTRACT ? You can terminate any contract by the following code: Warning This may allow unexpected behavior, that is described in the comments to the code below. If you terminate this contract, it is recommended to write or include in your contract checks from the WriteProgressContract() contract. Unexpected behavior #1 import multibar client = multibar . ProgressbarClient () client . contract_manager . terminate ( multibar . WRITE_PROGRESS_CONTRACT ) progressbar = client . get_progress ( 200 , 100 , length = 10 ) assert str ( progressbar ) == \"++++++++++++++++++++\" assert progressbar . length == len ( progressbar ) == 20 # But specified length is 10! Unexpected behavior #2 client . get_progress ( 100 , 100 , length = 0 ) # This code will raise ZeroDivisionError. Unexpected behavior #3 progressbar = client . get_progress ( 100 , 100 , length =- 1 ) assert str ( progressbar ) == \"\" # Progressbar is empty. assert progressbar . length == len ( progressbar ) == 0 Discord addition & Signature changing \u00a4 Your custom signature implementation will look like: \u00a4 import dataclasses import multibar @dataclasses . dataclass class MyOwnSignature : start : multibar . SignatureSegmentProtocol = dataclasses . field ( default = multibar . SignatureSegment ( on_filled = \"<\" , on_unfilled = \"#\" ), ) middle : multibar . SignatureSegmentProtocol = dataclasses . field ( default = multibar . SignatureSegment ( on_filled = \"O\" , on_unfilled = \"#\" ), ) end : multibar . SignatureSegmentProtocol = dataclasses . field ( default = multibar . SignatureSegment ( on_filled = \">\" , on_unfilled = \"#\" ), ) Setting signature to writer on creation \u00a4 multibar . ProgressbarWriter . from_signature ( MyOwnSignature ()) progressbar = writer . write ( 50 , 100 , length = 6 ) assert str ( progressbar ) == \"OOO###\" # Your custom signature Setting signature to existing writer \u00a4 existing_writer . bind_signature ( MyOwnSignature ()) progressbar = writer . write ( 50 , 100 , length = 6 ) assert str ( progressbar ) == \"OOO###\" # Your custom signature Settings signature to ProgressbarClient() \u00a4 Go to hooks documentation client = multibar . ProgressbarClient () client . writer . bind_signature ( MyOwnSignature ()) # Setting signature # Setting hooks that includes `start` and `end` value into progressbar client . update_hooks ( multibar . WRITER_HOOKS ) progressbar = client . get_progress ( 100 , 100 , length = 6 ) assert str ( progressbar ) == \"<OOOO>\" assert type ( progressbar ) is multibar . Progressbar Discord pseudocode \u00a4 import multibar writer = multibar . ProgressbarWriter . from_signature ( multibar . SquareEmojiSignature () ) async def some_command ( context : your . library . CommandContext ) -> None : user = inject ( context . author . id ) await context . create_message ( writer . write ( user . current_xp , user . needed_xp ) ) If user progress is, for example, 50%, then in discord it will look like:","title":":gear: Quickstart"},{"location":"quickstart/#quickstart","text":"If you haven't installed the library yet, then you should start with this section: how to install python-multibar","title":"Quickstart"},{"location":"quickstart/#minimal-progressbar","text":"","title":"Minimal progressbar"},{"location":"quickstart/#using-writer","text":"import multibar writer = multibar . ProgressbarWriter () progressbar = writer . write ( 50 , 100 , length = 10 ) assert str ( progressbar ) == \"+++++-----\" # Default signature, that You can change. assert type ( progressbar ) is multibar . Progressbar # Default progressbar collection, that You can change.","title":"Using writer"},{"location":"quickstart/#using-client","text":"client = multibar . ProgressbarClient () client . set_hooks ( multibar . WRITER_HOOKS ) # This hooks allows You to work with `start` and `end` characters of the progress bar. progressbar = client . get_progress ( 100 , 100 , length = 10 ) assert str ( progressbar ) == \"<++++++++>\" # Default signature, that You can change. Error The following code will raise multibar.errors.TerminatedContractError ! progressbar = client . get_progress ( 200 , 100 ) # Start value more that end value Because by default ProgressbarClient() is subscribed to the multibar.WRITE_PROGRESS_CONTRACT contract, that checks if start_value is not more than end_value and if length is more that zero. How to terminate multibar.WRITE_PROGRESS_CONTRACT ? You can terminate any contract by the following code: Warning This may allow unexpected behavior, that is described in the comments to the code below. If you terminate this contract, it is recommended to write or include in your contract checks from the WriteProgressContract() contract. Unexpected behavior #1 import multibar client = multibar . ProgressbarClient () client . contract_manager . terminate ( multibar . WRITE_PROGRESS_CONTRACT ) progressbar = client . get_progress ( 200 , 100 , length = 10 ) assert str ( progressbar ) == \"++++++++++++++++++++\" assert progressbar . length == len ( progressbar ) == 20 # But specified length is 10! Unexpected behavior #2 client . get_progress ( 100 , 100 , length = 0 ) # This code will raise ZeroDivisionError. Unexpected behavior #3 progressbar = client . get_progress ( 100 , 100 , length =- 1 ) assert str ( progressbar ) == \"\" # Progressbar is empty. assert progressbar . length == len ( progressbar ) == 0","title":"Using client"},{"location":"quickstart/#discord-addition-signature-changing","text":"","title":"Discord addition &amp; Signature changing"},{"location":"quickstart/#your-custom-signature-implementation-will-look-like","text":"import dataclasses import multibar @dataclasses . dataclass class MyOwnSignature : start : multibar . SignatureSegmentProtocol = dataclasses . field ( default = multibar . SignatureSegment ( on_filled = \"<\" , on_unfilled = \"#\" ), ) middle : multibar . SignatureSegmentProtocol = dataclasses . field ( default = multibar . SignatureSegment ( on_filled = \"O\" , on_unfilled = \"#\" ), ) end : multibar . SignatureSegmentProtocol = dataclasses . field ( default = multibar . SignatureSegment ( on_filled = \">\" , on_unfilled = \"#\" ), )","title":"Your custom signature implementation will look like:"},{"location":"quickstart/#setting-signature-to-writer-on-creation","text":"multibar . ProgressbarWriter . from_signature ( MyOwnSignature ()) progressbar = writer . write ( 50 , 100 , length = 6 ) assert str ( progressbar ) == \"OOO###\" # Your custom signature","title":"Setting signature to writer on creation"},{"location":"quickstart/#setting-signature-to-existing-writer","text":"existing_writer . bind_signature ( MyOwnSignature ()) progressbar = writer . write ( 50 , 100 , length = 6 ) assert str ( progressbar ) == \"OOO###\" # Your custom signature","title":"Setting signature to existing writer"},{"location":"quickstart/#settings-signature-to-progressbarclient","text":"Go to hooks documentation client = multibar . ProgressbarClient () client . writer . bind_signature ( MyOwnSignature ()) # Setting signature # Setting hooks that includes `start` and `end` value into progressbar client . update_hooks ( multibar . WRITER_HOOKS ) progressbar = client . get_progress ( 100 , 100 , length = 6 ) assert str ( progressbar ) == \"<OOOO>\" assert type ( progressbar ) is multibar . Progressbar","title":"Settings signature to ProgressbarClient()"},{"location":"quickstart/#discord-pseudocode","text":"import multibar writer = multibar . ProgressbarWriter . from_signature ( multibar . SquareEmojiSignature () ) async def some_command ( context : your . library . CommandContext ) -> None : user = inject ( context . author . id ) await context . create_message ( writer . write ( user . current_xp , user . needed_xp ) ) If user progress is, for example, 50%, then in discord it will look like:","title":"Discord pseudocode"},{"location":"settings/","text":"multibar.settings \u00a4 Python-Multibar project settings. SelfT = typing . TypeVar ( 'SelfT' , bound = 'Settings' ) module-attribute \u00a4 Self Type for Settings instance. __all__ = ( 'Settings' , 'settings' ) module-attribute \u00a4 settings = Settings () module-attribute \u00a4 Multibar global settings singleton. Settings \u00a4 Multibar global settings singleton. Currently used for Option Type Default PRINTER PrinterAware TermcolorPrinter Expand example of usage import typing from returns.io import IO from multibar import output , settings class MyOwnPrinter ( output . PrinterAware ): def print ( self , * args : typing . Any , ** kwargs : typing . Any ) -> IO [ None ]: # Implementation of your [colored] printer. return IO ( None ) settings . settings . configure ( PRINTER = MyOwnPrinter ) Source code in multibar\\settings.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class Settings ( metaclass = utils . Singleton ): \"\"\"Multibar global settings singleton. !!! tldr \"Currently used for\" | Option | Type | Default | | ----------- | ---------------|----------------- | | `PRINTER` | PrinterAware | TermcolorPrinter | ??? example \"Expand example of usage\" ```py hl_lines=\"12\" import typing from returns.io import IO from multibar import output, settings class MyOwnPrinter(output.PrinterAware): def print(self, *args: typing.Any, **kwargs: typing.Any) -> IO[None]: # Implementation of your [colored] printer. return IO(None) settings.settings.configure(PRINTER=MyOwnPrinter) ``` \"\"\" __getattr__ = __getitem__ = _config_get_function def __init__ ( self ) -> None : self . _config : dict [ str , typing . Any ] = {} def __contains__ ( self , item : typing . Any ) -> bool : \"\"\"If item is not hashable, checks for config.values(), otherwise config.keys().\"\"\" if not isinstance ( item , collections . abc . Hashable ): return item in self . _config . values () return item in self . _config def configure ( self , ** kwargs : typing . Any ) -> None : \"\"\"Updates global settings config. Parameters ---------- **kwargs : typing.Any Keyword arguments to configure. \"\"\" self . _config . update ( kwargs ) __getattr__ = _config_get_function class-attribute \u00a4 __getitem__ = _config_get_function class-attribute \u00a4 __contains__ ( item ) \u00a4 If item is not hashable, checks for config.values(), otherwise config.keys(). Source code in multibar\\settings.py 66 67 68 69 70 71 def __contains__ ( self , item : typing . Any ) -> bool : \"\"\"If item is not hashable, checks for config.values(), otherwise config.keys().\"\"\" if not isinstance ( item , collections . abc . Hashable ): return item in self . _config . values () return item in self . _config __init__ () \u00a4 Source code in multibar\\settings.py 63 64 def __init__ ( self ) -> None : self . _config : dict [ str , typing . Any ] = {} configure ( ** kwargs ) \u00a4 Updates global settings config. PARAMETER DESCRIPTION **kwargs Keyword arguments to configure. TYPE: typing . Any DEFAULT: {} Source code in multibar\\settings.py 73 74 75 76 77 78 79 80 81 def configure ( self , ** kwargs : typing . Any ) -> None : \"\"\"Updates global settings config. Parameters ---------- **kwargs : typing.Any Keyword arguments to configure. \"\"\" self . _config . update ( kwargs )","title":"Settings"},{"location":"settings/#multibar.settings","text":"Python-Multibar project settings.","title":"settings"},{"location":"settings/#multibar.settings.SelfT","text":"Self Type for Settings instance.","title":"SelfT"},{"location":"settings/#multibar.settings.__all__","text":"","title":"__all__"},{"location":"settings/#multibar.settings.settings","text":"Multibar global settings singleton.","title":"settings"},{"location":"settings/#multibar.settings.Settings","text":"Multibar global settings singleton. Currently used for Option Type Default PRINTER PrinterAware TermcolorPrinter Expand example of usage import typing from returns.io import IO from multibar import output , settings class MyOwnPrinter ( output . PrinterAware ): def print ( self , * args : typing . Any , ** kwargs : typing . Any ) -> IO [ None ]: # Implementation of your [colored] printer. return IO ( None ) settings . settings . configure ( PRINTER = MyOwnPrinter ) Source code in multibar\\settings.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class Settings ( metaclass = utils . Singleton ): \"\"\"Multibar global settings singleton. !!! tldr \"Currently used for\" | Option | Type | Default | | ----------- | ---------------|----------------- | | `PRINTER` | PrinterAware | TermcolorPrinter | ??? example \"Expand example of usage\" ```py hl_lines=\"12\" import typing from returns.io import IO from multibar import output, settings class MyOwnPrinter(output.PrinterAware): def print(self, *args: typing.Any, **kwargs: typing.Any) -> IO[None]: # Implementation of your [colored] printer. return IO(None) settings.settings.configure(PRINTER=MyOwnPrinter) ``` \"\"\" __getattr__ = __getitem__ = _config_get_function def __init__ ( self ) -> None : self . _config : dict [ str , typing . Any ] = {} def __contains__ ( self , item : typing . Any ) -> bool : \"\"\"If item is not hashable, checks for config.values(), otherwise config.keys().\"\"\" if not isinstance ( item , collections . abc . Hashable ): return item in self . _config . values () return item in self . _config def configure ( self , ** kwargs : typing . Any ) -> None : \"\"\"Updates global settings config. Parameters ---------- **kwargs : typing.Any Keyword arguments to configure. \"\"\" self . _config . update ( kwargs )","title":"Settings"},{"location":"settings/#multibar.settings.Settings.__getattr__","text":"","title":"__getattr__"},{"location":"settings/#multibar.settings.Settings.__getitem__","text":"","title":"__getitem__"},{"location":"settings/#multibar.settings.Settings.__contains__","text":"If item is not hashable, checks for config.values(), otherwise config.keys(). Source code in multibar\\settings.py 66 67 68 69 70 71 def __contains__ ( self , item : typing . Any ) -> bool : \"\"\"If item is not hashable, checks for config.values(), otherwise config.keys().\"\"\" if not isinstance ( item , collections . abc . Hashable ): return item in self . _config . values () return item in self . _config","title":"__contains__()"},{"location":"settings/#multibar.settings.Settings.__init__","text":"Source code in multibar\\settings.py 63 64 def __init__ ( self ) -> None : self . _config : dict [ str , typing . Any ] = {}","title":"__init__()"},{"location":"settings/#multibar.settings.Settings.configure","text":"Updates global settings config. PARAMETER DESCRIPTION **kwargs Keyword arguments to configure. TYPE: typing . Any DEFAULT: {} Source code in multibar\\settings.py 73 74 75 76 77 78 79 80 81 def configure ( self , ** kwargs : typing . Any ) -> None : \"\"\"Updates global settings config. Parameters ---------- **kwargs : typing.Any Keyword arguments to configure. \"\"\" self . _config . update ( kwargs )","title":"configure()"},{"location":"types/","text":"multibar.types \u00a4 Python-Multibar project types. HookSignatureType : typing_extensions . TypeAlias = typing . Callable [ Ellipsis , typing . Optional [ bool ]] module-attribute \u00a4 Type for hook callable signature. Info By default hook callable accepts *args and **kwargs parameters. __all__ = ( 'ProgressMetadataType' ) module-attribute \u00a4 ProgressMetadataType \u00a4 Bases: typing . TypedDict Progress metadata type for hooks triggering. Source code in multibar\\types.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class ProgressMetadataType ( typing . TypedDict , total = False ): \"\"\"Progress metadata type for hooks triggering.\"\"\" start_value : int \"\"\"Start value (current progress).\"\"\" end_value : int \"\"\"End value (needed progress).\"\"\" length : int \"\"\"Length of progressbar.\"\"\" sig : signatures . ProgressbarSignatureProtocol \"\"\"Progressbar signature.\"\"\" progressbar : typing . Optional [ progressbars . ProgressbarAware [ sectors . AbstractSector ]] \"\"\"Progressbar instance.\"\"\" calculation_service_cls : typing . Type [ calculation_service . AbstractCalculationService ] \"\"\"Math operations cls.\"\"\" calculation_service_cls : typing . Type [ calculation_service . AbstractCalculationService ] class-attribute \u00a4 Math operations cls. end_value : int class-attribute \u00a4 End value (needed progress). length : int class-attribute \u00a4 Length of progressbar. progressbar : typing . Optional [ progressbars . ProgressbarAware [ sectors . AbstractSector ]] class-attribute \u00a4 Progressbar instance. sig : signatures . ProgressbarSignatureProtocol class-attribute \u00a4 Progressbar signature. start_value : int class-attribute \u00a4 Start value (current progress).","title":"Types"},{"location":"types/#multibar.types","text":"Python-Multibar project types.","title":"types"},{"location":"types/#multibar.types.HookSignatureType","text":"Type for hook callable signature. Info By default hook callable accepts *args and **kwargs parameters.","title":"HookSignatureType"},{"location":"types/#multibar.types.__all__","text":"","title":"__all__"},{"location":"types/#multibar.types.ProgressMetadataType","text":"Bases: typing . TypedDict Progress metadata type for hooks triggering. Source code in multibar\\types.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class ProgressMetadataType ( typing . TypedDict , total = False ): \"\"\"Progress metadata type for hooks triggering.\"\"\" start_value : int \"\"\"Start value (current progress).\"\"\" end_value : int \"\"\"End value (needed progress).\"\"\" length : int \"\"\"Length of progressbar.\"\"\" sig : signatures . ProgressbarSignatureProtocol \"\"\"Progressbar signature.\"\"\" progressbar : typing . Optional [ progressbars . ProgressbarAware [ sectors . AbstractSector ]] \"\"\"Progressbar instance.\"\"\" calculation_service_cls : typing . Type [ calculation_service . AbstractCalculationService ] \"\"\"Math operations cls.\"\"\"","title":"ProgressMetadataType"},{"location":"types/#multibar.types.ProgressMetadataType.calculation_service_cls","text":"Math operations cls.","title":"calculation_service_cls"},{"location":"types/#multibar.types.ProgressMetadataType.end_value","text":"End value (needed progress).","title":"end_value"},{"location":"types/#multibar.types.ProgressMetadataType.length","text":"Length of progressbar.","title":"length"},{"location":"types/#multibar.types.ProgressMetadataType.progressbar","text":"Progressbar instance.","title":"progressbar"},{"location":"types/#multibar.types.ProgressMetadataType.sig","text":"Progressbar signature.","title":"sig"},{"location":"types/#multibar.types.ProgressMetadataType.start_value","text":"Start value (current progress).","title":"start_value"},{"location":"utilities/","text":"multibar.utils \u00a4 Python-Multibar project utilities. __all__ = ( 'Singleton' , 'cached_property' , 'none_or' ) module-attribute \u00a4 Singleton \u00a4 Bases: type Metaclass that implements Singleton pattern. Expand example of usage class Class ( metaclass = Singleton ): def __init__ ( self ) -> None : self . attribute = 1 >>> self = Class () >>> self2 = Class () >>> self2 . attribute 1 >>> self . attribute = 2 >>> self2 . attribute 2 ATTRIBUTE DESCRIPTION _instances Dict of instances, where key is Type[instance]. TYPE: dict[typing.Type[typing.Any], typing.Any] = {} Source code in multibar\\utils.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 class Singleton ( type ): \"\"\"Metaclass that implements Singleton pattern. ??? example \"Expand example of usage\" ```py hl_lines=\"7 8 9 10 11\" class Class(metaclass=Singleton): def __init__(self) -> None: self.attribute = 1 >>> self = Class() >>> self2 = Class() >>> self2.attribute 1 >>> self.attribute = 2 >>> self2.attribute 2 ``` Attributes ---------- _instances : dict[typing.Type[typing.Any], typing.Any] = {} Dict of instances, where key is Type[instance]. \"\"\" _instances : dict [ typing . Type [ typing . Any ], typing . Any ] = {} def __call__ ( cls , * args : typing . Any , ** kwargs : typing . Any ) -> typing . Any : \"\"\"Returns thread-safe class instance if exists. Parameters ---------- *args : typing.Any Argument to type call. **kwargs : typing.Any Keyword arguments to type call. Returns ------- typing.Any Class instance. \"\"\" if cls not in cls . _instances : with _SINGLETON_LOCK : if cls not in cls . _instances : cls . _instances [ cls ] = super () . __call__ ( * args , ** kwargs ) return cls . _instances [ cls ] __call__ ( * args , ** kwargs ) \u00a4 Returns thread-safe class instance if exists. PARAMETER DESCRIPTION *args Argument to type call. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to type call. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION typing . Any Class instance. Source code in multibar\\utils.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def __call__ ( cls , * args : typing . Any , ** kwargs : typing . Any ) -> typing . Any : \"\"\"Returns thread-safe class instance if exists. Parameters ---------- *args : typing.Any Argument to type call. **kwargs : typing.Any Keyword arguments to type call. Returns ------- typing.Any Class instance. \"\"\" if cls not in cls . _instances : with _SINGLETON_LOCK : if cls not in cls . _instances : cls . _instances [ cls ] = super () . __call__ ( * args , ** kwargs ) return cls . _instances [ cls ] cached_property \u00a4 Simple cached property implementation that sets in self.__dict__ function callback by function.__name__ key. Warning This implementation of cached_property will not work with slotted classes. Expand example of usage class Owner : '''Owner class.''' def __init__ ( self ) -> None : self . _hard_attribute = 1 def set_new_attribute ( self , new : typing . Any , / ) -> None : self . _hard_attribute = new @utils . cached_property def some_owner_hard_attribute ( self ) -> typing . Any : return self . _hard_attribute >>> own = Owner () >>> own . some_owner_hard_attribute 1 >>> own . set_new_attribute ( 2 ) >>> own . some_owner_hard_attribute 1 >>> cached_property . update_cache_for ( own , \"some_owner_hard_attribute\" ) >>> own . some_owner_hard_attribute 2 Source code in multibar\\utils.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 class cached_property : \"\"\"Simple cached property implementation that sets in `self.__dict__` function callback by `function.__name__` key. !!! warning This implementation of `cached_property` will not work with slotted classes. ??? example \"Expand example of usage\" ``` py hl_lines=\"15 16 17 18 19 20 21 22\" class Owner: '''Owner class.''' def __init__(self) -> None: self._hard_attribute = 1 def set_new_attribute(self, new: typing.Any, /) -> None: self._hard_attribute = new @utils.cached_property def some_owner_hard_attribute(self) -> typing.Any: return self._hard_attribute >>> own = Owner() >>> own.some_owner_hard_attribute 1 >>> own.set_new_attribute(2) >>> own.some_owner_hard_attribute 1 >>> cached_property.update_cache_for(own, \"some_owner_hard_attribute\") >>> own.some_owner_hard_attribute 2 ``` \"\"\" def __init__ ( self , func : typing . Callable [[ _InstanceT ], typing . Any ], / ) -> None : \"\"\" Parameters ---------- func : typing.Callable[[_InstanceT], typing.Any] Function to cache. \"\"\" self . func = func def __get__ ( self , instance : _InstanceT , owner : typing . Optional [ typing . Type [ typing . Any ]] = None , ) -> typing . Any : \"\"\"Returns cached function callback. Parameters ---------- instance : _InstanceT Property instance. owner : typing.Optional[typing.Type[typing.Any]] = None Property owner. \"\"\" result = instance . __dict__ [ self . func . __name__ ] = self . func ( instance ) return result @staticmethod def update_cache_for ( state : _InstanceT , prop_name : str , / ) -> None : \"\"\"Updates cached_property on instance by property name. Parameters ---------- state : _InstanceT Instance to update cached_property for prop_name : str Property name to update cache for. \"\"\" del state . __dict__ [ prop_name ] func = func instance-attribute \u00a4 __get__ ( instance , owner = None ) \u00a4 Returns cached function callback. PARAMETER DESCRIPTION instance Property instance. TYPE: _InstanceT owner Property owner. TYPE: typing . Optional [ typing . Type [ typing . Any ]] DEFAULT: None Source code in multibar\\utils.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def __get__ ( self , instance : _InstanceT , owner : typing . Optional [ typing . Type [ typing . Any ]] = None , ) -> typing . Any : \"\"\"Returns cached function callback. Parameters ---------- instance : _InstanceT Property instance. owner : typing.Optional[typing.Type[typing.Any]] = None Property owner. \"\"\" result = instance . __dict__ [ self . func . __name__ ] = self . func ( instance ) return result __init__ ( func ) \u00a4 PARAMETER DESCRIPTION func Function to cache. TYPE: typing . Callable [[ _InstanceT ], typing . Any ] Source code in multibar\\utils.py 102 103 104 105 106 107 108 109 def __init__ ( self , func : typing . Callable [[ _InstanceT ], typing . Any ], / ) -> None : \"\"\" Parameters ---------- func : typing.Callable[[_InstanceT], typing.Any] Function to cache. \"\"\" self . func = func update_cache_for ( state , prop_name ) staticmethod \u00a4 Updates cached_property on instance by property name. PARAMETER DESCRIPTION state Instance to update cached_property for TYPE: _InstanceT prop_name Property name to update cache for. TYPE: str Source code in multibar\\utils.py 128 129 130 131 132 133 134 135 136 137 138 139 @staticmethod def update_cache_for ( state : _InstanceT , prop_name : str , / ) -> None : \"\"\"Updates cached_property on instance by property name. Parameters ---------- state : _InstanceT Instance to update cached_property for prop_name : str Property name to update cache for. \"\"\" del state . __dict__ [ prop_name ] none_or ( alternative , actual ) \u00a4 Returns alternative value, if actual is None. PARAMETER DESCRIPTION alternative Alternative value that will be returned if _ActualT is None. TYPE: _AlternativeT actual Actual value that will be None. TYPE: typing . Union [ _ActualT , typing . Literal [None]] RETURNS DESCRIPTION typing . Union [ _AlternativeT , _ActualT ] Alternative value, if actual is None, otherwise actual . Source code in multibar\\utils.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def none_or ( alternative : _AlternativeT , actual : typing . Union [ _ActualT , typing . Literal [ None ]], / ) -> typing . Union [ _AlternativeT , _ActualT ]: \"\"\"Returns alternative value, if actual is None. Parameters ---------- alternative : _AlternativeT Alternative value that will be returned if `_ActualT` is None. actual : typing.Union[_ActualT, typing.Literal[None]] Actual value that will be None. Returns ------- typing.Union[_AlternativeT, _ActualT] `Alternative` value, if `actual` is None, otherwise `actual`. \"\"\" return alternative if actual is None else actual","title":"Utilities"},{"location":"utilities/#multibar.utils","text":"Python-Multibar project utilities.","title":"utils"},{"location":"utilities/#multibar.utils.__all__","text":"","title":"__all__"},{"location":"utilities/#multibar.utils.Singleton","text":"Bases: type Metaclass that implements Singleton pattern. Expand example of usage class Class ( metaclass = Singleton ): def __init__ ( self ) -> None : self . attribute = 1 >>> self = Class () >>> self2 = Class () >>> self2 . attribute 1 >>> self . attribute = 2 >>> self2 . attribute 2 ATTRIBUTE DESCRIPTION _instances Dict of instances, where key is Type[instance]. TYPE: dict[typing.Type[typing.Any], typing.Any] = {} Source code in multibar\\utils.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 class Singleton ( type ): \"\"\"Metaclass that implements Singleton pattern. ??? example \"Expand example of usage\" ```py hl_lines=\"7 8 9 10 11\" class Class(metaclass=Singleton): def __init__(self) -> None: self.attribute = 1 >>> self = Class() >>> self2 = Class() >>> self2.attribute 1 >>> self.attribute = 2 >>> self2.attribute 2 ``` Attributes ---------- _instances : dict[typing.Type[typing.Any], typing.Any] = {} Dict of instances, where key is Type[instance]. \"\"\" _instances : dict [ typing . Type [ typing . Any ], typing . Any ] = {} def __call__ ( cls , * args : typing . Any , ** kwargs : typing . Any ) -> typing . Any : \"\"\"Returns thread-safe class instance if exists. Parameters ---------- *args : typing.Any Argument to type call. **kwargs : typing.Any Keyword arguments to type call. Returns ------- typing.Any Class instance. \"\"\" if cls not in cls . _instances : with _SINGLETON_LOCK : if cls not in cls . _instances : cls . _instances [ cls ] = super () . __call__ ( * args , ** kwargs ) return cls . _instances [ cls ]","title":"Singleton"},{"location":"utilities/#multibar.utils.Singleton.__call__","text":"Returns thread-safe class instance if exists. PARAMETER DESCRIPTION *args Argument to type call. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to type call. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION typing . Any Class instance. Source code in multibar\\utils.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def __call__ ( cls , * args : typing . Any , ** kwargs : typing . Any ) -> typing . Any : \"\"\"Returns thread-safe class instance if exists. Parameters ---------- *args : typing.Any Argument to type call. **kwargs : typing.Any Keyword arguments to type call. Returns ------- typing.Any Class instance. \"\"\" if cls not in cls . _instances : with _SINGLETON_LOCK : if cls not in cls . _instances : cls . _instances [ cls ] = super () . __call__ ( * args , ** kwargs ) return cls . _instances [ cls ]","title":"__call__()"},{"location":"utilities/#multibar.utils.cached_property","text":"Simple cached property implementation that sets in self.__dict__ function callback by function.__name__ key. Warning This implementation of cached_property will not work with slotted classes. Expand example of usage class Owner : '''Owner class.''' def __init__ ( self ) -> None : self . _hard_attribute = 1 def set_new_attribute ( self , new : typing . Any , / ) -> None : self . _hard_attribute = new @utils . cached_property def some_owner_hard_attribute ( self ) -> typing . Any : return self . _hard_attribute >>> own = Owner () >>> own . some_owner_hard_attribute 1 >>> own . set_new_attribute ( 2 ) >>> own . some_owner_hard_attribute 1 >>> cached_property . update_cache_for ( own , \"some_owner_hard_attribute\" ) >>> own . some_owner_hard_attribute 2 Source code in multibar\\utils.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 class cached_property : \"\"\"Simple cached property implementation that sets in `self.__dict__` function callback by `function.__name__` key. !!! warning This implementation of `cached_property` will not work with slotted classes. ??? example \"Expand example of usage\" ``` py hl_lines=\"15 16 17 18 19 20 21 22\" class Owner: '''Owner class.''' def __init__(self) -> None: self._hard_attribute = 1 def set_new_attribute(self, new: typing.Any, /) -> None: self._hard_attribute = new @utils.cached_property def some_owner_hard_attribute(self) -> typing.Any: return self._hard_attribute >>> own = Owner() >>> own.some_owner_hard_attribute 1 >>> own.set_new_attribute(2) >>> own.some_owner_hard_attribute 1 >>> cached_property.update_cache_for(own, \"some_owner_hard_attribute\") >>> own.some_owner_hard_attribute 2 ``` \"\"\" def __init__ ( self , func : typing . Callable [[ _InstanceT ], typing . Any ], / ) -> None : \"\"\" Parameters ---------- func : typing.Callable[[_InstanceT], typing.Any] Function to cache. \"\"\" self . func = func def __get__ ( self , instance : _InstanceT , owner : typing . Optional [ typing . Type [ typing . Any ]] = None , ) -> typing . Any : \"\"\"Returns cached function callback. Parameters ---------- instance : _InstanceT Property instance. owner : typing.Optional[typing.Type[typing.Any]] = None Property owner. \"\"\" result = instance . __dict__ [ self . func . __name__ ] = self . func ( instance ) return result @staticmethod def update_cache_for ( state : _InstanceT , prop_name : str , / ) -> None : \"\"\"Updates cached_property on instance by property name. Parameters ---------- state : _InstanceT Instance to update cached_property for prop_name : str Property name to update cache for. \"\"\" del state . __dict__ [ prop_name ]","title":"cached_property"},{"location":"utilities/#multibar.utils.cached_property.func","text":"","title":"func"},{"location":"utilities/#multibar.utils.cached_property.__get__","text":"Returns cached function callback. PARAMETER DESCRIPTION instance Property instance. TYPE: _InstanceT owner Property owner. TYPE: typing . Optional [ typing . Type [ typing . Any ]] DEFAULT: None Source code in multibar\\utils.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def __get__ ( self , instance : _InstanceT , owner : typing . Optional [ typing . Type [ typing . Any ]] = None , ) -> typing . Any : \"\"\"Returns cached function callback. Parameters ---------- instance : _InstanceT Property instance. owner : typing.Optional[typing.Type[typing.Any]] = None Property owner. \"\"\" result = instance . __dict__ [ self . func . __name__ ] = self . func ( instance ) return result","title":"__get__()"},{"location":"utilities/#multibar.utils.cached_property.__init__","text":"PARAMETER DESCRIPTION func Function to cache. TYPE: typing . Callable [[ _InstanceT ], typing . Any ] Source code in multibar\\utils.py 102 103 104 105 106 107 108 109 def __init__ ( self , func : typing . Callable [[ _InstanceT ], typing . Any ], / ) -> None : \"\"\" Parameters ---------- func : typing.Callable[[_InstanceT], typing.Any] Function to cache. \"\"\" self . func = func","title":"__init__()"},{"location":"utilities/#multibar.utils.cached_property.update_cache_for","text":"Updates cached_property on instance by property name. PARAMETER DESCRIPTION state Instance to update cached_property for TYPE: _InstanceT prop_name Property name to update cache for. TYPE: str Source code in multibar\\utils.py 128 129 130 131 132 133 134 135 136 137 138 139 @staticmethod def update_cache_for ( state : _InstanceT , prop_name : str , / ) -> None : \"\"\"Updates cached_property on instance by property name. Parameters ---------- state : _InstanceT Instance to update cached_property for prop_name : str Property name to update cache for. \"\"\" del state . __dict__ [ prop_name ]","title":"update_cache_for()"},{"location":"utilities/#multibar.utils.none_or","text":"Returns alternative value, if actual is None. PARAMETER DESCRIPTION alternative Alternative value that will be returned if _ActualT is None. TYPE: _AlternativeT actual Actual value that will be None. TYPE: typing . Union [ _ActualT , typing . Literal [None]] RETURNS DESCRIPTION typing . Union [ _AlternativeT , _ActualT ] Alternative value, if actual is None, otherwise actual . Source code in multibar\\utils.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def none_or ( alternative : _AlternativeT , actual : typing . Union [ _ActualT , typing . Literal [ None ]], / ) -> typing . Union [ _AlternativeT , _ActualT ]: \"\"\"Returns alternative value, if actual is None. Parameters ---------- alternative : _AlternativeT Alternative value that will be returned if `_ActualT` is None. actual : typing.Union[_ActualT, typing.Literal[None]] Actual value that will be None. Returns ------- typing.Union[_AlternativeT, _ActualT] `Alternative` value, if `actual` is None, otherwise `actual`. \"\"\" return alternative if actual is None else actual","title":"none_or()"},{"location":"api/clients/","text":"multibar.api.clients \u00a4 Interfaces for progressbar clients. __all__ = ( 'ProgressbarClientAware' ) module-attribute \u00a4 ProgressbarClientAware \u00a4 Bases: abc . ABC Interface for implementing a progress client that adds new features. Source code in multibar\\api\\clients.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 class ProgressbarClientAware ( abc . ABC ): \"\"\"Interface for implementing a progress client that adds new features.\"\"\" __slots__ = () @abc . abstractmethod @typing . overload def get_progress ( self , start_value : int , end_value : int , / , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @abc . abstractmethod @typing . overload def get_progress ( self , start_value : int , end_value : int , / , * , length : int , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @abc . abstractmethod def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. Parameters ---------- start_value : int, / Start value (current progress) for progressbar math operations. end_value : int, / End value (needed progress) for progressbar math operations. length : int = 20, * Length of progressbar for progressbar math operations. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar instance. \"\"\" ... @abc . abstractmethod def set_hooks ( self , hooks : hooks_ . HooksAware , / ) -> ProgressbarClientAware : \"\"\"Sets hooks to the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to set. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" ... @abc . abstractmethod def update_hooks ( self , hooks : hooks_ . HooksAware , / ) -> ProgressbarClientAware : \"\"\"Updates hooks for the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to update. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" ... @property @abc . abstractmethod def hooks ( self ) -> hooks_ . HooksAware : \"\"\" Returns ------- hooks_.HooksAware Client hooks. \"\"\" ... @property @abc . abstractmethod def contract_manager ( self ) -> contracts . ContractManagerAware : \"\"\" Returns ------- contracts.ContractManagerAware Client contract manager for checks. \"\"\" ... @property @abc . abstractmethod def writer ( self ) -> writers . ProgressbarWriterAware : \"\"\" Returns ------- writers.ProgressbarWriterAware[sectors.AbstractSector] Progressbar writer for progress generating. \"\"\" ... __slots__ = () class-attribute \u00a4 contract_manager () abstractmethod property \u00a4 RETURNS DESCRIPTION contracts . ContractManagerAware Client contract manager for checks. Source code in multibar\\api\\clients.py 128 129 130 131 132 133 134 135 136 137 @property @abc . abstractmethod def contract_manager ( self ) -> contracts . ContractManagerAware : \"\"\" Returns ------- contracts.ContractManagerAware Client contract manager for checks. \"\"\" ... get_progress ( start_value , end_value , / , * , length = 20 ) abstractmethod \u00a4 Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. PARAMETER DESCRIPTION start_value Start value (current progress) for progressbar math operations. TYPE: int end_value End value (needed progress) for progressbar math operations. TYPE: int length Length of progressbar for progressbar math operations. TYPE: int DEFAULT: 20 RETURNS DESCRIPTION progressbars . ProgressbarAware [ sectors . AbstractSector ] Progressbar instance. Source code in multibar\\api\\clients.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 @abc . abstractmethod def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. Parameters ---------- start_value : int, / Start value (current progress) for progressbar math operations. end_value : int, / End value (needed progress) for progressbar math operations. length : int = 20, * Length of progressbar for progressbar math operations. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar instance. \"\"\" ... hooks () abstractmethod property \u00a4 RETURNS DESCRIPTION hooks_ . HooksAware Client hooks. Source code in multibar\\api\\clients.py 117 118 119 120 121 122 123 124 125 126 @property @abc . abstractmethod def hooks ( self ) -> hooks_ . HooksAware : \"\"\" Returns ------- hooks_.HooksAware Client hooks. \"\"\" ... set_hooks ( hooks ) abstractmethod \u00a4 Sets hooks to the client. PARAMETER DESCRIPTION hooks Any hooks to set. TYPE: hooks_ . HooksAware RETURNS DESCRIPTION Self ProgressbarClient object to allow fluent-style. Source code in multibar\\api\\clients.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @abc . abstractmethod def set_hooks ( self , hooks : hooks_ . HooksAware , / ) -> ProgressbarClientAware : \"\"\"Sets hooks to the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to set. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" ... update_hooks ( hooks ) abstractmethod \u00a4 Updates hooks for the client. PARAMETER DESCRIPTION hooks Any hooks to update. TYPE: hooks_ . HooksAware RETURNS DESCRIPTION Self ProgressbarClient object to allow fluent-style. Source code in multibar\\api\\clients.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 @abc . abstractmethod def update_hooks ( self , hooks : hooks_ . HooksAware , / ) -> ProgressbarClientAware : \"\"\"Updates hooks for the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to update. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" ... writer () abstractmethod property \u00a4 RETURNS DESCRIPTION writers . ProgressbarWriterAware [ sectors . AbstractSector ] Progressbar writer for progress generating. Source code in multibar\\api\\clients.py 139 140 141 142 143 144 145 146 147 148 @property @abc . abstractmethod def writer ( self ) -> writers . ProgressbarWriterAware : \"\"\" Returns ------- writers.ProgressbarWriterAware[sectors.AbstractSector] Progressbar writer for progress generating. \"\"\" ...","title":"Clients"},{"location":"api/clients/#multibar.api.clients","text":"Interfaces for progressbar clients.","title":"clients"},{"location":"api/clients/#multibar.api.clients.__all__","text":"","title":"__all__"},{"location":"api/clients/#multibar.api.clients.ProgressbarClientAware","text":"Bases: abc . ABC Interface for implementing a progress client that adds new features. Source code in multibar\\api\\clients.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 class ProgressbarClientAware ( abc . ABC ): \"\"\"Interface for implementing a progress client that adds new features.\"\"\" __slots__ = () @abc . abstractmethod @typing . overload def get_progress ( self , start_value : int , end_value : int , / , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @abc . abstractmethod @typing . overload def get_progress ( self , start_value : int , end_value : int , / , * , length : int , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @abc . abstractmethod def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. Parameters ---------- start_value : int, / Start value (current progress) for progressbar math operations. end_value : int, / End value (needed progress) for progressbar math operations. length : int = 20, * Length of progressbar for progressbar math operations. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar instance. \"\"\" ... @abc . abstractmethod def set_hooks ( self , hooks : hooks_ . HooksAware , / ) -> ProgressbarClientAware : \"\"\"Sets hooks to the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to set. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" ... @abc . abstractmethod def update_hooks ( self , hooks : hooks_ . HooksAware , / ) -> ProgressbarClientAware : \"\"\"Updates hooks for the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to update. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" ... @property @abc . abstractmethod def hooks ( self ) -> hooks_ . HooksAware : \"\"\" Returns ------- hooks_.HooksAware Client hooks. \"\"\" ... @property @abc . abstractmethod def contract_manager ( self ) -> contracts . ContractManagerAware : \"\"\" Returns ------- contracts.ContractManagerAware Client contract manager for checks. \"\"\" ... @property @abc . abstractmethod def writer ( self ) -> writers . ProgressbarWriterAware : \"\"\" Returns ------- writers.ProgressbarWriterAware[sectors.AbstractSector] Progressbar writer for progress generating. \"\"\" ...","title":"ProgressbarClientAware"},{"location":"api/clients/#multibar.api.clients.ProgressbarClientAware.__slots__","text":"","title":"__slots__"},{"location":"api/clients/#multibar.api.clients.ProgressbarClientAware.contract_manager","text":"RETURNS DESCRIPTION contracts . ContractManagerAware Client contract manager for checks. Source code in multibar\\api\\clients.py 128 129 130 131 132 133 134 135 136 137 @property @abc . abstractmethod def contract_manager ( self ) -> contracts . ContractManagerAware : \"\"\" Returns ------- contracts.ContractManagerAware Client contract manager for checks. \"\"\" ...","title":"contract_manager()"},{"location":"api/clients/#multibar.api.clients.ProgressbarClientAware.get_progress","text":"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. PARAMETER DESCRIPTION start_value Start value (current progress) for progressbar math operations. TYPE: int end_value End value (needed progress) for progressbar math operations. TYPE: int length Length of progressbar for progressbar math operations. TYPE: int DEFAULT: 20 RETURNS DESCRIPTION progressbars . ProgressbarAware [ sectors . AbstractSector ] Progressbar instance. Source code in multibar\\api\\clients.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 @abc . abstractmethod def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. Parameters ---------- start_value : int, / Start value (current progress) for progressbar math operations. end_value : int, / End value (needed progress) for progressbar math operations. length : int = 20, * Length of progressbar for progressbar math operations. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar instance. \"\"\" ...","title":"get_progress()"},{"location":"api/clients/#multibar.api.clients.ProgressbarClientAware.hooks","text":"RETURNS DESCRIPTION hooks_ . HooksAware Client hooks. Source code in multibar\\api\\clients.py 117 118 119 120 121 122 123 124 125 126 @property @abc . abstractmethod def hooks ( self ) -> hooks_ . HooksAware : \"\"\" Returns ------- hooks_.HooksAware Client hooks. \"\"\" ...","title":"hooks()"},{"location":"api/clients/#multibar.api.clients.ProgressbarClientAware.set_hooks","text":"Sets hooks to the client. PARAMETER DESCRIPTION hooks Any hooks to set. TYPE: hooks_ . HooksAware RETURNS DESCRIPTION Self ProgressbarClient object to allow fluent-style. Source code in multibar\\api\\clients.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @abc . abstractmethod def set_hooks ( self , hooks : hooks_ . HooksAware , / ) -> ProgressbarClientAware : \"\"\"Sets hooks to the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to set. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" ...","title":"set_hooks()"},{"location":"api/clients/#multibar.api.clients.ProgressbarClientAware.update_hooks","text":"Updates hooks for the client. PARAMETER DESCRIPTION hooks Any hooks to update. TYPE: hooks_ . HooksAware RETURNS DESCRIPTION Self ProgressbarClient object to allow fluent-style. Source code in multibar\\api\\clients.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 @abc . abstractmethod def update_hooks ( self , hooks : hooks_ . HooksAware , / ) -> ProgressbarClientAware : \"\"\"Updates hooks for the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to update. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" ...","title":"update_hooks()"},{"location":"api/clients/#multibar.api.clients.ProgressbarClientAware.writer","text":"RETURNS DESCRIPTION writers . ProgressbarWriterAware [ sectors . AbstractSector ] Progressbar writer for progress generating. Source code in multibar\\api\\clients.py 139 140 141 142 143 144 145 146 147 148 @property @abc . abstractmethod def writer ( self ) -> writers . ProgressbarWriterAware : \"\"\" Returns ------- writers.ProgressbarWriterAware[sectors.AbstractSector] Progressbar writer for progress generating. \"\"\" ...","title":"writer()"},{"location":"api/contracts/","text":"multibar.api.contracts \u00a4 Interfaces for progressbar contracts. __all__ = ( 'ContractAware' , 'ContractCheck' , 'ContractManagerAware' ) module-attribute \u00a4 ContractAware \u00a4 Bases: abc . ABC Interface for contract implementations. Source code in multibar\\api\\contracts.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class ContractAware ( abc . ABC ): \"\"\"Interface for contract implementations.\"\"\" __slots__ = () @abc . abstractmethod def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> ContractCheck : \"\"\"Checks contract for errors and warnings. Parameters ---------- *args : typing.Any Arguments to check. **kwargs : typing.Any Keyword arguments to check. Returns ------- ContractCheck Contract response. \"\"\" ... @impure @abc . abstractmethod def render_terminated_contract ( self , check : ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : \"\"\"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- check : ContractCheck Contract response. raise_errors : bool If True, will raise errors when contract is broken. Returns ------- typing.Any Any value depending on context and implementation. \"\"\" ... __slots__ = () class-attribute \u00a4 check ( * args , ** kwargs ) abstractmethod \u00a4 Checks contract for errors and warnings. PARAMETER DESCRIPTION *args Arguments to check. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to check. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION ContractCheck Contract response. Source code in multibar\\api\\contracts.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 @abc . abstractmethod def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> ContractCheck : \"\"\"Checks contract for errors and warnings. Parameters ---------- *args : typing.Any Arguments to check. **kwargs : typing.Any Keyword arguments to check. Returns ------- ContractCheck Contract response. \"\"\" ... render_terminated_contract ( check , / , * , raise_errors ) abstractmethod \u00a4 Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. PARAMETER DESCRIPTION check Contract response. TYPE: ContractCheck raise_errors If True, will raise errors when contract is broken. TYPE: bool RETURNS DESCRIPTION typing . Any Any value depending on context and implementation. Source code in multibar\\api\\contracts.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @impure @abc . abstractmethod def render_terminated_contract ( self , check : ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : \"\"\"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- check : ContractCheck Contract response. raise_errors : bool If True, will raise errors when contract is broken. Returns ------- typing.Any Any value depending on context and implementation. \"\"\" ... ContractCheck dataclass \u00a4 Response for contracts. Source code in multibar\\api\\contracts.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @dataclasses . dataclass class ContractCheck : \"\"\"Response for contracts.\"\"\" kept : bool \"\"\"True if the contract is not broken (contains no errors or warnings).\"\"\" metadata : typing . MutableMapping [ typing . Any , typing . Any ] = dataclasses . field ( default_factory = dict ) \"\"\"Contract metadata to check.\"\"\" warnings : list [ str ] = dataclasses . field ( default_factory = list ) \"\"\"Contract warnings.\"\"\" errors : list [ str ] = dataclasses . field ( default_factory = list ) \"\"\"Contract errors.\"\"\" @classmethod def done ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , ) -> ContractCheck : \"\"\"Alternative constructor that used if contract is kept. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. Returns ------- ContractCheck Contract response. \"\"\" return cls ( kept = True , metadata = utils . none_or ({}, metadata )) @classmethod @typing . no_type_check def terminated ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , warnings : typing . Optional [ list [ str ]] = None , errors : typing . Optional [ list [ str ]] = None , ) -> ContractCheck : \"\"\"Alternative constructor that used if contract is broken. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. warnings : typing.Optional[list[str]] = None Warnings to return. errors : typing.Optional[list[str]] = None Errors to return. Returns ------- ContractCheck Contract response. \"\"\" return cls ( kept = False , metadata = utils . none_or ({}, metadata ), warnings = utils . none_or ([], warnings ), errors = utils . none_or ([], errors ), ) errors : list [ str ] = dataclasses . field ( default_factory = list ) class-attribute \u00a4 Contract errors. kept : bool class-attribute \u00a4 True if the contract is not broken (contains no errors or warnings). metadata : typing . MutableMapping [ typing . Any , typing . Any ] = dataclasses . field ( default_factory = dict ) class-attribute \u00a4 Contract metadata to check. warnings : list [ str ] = dataclasses . field ( default_factory = list ) class-attribute \u00a4 Contract warnings. done ( metadata = None ) classmethod \u00a4 Alternative constructor that used if contract is kept. PARAMETER DESCRIPTION metadata Contract metadata to return. TYPE: typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] DEFAULT: None RETURNS DESCRIPTION ContractCheck Contract response. Source code in multibar\\api\\contracts.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @classmethod def done ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , ) -> ContractCheck : \"\"\"Alternative constructor that used if contract is kept. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. Returns ------- ContractCheck Contract response. \"\"\" return cls ( kept = True , metadata = utils . none_or ({}, metadata )) terminated ( metadata = None , warnings = None , errors = None ) classmethod \u00a4 Alternative constructor that used if contract is broken. PARAMETER DESCRIPTION metadata Contract metadata to return. TYPE: typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] DEFAULT: None warnings Warnings to return. TYPE: typing . Optional [ list [ str ]] DEFAULT: None errors Errors to return. TYPE: typing . Optional [ list [ str ]] DEFAULT: None RETURNS DESCRIPTION ContractCheck Contract response. Source code in multibar\\api\\contracts.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @classmethod @typing . no_type_check def terminated ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , warnings : typing . Optional [ list [ str ]] = None , errors : typing . Optional [ list [ str ]] = None , ) -> ContractCheck : \"\"\"Alternative constructor that used if contract is broken. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. warnings : typing.Optional[list[str]] = None Warnings to return. errors : typing.Optional[list[str]] = None Errors to return. Returns ------- ContractCheck Contract response. \"\"\" return cls ( kept = False , metadata = utils . none_or ({}, metadata ), warnings = utils . none_or ([], warnings ), errors = utils . none_or ([], errors ), ) ContractManagerAware \u00a4 Bases: abc . ABC Interface for contract manager implementations. Source code in multibar\\api\\contracts.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 class ContractManagerAware ( abc . ABC ): \"\"\"Interface for contract manager implementations.\"\"\" __slots__ = () @abc . abstractmethod def check_contract ( self , contract : ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : \"\"\"Checks contract for any errors or warnings. Parameters ---------- contract : ContractAware Contract to check. *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. Returns ------- None \"\"\" ... @abc . abstractmethod def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Checks all contracts. *args: typing.Any Arguments to contracts check. **kwargs: typing.Any Keyword arguments to contracts check. Returns ------- None \"\"\" ... @abc . abstractmethod def subscribe ( self , contract : ContractAware , / ) -> None : \"\"\"Subscribes for contract. Parameters ---------- contract : ContractAware Contract to subscribe. Returns ------- None \"\"\" ... @abc . abstractmethod def terminate ( self , contract : ContractAware , / ) -> None : \"\"\"Terminates any contract. Parameters ---------- contract : ContractAware Contract to terminate. Returns ------- None \"\"\" ... @abc . abstractmethod def terminate_all ( self ) -> None : \"\"\"Terminates all contracts. Returns ------- None \"\"\" ... @abc . abstractmethod def set_raise_errors ( self , value : bool , / ) -> None : \"\"\"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- value : bool Raise errors boolean value. Returns ------- None \"\"\" ... @property @abc . abstractmethod def contracts ( self ) -> collections . abc . Sequence [ ContractAware ]: \"\"\" Returns ------- collections.abc.Sequence[ContractAware] Sequence of the contracts. \"\"\" ... @property @abc . abstractmethod def raise_errors ( self ) -> bool : \"\"\" Returns ------- bool Raise errors boolean value. \"\"\" ... __slots__ = () class-attribute \u00a4 check_contract ( contract , / , * args , ** kwargs ) abstractmethod \u00a4 Checks contract for any errors or warnings. PARAMETER DESCRIPTION contract Contract to check. TYPE: ContractAware *args Arguments to contract check. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to contract check. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\api\\contracts.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @abc . abstractmethod def check_contract ( self , contract : ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : \"\"\"Checks contract for any errors or warnings. Parameters ---------- contract : ContractAware Contract to check. *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. Returns ------- None \"\"\" ... check_contracts ( * args , ** kwargs ) abstractmethod \u00a4 Checks all contracts. args: typing.Any Arguments to contracts check. *kwargs: typing.Any Keyword arguments to contracts check. RETURNS DESCRIPTION None Source code in multibar\\api\\contracts.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 @abc . abstractmethod def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Checks all contracts. *args: typing.Any Arguments to contracts check. **kwargs: typing.Any Keyword arguments to contracts check. Returns ------- None \"\"\" ... contracts () abstractmethod property \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ ContractAware ] Sequence of the contracts. Source code in multibar\\api\\contracts.py 255 256 257 258 259 260 261 262 263 264 @property @abc . abstractmethod def contracts ( self ) -> collections . abc . Sequence [ ContractAware ]: \"\"\" Returns ------- collections.abc.Sequence[ContractAware] Sequence of the contracts. \"\"\" ... raise_errors () abstractmethod property \u00a4 RETURNS DESCRIPTION bool Raise errors boolean value. Source code in multibar\\api\\contracts.py 266 267 268 269 270 271 272 273 274 275 @property @abc . abstractmethod def raise_errors ( self ) -> bool : \"\"\" Returns ------- bool Raise errors boolean value. \"\"\" ... set_raise_errors ( value ) abstractmethod \u00a4 Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. PARAMETER DESCRIPTION value Raise errors boolean value. TYPE: bool RETURNS DESCRIPTION None Source code in multibar\\api\\contracts.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 @abc . abstractmethod def set_raise_errors ( self , value : bool , / ) -> None : \"\"\"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- value : bool Raise errors boolean value. Returns ------- None \"\"\" ... subscribe ( contract ) abstractmethod \u00a4 Subscribes for contract. PARAMETER DESCRIPTION contract Contract to subscribe. TYPE: ContractAware RETURNS DESCRIPTION None Source code in multibar\\api\\contracts.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 @abc . abstractmethod def subscribe ( self , contract : ContractAware , / ) -> None : \"\"\"Subscribes for contract. Parameters ---------- contract : ContractAware Contract to subscribe. Returns ------- None \"\"\" ... terminate ( contract ) abstractmethod \u00a4 Terminates any contract. PARAMETER DESCRIPTION contract Contract to terminate. TYPE: ContractAware RETURNS DESCRIPTION None Source code in multibar\\api\\contracts.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 @abc . abstractmethod def terminate ( self , contract : ContractAware , / ) -> None : \"\"\"Terminates any contract. Parameters ---------- contract : ContractAware Contract to terminate. Returns ------- None \"\"\" ... terminate_all () abstractmethod \u00a4 Terminates all contracts. RETURNS DESCRIPTION None Source code in multibar\\api\\contracts.py 228 229 230 231 232 233 234 235 236 @abc . abstractmethod def terminate_all ( self ) -> None : \"\"\"Terminates all contracts. Returns ------- None \"\"\" ...","title":"Contracts"},{"location":"api/contracts/#multibar.api.contracts","text":"Interfaces for progressbar contracts.","title":"contracts"},{"location":"api/contracts/#multibar.api.contracts.__all__","text":"","title":"__all__"},{"location":"api/contracts/#multibar.api.contracts.ContractAware","text":"Bases: abc . ABC Interface for contract implementations. Source code in multibar\\api\\contracts.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class ContractAware ( abc . ABC ): \"\"\"Interface for contract implementations.\"\"\" __slots__ = () @abc . abstractmethod def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> ContractCheck : \"\"\"Checks contract for errors and warnings. Parameters ---------- *args : typing.Any Arguments to check. **kwargs : typing.Any Keyword arguments to check. Returns ------- ContractCheck Contract response. \"\"\" ... @impure @abc . abstractmethod def render_terminated_contract ( self , check : ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : \"\"\"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- check : ContractCheck Contract response. raise_errors : bool If True, will raise errors when contract is broken. Returns ------- typing.Any Any value depending on context and implementation. \"\"\" ...","title":"ContractAware"},{"location":"api/contracts/#multibar.api.contracts.ContractAware.__slots__","text":"","title":"__slots__"},{"location":"api/contracts/#multibar.api.contracts.ContractAware.check","text":"Checks contract for errors and warnings. PARAMETER DESCRIPTION *args Arguments to check. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to check. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION ContractCheck Contract response. Source code in multibar\\api\\contracts.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 @abc . abstractmethod def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> ContractCheck : \"\"\"Checks contract for errors and warnings. Parameters ---------- *args : typing.Any Arguments to check. **kwargs : typing.Any Keyword arguments to check. Returns ------- ContractCheck Contract response. \"\"\" ...","title":"check()"},{"location":"api/contracts/#multibar.api.contracts.ContractAware.render_terminated_contract","text":"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. PARAMETER DESCRIPTION check Contract response. TYPE: ContractCheck raise_errors If True, will raise errors when contract is broken. TYPE: bool RETURNS DESCRIPTION typing . Any Any value depending on context and implementation. Source code in multibar\\api\\contracts.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @impure @abc . abstractmethod def render_terminated_contract ( self , check : ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : \"\"\"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- check : ContractCheck Contract response. raise_errors : bool If True, will raise errors when contract is broken. Returns ------- typing.Any Any value depending on context and implementation. \"\"\" ...","title":"render_terminated_contract()"},{"location":"api/contracts/#multibar.api.contracts.ContractCheck","text":"Response for contracts. Source code in multibar\\api\\contracts.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @dataclasses . dataclass class ContractCheck : \"\"\"Response for contracts.\"\"\" kept : bool \"\"\"True if the contract is not broken (contains no errors or warnings).\"\"\" metadata : typing . MutableMapping [ typing . Any , typing . Any ] = dataclasses . field ( default_factory = dict ) \"\"\"Contract metadata to check.\"\"\" warnings : list [ str ] = dataclasses . field ( default_factory = list ) \"\"\"Contract warnings.\"\"\" errors : list [ str ] = dataclasses . field ( default_factory = list ) \"\"\"Contract errors.\"\"\" @classmethod def done ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , ) -> ContractCheck : \"\"\"Alternative constructor that used if contract is kept. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. Returns ------- ContractCheck Contract response. \"\"\" return cls ( kept = True , metadata = utils . none_or ({}, metadata )) @classmethod @typing . no_type_check def terminated ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , warnings : typing . Optional [ list [ str ]] = None , errors : typing . Optional [ list [ str ]] = None , ) -> ContractCheck : \"\"\"Alternative constructor that used if contract is broken. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. warnings : typing.Optional[list[str]] = None Warnings to return. errors : typing.Optional[list[str]] = None Errors to return. Returns ------- ContractCheck Contract response. \"\"\" return cls ( kept = False , metadata = utils . none_or ({}, metadata ), warnings = utils . none_or ([], warnings ), errors = utils . none_or ([], errors ), )","title":"ContractCheck"},{"location":"api/contracts/#multibar.api.contracts.ContractCheck.errors","text":"Contract errors.","title":"errors"},{"location":"api/contracts/#multibar.api.contracts.ContractCheck.kept","text":"True if the contract is not broken (contains no errors or warnings).","title":"kept"},{"location":"api/contracts/#multibar.api.contracts.ContractCheck.metadata","text":"Contract metadata to check.","title":"metadata"},{"location":"api/contracts/#multibar.api.contracts.ContractCheck.warnings","text":"Contract warnings.","title":"warnings"},{"location":"api/contracts/#multibar.api.contracts.ContractCheck.done","text":"Alternative constructor that used if contract is kept. PARAMETER DESCRIPTION metadata Contract metadata to return. TYPE: typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] DEFAULT: None RETURNS DESCRIPTION ContractCheck Contract response. Source code in multibar\\api\\contracts.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @classmethod def done ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , ) -> ContractCheck : \"\"\"Alternative constructor that used if contract is kept. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. Returns ------- ContractCheck Contract response. \"\"\" return cls ( kept = True , metadata = utils . none_or ({}, metadata ))","title":"done()"},{"location":"api/contracts/#multibar.api.contracts.ContractCheck.terminated","text":"Alternative constructor that used if contract is broken. PARAMETER DESCRIPTION metadata Contract metadata to return. TYPE: typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] DEFAULT: None warnings Warnings to return. TYPE: typing . Optional [ list [ str ]] DEFAULT: None errors Errors to return. TYPE: typing . Optional [ list [ str ]] DEFAULT: None RETURNS DESCRIPTION ContractCheck Contract response. Source code in multibar\\api\\contracts.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @classmethod @typing . no_type_check def terminated ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , warnings : typing . Optional [ list [ str ]] = None , errors : typing . Optional [ list [ str ]] = None , ) -> ContractCheck : \"\"\"Alternative constructor that used if contract is broken. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. warnings : typing.Optional[list[str]] = None Warnings to return. errors : typing.Optional[list[str]] = None Errors to return. Returns ------- ContractCheck Contract response. \"\"\" return cls ( kept = False , metadata = utils . none_or ({}, metadata ), warnings = utils . none_or ([], warnings ), errors = utils . none_or ([], errors ), )","title":"terminated()"},{"location":"api/contracts/#multibar.api.contracts.ContractManagerAware","text":"Bases: abc . ABC Interface for contract manager implementations. Source code in multibar\\api\\contracts.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 class ContractManagerAware ( abc . ABC ): \"\"\"Interface for contract manager implementations.\"\"\" __slots__ = () @abc . abstractmethod def check_contract ( self , contract : ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : \"\"\"Checks contract for any errors or warnings. Parameters ---------- contract : ContractAware Contract to check. *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. Returns ------- None \"\"\" ... @abc . abstractmethod def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Checks all contracts. *args: typing.Any Arguments to contracts check. **kwargs: typing.Any Keyword arguments to contracts check. Returns ------- None \"\"\" ... @abc . abstractmethod def subscribe ( self , contract : ContractAware , / ) -> None : \"\"\"Subscribes for contract. Parameters ---------- contract : ContractAware Contract to subscribe. Returns ------- None \"\"\" ... @abc . abstractmethod def terminate ( self , contract : ContractAware , / ) -> None : \"\"\"Terminates any contract. Parameters ---------- contract : ContractAware Contract to terminate. Returns ------- None \"\"\" ... @abc . abstractmethod def terminate_all ( self ) -> None : \"\"\"Terminates all contracts. Returns ------- None \"\"\" ... @abc . abstractmethod def set_raise_errors ( self , value : bool , / ) -> None : \"\"\"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- value : bool Raise errors boolean value. Returns ------- None \"\"\" ... @property @abc . abstractmethod def contracts ( self ) -> collections . abc . Sequence [ ContractAware ]: \"\"\" Returns ------- collections.abc.Sequence[ContractAware] Sequence of the contracts. \"\"\" ... @property @abc . abstractmethod def raise_errors ( self ) -> bool : \"\"\" Returns ------- bool Raise errors boolean value. \"\"\" ...","title":"ContractManagerAware"},{"location":"api/contracts/#multibar.api.contracts.ContractManagerAware.__slots__","text":"","title":"__slots__"},{"location":"api/contracts/#multibar.api.contracts.ContractManagerAware.check_contract","text":"Checks contract for any errors or warnings. PARAMETER DESCRIPTION contract Contract to check. TYPE: ContractAware *args Arguments to contract check. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to contract check. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\api\\contracts.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @abc . abstractmethod def check_contract ( self , contract : ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : \"\"\"Checks contract for any errors or warnings. Parameters ---------- contract : ContractAware Contract to check. *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. Returns ------- None \"\"\" ...","title":"check_contract()"},{"location":"api/contracts/#multibar.api.contracts.ContractManagerAware.check_contracts","text":"Checks all contracts. args: typing.Any Arguments to contracts check. *kwargs: typing.Any Keyword arguments to contracts check. RETURNS DESCRIPTION None Source code in multibar\\api\\contracts.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 @abc . abstractmethod def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Checks all contracts. *args: typing.Any Arguments to contracts check. **kwargs: typing.Any Keyword arguments to contracts check. Returns ------- None \"\"\" ...","title":"check_contracts()"},{"location":"api/contracts/#multibar.api.contracts.ContractManagerAware.contracts","text":"RETURNS DESCRIPTION collections . abc . Sequence [ ContractAware ] Sequence of the contracts. Source code in multibar\\api\\contracts.py 255 256 257 258 259 260 261 262 263 264 @property @abc . abstractmethod def contracts ( self ) -> collections . abc . Sequence [ ContractAware ]: \"\"\" Returns ------- collections.abc.Sequence[ContractAware] Sequence of the contracts. \"\"\" ...","title":"contracts()"},{"location":"api/contracts/#multibar.api.contracts.ContractManagerAware.raise_errors","text":"RETURNS DESCRIPTION bool Raise errors boolean value. Source code in multibar\\api\\contracts.py 266 267 268 269 270 271 272 273 274 275 @property @abc . abstractmethod def raise_errors ( self ) -> bool : \"\"\" Returns ------- bool Raise errors boolean value. \"\"\" ...","title":"raise_errors()"},{"location":"api/contracts/#multibar.api.contracts.ContractManagerAware.set_raise_errors","text":"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. PARAMETER DESCRIPTION value Raise errors boolean value. TYPE: bool RETURNS DESCRIPTION None Source code in multibar\\api\\contracts.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 @abc . abstractmethod def set_raise_errors ( self , value : bool , / ) -> None : \"\"\"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- value : bool Raise errors boolean value. Returns ------- None \"\"\" ...","title":"set_raise_errors()"},{"location":"api/contracts/#multibar.api.contracts.ContractManagerAware.subscribe","text":"Subscribes for contract. PARAMETER DESCRIPTION contract Contract to subscribe. TYPE: ContractAware RETURNS DESCRIPTION None Source code in multibar\\api\\contracts.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 @abc . abstractmethod def subscribe ( self , contract : ContractAware , / ) -> None : \"\"\"Subscribes for contract. Parameters ---------- contract : ContractAware Contract to subscribe. Returns ------- None \"\"\" ...","title":"subscribe()"},{"location":"api/contracts/#multibar.api.contracts.ContractManagerAware.terminate","text":"Terminates any contract. PARAMETER DESCRIPTION contract Contract to terminate. TYPE: ContractAware RETURNS DESCRIPTION None Source code in multibar\\api\\contracts.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 @abc . abstractmethod def terminate ( self , contract : ContractAware , / ) -> None : \"\"\"Terminates any contract. Parameters ---------- contract : ContractAware Contract to terminate. Returns ------- None \"\"\" ...","title":"terminate()"},{"location":"api/contracts/#multibar.api.contracts.ContractManagerAware.terminate_all","text":"Terminates all contracts. RETURNS DESCRIPTION None Source code in multibar\\api\\contracts.py 228 229 230 231 232 233 234 235 236 @abc . abstractmethod def terminate_all ( self ) -> None : \"\"\"Terminates all contracts. Returns ------- None \"\"\" ...","title":"terminate_all()"},{"location":"api/hooks/","text":"multibar.api.hooks \u00a4 Interfaces for progressbar hooks. __all__ = ( 'HooksAware' ) module-attribute \u00a4 HooksAware \u00a4 Bases: abc . ABC Interface to progress hooks implementation. Source code in multibar\\api\\hooks.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 class HooksAware ( abc . ABC ): \"\"\"Interface to progress hooks implementation.\"\"\" __slots__ = () @abc . abstractmethod def __len__ ( self ) -> int : \"\"\" Returns ------- int Length of all hooks. \"\"\" ... @abc . abstractmethod def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> HooksAware : \"\"\"Adds hooks to the client. Parameters ---------- client : clients.ProgressbarClientAware, / Client to add. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def update ( self , other : HooksAware , / ) -> HooksAware : \"\"\"Updates self hooks from other hooks object. Parameters ---------- other : HooksAware, / Other hooks object to update. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def add_pre_execution ( self , callback : types . HookSignatureType , / ) -> HooksAware : \"\"\"Adds pre-execution callback. Parameters ---------- callback : HookSignatureType, / Pre-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def add_post_execution ( self , callback : types . HookSignatureType , / ) -> HooksAware : \"\"\"Adds post-execution callback. Parameters ---------- callback : HookSignatureType, / Post-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def add_on_error ( self , callback : types . HookSignatureType , / ) -> HooksAware : \"\"\"Adds on-error callback. Parameters ---------- callback : HookSignatureType, / On-error callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all post-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" ... @abc . abstractmethod def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all pre-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" ... @abc . abstractmethod def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all on-error callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" ... @property @abc . abstractmethod def pre_execution_hooks ( self ) -> collections . abc . Sequence [ types . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of pre-execution hooks. \"\"\" ... @property @abc . abstractmethod def post_execution_hooks ( self ) -> collections . abc . Sequence [ types . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of post-execution hooks. \"\"\" ... @property @abc . abstractmethod def on_error_hooks ( self ) -> collections . abc . Sequence [ types . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of on-error hooks. \"\"\" ... __slots__ = () class-attribute \u00a4 __len__ () abstractmethod \u00a4 RETURNS DESCRIPTION int Length of all hooks. Source code in multibar\\api\\hooks.py 36 37 38 39 40 41 42 43 44 @abc . abstractmethod def __len__ ( self ) -> int : \"\"\" Returns ------- int Length of all hooks. \"\"\" ... add_on_error ( callback ) abstractmethod \u00a4 Adds on-error callback. PARAMETER DESCRIPTION callback On-error callback. TYPE: HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @abc . abstractmethod def add_on_error ( self , callback : types . HookSignatureType , / ) -> HooksAware : \"\"\"Adds on-error callback. Parameters ---------- callback : HookSignatureType, / On-error callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... add_post_execution ( callback ) abstractmethod \u00a4 Adds post-execution callback. PARAMETER DESCRIPTION callback Post-execution callback. TYPE: HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @abc . abstractmethod def add_post_execution ( self , callback : types . HookSignatureType , / ) -> HooksAware : \"\"\"Adds post-execution callback. Parameters ---------- callback : HookSignatureType, / Post-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... add_pre_execution ( callback ) abstractmethod \u00a4 Adds pre-execution callback. PARAMETER DESCRIPTION callback Pre-execution callback. TYPE: HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @abc . abstractmethod def add_pre_execution ( self , callback : types . HookSignatureType , / ) -> HooksAware : \"\"\"Adds pre-execution callback. Parameters ---------- callback : HookSignatureType, / Pre-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... add_to_client ( client ) abstractmethod \u00a4 Adds hooks to the client. PARAMETER DESCRIPTION client Client to add. TYPE: clients . ProgressbarClientAware RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @abc . abstractmethod def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> HooksAware : \"\"\"Adds hooks to the client. Parameters ---------- client : clients.ProgressbarClientAware, / Client to add. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... on_error_hooks () abstractmethod property \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ HookSignatureType ] Sequence of on-error hooks. Source code in multibar\\api\\hooks.py 199 200 201 202 203 204 205 206 207 208 @property @abc . abstractmethod def on_error_hooks ( self ) -> collections . abc . Sequence [ types . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of on-error hooks. \"\"\" ... post_execution_hooks () abstractmethod property \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ HookSignatureType ] Sequence of post-execution hooks. Source code in multibar\\api\\hooks.py 188 189 190 191 192 193 194 195 196 197 @property @abc . abstractmethod def post_execution_hooks ( self ) -> collections . abc . Sequence [ types . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of post-execution hooks. \"\"\" ... pre_execution_hooks () abstractmethod property \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ HookSignatureType ] Sequence of pre-execution hooks. Source code in multibar\\api\\hooks.py 177 178 179 180 181 182 183 184 185 186 @property @abc . abstractmethod def pre_execution_hooks ( self ) -> collections . abc . Sequence [ types . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of pre-execution hooks. \"\"\" ... trigger_on_error ( * args , ** kwargs ) abstractmethod \u00a4 Triggers all on-error callbacks. PARAMETER DESCRIPTION *args Arguments to trigger. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to trigger. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\api\\hooks.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 @abc . abstractmethod def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all on-error callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" ... trigger_post_execution ( * args , ** kwargs ) abstractmethod \u00a4 Triggers all post-execution callbacks. PARAMETER DESCRIPTION *args Arguments to trigger. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to trigger. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\api\\hooks.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @abc . abstractmethod def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all post-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" ... trigger_pre_execution ( * args , ** kwargs ) abstractmethod \u00a4 Triggers all pre-execution callbacks. PARAMETER DESCRIPTION *args Arguments to trigger. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to trigger. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\api\\hooks.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 @abc . abstractmethod def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all pre-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" ... update ( other ) abstractmethod \u00a4 Updates self hooks from other hooks object. PARAMETER DESCRIPTION other Other hooks object to update. TYPE: HooksAware RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @abc . abstractmethod def update ( self , other : HooksAware , / ) -> HooksAware : \"\"\"Updates self hooks from other hooks object. Parameters ---------- other : HooksAware, / Other hooks object to update. Returns ------- Self The hook object to allow fluent-style. \"\"\" ...","title":"Hooks"},{"location":"api/hooks/#multibar.api.hooks","text":"Interfaces for progressbar hooks.","title":"hooks"},{"location":"api/hooks/#multibar.api.hooks.__all__","text":"","title":"__all__"},{"location":"api/hooks/#multibar.api.hooks.HooksAware","text":"Bases: abc . ABC Interface to progress hooks implementation. Source code in multibar\\api\\hooks.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 class HooksAware ( abc . ABC ): \"\"\"Interface to progress hooks implementation.\"\"\" __slots__ = () @abc . abstractmethod def __len__ ( self ) -> int : \"\"\" Returns ------- int Length of all hooks. \"\"\" ... @abc . abstractmethod def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> HooksAware : \"\"\"Adds hooks to the client. Parameters ---------- client : clients.ProgressbarClientAware, / Client to add. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def update ( self , other : HooksAware , / ) -> HooksAware : \"\"\"Updates self hooks from other hooks object. Parameters ---------- other : HooksAware, / Other hooks object to update. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def add_pre_execution ( self , callback : types . HookSignatureType , / ) -> HooksAware : \"\"\"Adds pre-execution callback. Parameters ---------- callback : HookSignatureType, / Pre-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def add_post_execution ( self , callback : types . HookSignatureType , / ) -> HooksAware : \"\"\"Adds post-execution callback. Parameters ---------- callback : HookSignatureType, / Post-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def add_on_error ( self , callback : types . HookSignatureType , / ) -> HooksAware : \"\"\"Adds on-error callback. Parameters ---------- callback : HookSignatureType, / On-error callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all post-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" ... @abc . abstractmethod def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all pre-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" ... @abc . abstractmethod def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all on-error callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" ... @property @abc . abstractmethod def pre_execution_hooks ( self ) -> collections . abc . Sequence [ types . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of pre-execution hooks. \"\"\" ... @property @abc . abstractmethod def post_execution_hooks ( self ) -> collections . abc . Sequence [ types . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of post-execution hooks. \"\"\" ... @property @abc . abstractmethod def on_error_hooks ( self ) -> collections . abc . Sequence [ types . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of on-error hooks. \"\"\" ...","title":"HooksAware"},{"location":"api/hooks/#multibar.api.hooks.HooksAware.__slots__","text":"","title":"__slots__"},{"location":"api/hooks/#multibar.api.hooks.HooksAware.__len__","text":"RETURNS DESCRIPTION int Length of all hooks. Source code in multibar\\api\\hooks.py 36 37 38 39 40 41 42 43 44 @abc . abstractmethod def __len__ ( self ) -> int : \"\"\" Returns ------- int Length of all hooks. \"\"\" ...","title":"__len__()"},{"location":"api/hooks/#multibar.api.hooks.HooksAware.add_on_error","text":"Adds on-error callback. PARAMETER DESCRIPTION callback On-error callback. TYPE: HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @abc . abstractmethod def add_on_error ( self , callback : types . HookSignatureType , / ) -> HooksAware : \"\"\"Adds on-error callback. Parameters ---------- callback : HookSignatureType, / On-error callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ...","title":"add_on_error()"},{"location":"api/hooks/#multibar.api.hooks.HooksAware.add_post_execution","text":"Adds post-execution callback. PARAMETER DESCRIPTION callback Post-execution callback. TYPE: HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @abc . abstractmethod def add_post_execution ( self , callback : types . HookSignatureType , / ) -> HooksAware : \"\"\"Adds post-execution callback. Parameters ---------- callback : HookSignatureType, / Post-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ...","title":"add_post_execution()"},{"location":"api/hooks/#multibar.api.hooks.HooksAware.add_pre_execution","text":"Adds pre-execution callback. PARAMETER DESCRIPTION callback Pre-execution callback. TYPE: HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @abc . abstractmethod def add_pre_execution ( self , callback : types . HookSignatureType , / ) -> HooksAware : \"\"\"Adds pre-execution callback. Parameters ---------- callback : HookSignatureType, / Pre-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ...","title":"add_pre_execution()"},{"location":"api/hooks/#multibar.api.hooks.HooksAware.add_to_client","text":"Adds hooks to the client. PARAMETER DESCRIPTION client Client to add. TYPE: clients . ProgressbarClientAware RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @abc . abstractmethod def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> HooksAware : \"\"\"Adds hooks to the client. Parameters ---------- client : clients.ProgressbarClientAware, / Client to add. Returns ------- Self The hook object to allow fluent-style. \"\"\" ...","title":"add_to_client()"},{"location":"api/hooks/#multibar.api.hooks.HooksAware.on_error_hooks","text":"RETURNS DESCRIPTION collections . abc . Sequence [ HookSignatureType ] Sequence of on-error hooks. Source code in multibar\\api\\hooks.py 199 200 201 202 203 204 205 206 207 208 @property @abc . abstractmethod def on_error_hooks ( self ) -> collections . abc . Sequence [ types . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of on-error hooks. \"\"\" ...","title":"on_error_hooks()"},{"location":"api/hooks/#multibar.api.hooks.HooksAware.post_execution_hooks","text":"RETURNS DESCRIPTION collections . abc . Sequence [ HookSignatureType ] Sequence of post-execution hooks. Source code in multibar\\api\\hooks.py 188 189 190 191 192 193 194 195 196 197 @property @abc . abstractmethod def post_execution_hooks ( self ) -> collections . abc . Sequence [ types . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of post-execution hooks. \"\"\" ...","title":"post_execution_hooks()"},{"location":"api/hooks/#multibar.api.hooks.HooksAware.pre_execution_hooks","text":"RETURNS DESCRIPTION collections . abc . Sequence [ HookSignatureType ] Sequence of pre-execution hooks. Source code in multibar\\api\\hooks.py 177 178 179 180 181 182 183 184 185 186 @property @abc . abstractmethod def pre_execution_hooks ( self ) -> collections . abc . Sequence [ types . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of pre-execution hooks. \"\"\" ...","title":"pre_execution_hooks()"},{"location":"api/hooks/#multibar.api.hooks.HooksAware.trigger_on_error","text":"Triggers all on-error callbacks. PARAMETER DESCRIPTION *args Arguments to trigger. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to trigger. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\api\\hooks.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 @abc . abstractmethod def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all on-error callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" ...","title":"trigger_on_error()"},{"location":"api/hooks/#multibar.api.hooks.HooksAware.trigger_post_execution","text":"Triggers all post-execution callbacks. PARAMETER DESCRIPTION *args Arguments to trigger. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to trigger. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\api\\hooks.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @abc . abstractmethod def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all post-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" ...","title":"trigger_post_execution()"},{"location":"api/hooks/#multibar.api.hooks.HooksAware.trigger_pre_execution","text":"Triggers all pre-execution callbacks. PARAMETER DESCRIPTION *args Arguments to trigger. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to trigger. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\api\\hooks.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 @abc . abstractmethod def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all pre-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" ...","title":"trigger_pre_execution()"},{"location":"api/hooks/#multibar.api.hooks.HooksAware.update","text":"Updates self hooks from other hooks object. PARAMETER DESCRIPTION other Other hooks object to update. TYPE: HooksAware RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @abc . abstractmethod def update ( self , other : HooksAware , / ) -> HooksAware : \"\"\"Updates self hooks from other hooks object. Parameters ---------- other : HooksAware, / Other hooks object to update. Returns ------- Self The hook object to allow fluent-style. \"\"\" ...","title":"update()"},{"location":"api/math_operations/","text":"multibar.api.calculation_service \u00a4 Interfaces for math operations. __all__ = ( 'AbstractCalculationService' ) module-attribute \u00a4 AbstractCalculationService \u00a4 Bases: abc . ABC An abstraction that represents a service for mathematical operations on the progress bar. Source code in multibar\\api\\calculation_service.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 class AbstractCalculationService ( abc . ABC ): \"\"\"An abstraction that represents a service for mathematical operations on the progress bar.\"\"\" __slots__ = ( \"_start_value\" , \"_end_value\" , \"_length\" ) def __init__ ( self , start_value : typing . Union [ int , float ], end_value : typing . Union [ int , float ], length : int , ) -> None : \"\"\" Parameters ---------- start_value : typing.Union[int, float] Start value (current progress) for progressbar math operations. end_value : typing.Union[int, float] End value (needed progress) for progressbar math operations. length : int Length of progressbar for progressbar math operations. \"\"\" self . _start_value = start_value self . _end_value = end_value self . _length = length @abc . abstractmethod def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar filled sector indexes. \"\"\" ... @abc . abstractmethod def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar unfilled sector indexes. \"\"\" ... @property @abc . abstractmethod def progress_percents ( self ) -> float : \"\"\"Returns current progress percentage. Returns ------- float Float progress percentage. \"\"\" ... @staticmethod @abc . abstractmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : \"\"\"Alternative staticmethod to get progress percentage. Parameters ----------- start : typing.Union[int, float] Start value (current progress) for progressbar math operations. end : typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" ... @property def start_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] Start value (current progress) for progressbar math operations. \"\"\" return self . _start_value @property def end_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" return self . _end_value @property def length_value ( self ) -> int : \"\"\" Returns ------- int Length of progressbar for progressbar math operations. \"\"\" return self . _length __slots__ = ( '_start_value' , '_end_value' , '_length' ) class-attribute \u00a4 __init__ ( start_value , end_value , length ) \u00a4 PARAMETER DESCRIPTION start_value Start value (current progress) for progressbar math operations. TYPE: typing . Union [ int , float ] end_value End value (needed progress) for progressbar math operations. TYPE: typing . Union [ int , float ] length Length of progressbar for progressbar math operations. TYPE: int Source code in multibar\\api\\calculation_service.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , start_value : typing . Union [ int , float ], end_value : typing . Union [ int , float ], length : int , ) -> None : \"\"\" Parameters ---------- start_value : typing.Union[int, float] Start value (current progress) for progressbar math operations. end_value : typing.Union[int, float] End value (needed progress) for progressbar math operations. length : int Length of progressbar for progressbar math operations. \"\"\" self . _start_value = start_value self . _end_value = end_value self . _length = length calculate_filled_indexes () abstractmethod \u00a4 Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. RETURNS DESCRIPTION collections . abc . Iterator [ int ] Iterator over progressbar filled sector indexes. Source code in multibar\\api\\calculation_service.py 52 53 54 55 56 57 58 59 60 61 62 63 @abc . abstractmethod def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar filled sector indexes. \"\"\" ... calculate_unfilled_indexes () abstractmethod \u00a4 Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. RETURNS DESCRIPTION collections . abc . Iterator [ int ] Iterator over progressbar unfilled sector indexes. Source code in multibar\\api\\calculation_service.py 65 66 67 68 69 70 71 72 73 74 75 76 @abc . abstractmethod def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar unfilled sector indexes. \"\"\" ... end_value () property \u00a4 RETURNS DESCRIPTION typing . Union [ int , float ] End value (needed progress) for progressbar math operations. Source code in multibar\\api\\calculation_service.py 114 115 116 117 118 119 120 121 122 @property def end_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" return self . _end_value get_progress_percentage ( start , end ) staticmethod abstractmethod \u00a4 Alternative staticmethod to get progress percentage. PARAMETER DESCRIPTION start Start value (current progress) for progressbar math operations. TYPE: typing . Union [ int , float ] end End value (needed progress) for progressbar math operations. TYPE: typing . Union [ int , float ] Source code in multibar\\api\\calculation_service.py 90 91 92 93 94 95 96 97 98 99 100 101 102 @staticmethod @abc . abstractmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : \"\"\"Alternative staticmethod to get progress percentage. Parameters ----------- start : typing.Union[int, float] Start value (current progress) for progressbar math operations. end : typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" ... length_value () property \u00a4 RETURNS DESCRIPTION int Length of progressbar for progressbar math operations. Source code in multibar\\api\\calculation_service.py 124 125 126 127 128 129 130 131 132 @property def length_value ( self ) -> int : \"\"\" Returns ------- int Length of progressbar for progressbar math operations. \"\"\" return self . _length progress_percents () abstractmethod property \u00a4 Returns current progress percentage. RETURNS DESCRIPTION float Float progress percentage. Source code in multibar\\api\\calculation_service.py 78 79 80 81 82 83 84 85 86 87 88 @property @abc . abstractmethod def progress_percents ( self ) -> float : \"\"\"Returns current progress percentage. Returns ------- float Float progress percentage. \"\"\" ... start_value () property \u00a4 RETURNS DESCRIPTION typing . Union [ int , float ] Start value (current progress) for progressbar math operations. Source code in multibar\\api\\calculation_service.py 104 105 106 107 108 109 110 111 112 @property def start_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] Start value (current progress) for progressbar math operations. \"\"\" return self . _start_value","title":"Math operations"},{"location":"api/math_operations/#multibar.api.calculation_service","text":"Interfaces for math operations.","title":"calculation_service"},{"location":"api/math_operations/#multibar.api.calculation_service.__all__","text":"","title":"__all__"},{"location":"api/math_operations/#multibar.api.calculation_service.AbstractCalculationService","text":"Bases: abc . ABC An abstraction that represents a service for mathematical operations on the progress bar. Source code in multibar\\api\\calculation_service.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 class AbstractCalculationService ( abc . ABC ): \"\"\"An abstraction that represents a service for mathematical operations on the progress bar.\"\"\" __slots__ = ( \"_start_value\" , \"_end_value\" , \"_length\" ) def __init__ ( self , start_value : typing . Union [ int , float ], end_value : typing . Union [ int , float ], length : int , ) -> None : \"\"\" Parameters ---------- start_value : typing.Union[int, float] Start value (current progress) for progressbar math operations. end_value : typing.Union[int, float] End value (needed progress) for progressbar math operations. length : int Length of progressbar for progressbar math operations. \"\"\" self . _start_value = start_value self . _end_value = end_value self . _length = length @abc . abstractmethod def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar filled sector indexes. \"\"\" ... @abc . abstractmethod def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar unfilled sector indexes. \"\"\" ... @property @abc . abstractmethod def progress_percents ( self ) -> float : \"\"\"Returns current progress percentage. Returns ------- float Float progress percentage. \"\"\" ... @staticmethod @abc . abstractmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : \"\"\"Alternative staticmethod to get progress percentage. Parameters ----------- start : typing.Union[int, float] Start value (current progress) for progressbar math operations. end : typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" ... @property def start_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] Start value (current progress) for progressbar math operations. \"\"\" return self . _start_value @property def end_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" return self . _end_value @property def length_value ( self ) -> int : \"\"\" Returns ------- int Length of progressbar for progressbar math operations. \"\"\" return self . _length","title":"AbstractCalculationService"},{"location":"api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.__slots__","text":"","title":"__slots__"},{"location":"api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.__init__","text":"PARAMETER DESCRIPTION start_value Start value (current progress) for progressbar math operations. TYPE: typing . Union [ int , float ] end_value End value (needed progress) for progressbar math operations. TYPE: typing . Union [ int , float ] length Length of progressbar for progressbar math operations. TYPE: int Source code in multibar\\api\\calculation_service.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , start_value : typing . Union [ int , float ], end_value : typing . Union [ int , float ], length : int , ) -> None : \"\"\" Parameters ---------- start_value : typing.Union[int, float] Start value (current progress) for progressbar math operations. end_value : typing.Union[int, float] End value (needed progress) for progressbar math operations. length : int Length of progressbar for progressbar math operations. \"\"\" self . _start_value = start_value self . _end_value = end_value self . _length = length","title":"__init__()"},{"location":"api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.calculate_filled_indexes","text":"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. RETURNS DESCRIPTION collections . abc . Iterator [ int ] Iterator over progressbar filled sector indexes. Source code in multibar\\api\\calculation_service.py 52 53 54 55 56 57 58 59 60 61 62 63 @abc . abstractmethod def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar filled sector indexes. \"\"\" ...","title":"calculate_filled_indexes()"},{"location":"api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.calculate_unfilled_indexes","text":"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. RETURNS DESCRIPTION collections . abc . Iterator [ int ] Iterator over progressbar unfilled sector indexes. Source code in multibar\\api\\calculation_service.py 65 66 67 68 69 70 71 72 73 74 75 76 @abc . abstractmethod def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar unfilled sector indexes. \"\"\" ...","title":"calculate_unfilled_indexes()"},{"location":"api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.end_value","text":"RETURNS DESCRIPTION typing . Union [ int , float ] End value (needed progress) for progressbar math operations. Source code in multibar\\api\\calculation_service.py 114 115 116 117 118 119 120 121 122 @property def end_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" return self . _end_value","title":"end_value()"},{"location":"api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.get_progress_percentage","text":"Alternative staticmethod to get progress percentage. PARAMETER DESCRIPTION start Start value (current progress) for progressbar math operations. TYPE: typing . Union [ int , float ] end End value (needed progress) for progressbar math operations. TYPE: typing . Union [ int , float ] Source code in multibar\\api\\calculation_service.py 90 91 92 93 94 95 96 97 98 99 100 101 102 @staticmethod @abc . abstractmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : \"\"\"Alternative staticmethod to get progress percentage. Parameters ----------- start : typing.Union[int, float] Start value (current progress) for progressbar math operations. end : typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" ...","title":"get_progress_percentage()"},{"location":"api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.length_value","text":"RETURNS DESCRIPTION int Length of progressbar for progressbar math operations. Source code in multibar\\api\\calculation_service.py 124 125 126 127 128 129 130 131 132 @property def length_value ( self ) -> int : \"\"\" Returns ------- int Length of progressbar for progressbar math operations. \"\"\" return self . _length","title":"length_value()"},{"location":"api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.progress_percents","text":"Returns current progress percentage. RETURNS DESCRIPTION float Float progress percentage. Source code in multibar\\api\\calculation_service.py 78 79 80 81 82 83 84 85 86 87 88 @property @abc . abstractmethod def progress_percents ( self ) -> float : \"\"\"Returns current progress percentage. Returns ------- float Float progress percentage. \"\"\" ...","title":"progress_percents()"},{"location":"api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.start_value","text":"RETURNS DESCRIPTION typing . Union [ int , float ] Start value (current progress) for progressbar math operations. Source code in multibar\\api\\calculation_service.py 104 105 106 107 108 109 110 111 112 @property def start_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] Start value (current progress) for progressbar math operations. \"\"\" return self . _start_value","title":"start_value()"},{"location":"api/progressbars/","text":"multibar.api.progressbars \u00a4 Interfaces for progressbar collections. SectorT = typing . TypeVar ( 'SectorT' , bound = sectors . AbstractSector ) module-attribute \u00a4 __all__ = ( 'ProgressbarAware' ) module-attribute \u00a4 ProgressbarAware \u00a4 Bases: abc . ABC , typing . Generic [ SectorT ] Interface for progressbar implementations. Source code in multibar\\api\\progressbars.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 class ProgressbarAware ( abc . ABC , typing . Generic [ SectorT ]): \"\"\"Interface for progressbar implementations.\"\"\" __slots__ = () @typing . overload @abc . abstractmethod def __getitem__ ( self , item : slice ) -> collections . abc . Sequence [ SectorT ]: ... @typing . overload @abc . abstractmethod def __getitem__ ( self , item : int ) -> SectorT : ... @abc . abstractmethod def __getitem__ ( self , item : typing . Any ) -> typing . Any : \"\"\"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice. Returns ------- typing.Any Any value depending on context and implementation. \"\"\" ... @abc . abstractmethod def __len__ ( self ) -> int : \"\"\" Returns ------- int Sectors count. \"\"\" ... @classmethod @abc . abstractmethod def set_new_sectors ( cls : typing . Type [ _InstanceKind ], new_value : collections . abc . Iterable [ _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Sets new sectors in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progresswriter.write(value, value) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors(...) # Extended sectors with .extend_method() >>> new_progressbar = progressbar.set_new_sectors(sectors) # Sectors have .extend_method() >>> new_progressbar.sectors[0].extend_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Parameters ---------- new_value : collections.abc.Iterable[_NewValueType], / Iterable over new sector objects. For example of behavior see `info` block. Returns ------- Kind1[_InstanceKind, _NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" ... @abc . abstractmethod def map ( self : _InstanceKind , callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Applies callback for every sector in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progressbarwriter.write(value, value) ... >>> class ExtendedImpl(AbstractSector): # Your extended implementation >>> def __init__(self, sector_obj: AbstractSector) -> None: ... super().__init__(sector_obj.name, sector_obj.is_filled, sector_obj.position) ... self._origin = sector_obj ... >>> def extended_method(self) -> None: ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar.map(lambda s: ExtendedImpl(s)) >>> new_progressbar.sectors[0].extended_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Returns ------- Kind1[_InstanceKind, _NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" ... @abc . abstractmethod def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : \"\"\"Pass each sector to a given consumer. Parameters ---------- consumer : typing.Callable[[SectorT], typing.Any], / Function to apply for progressbar sectors. Returns ------- None \"\"\" ... @abc . abstractmethod def add_sector ( self : _InstanceKind , sector : sectors . AbstractSector , / ) -> _InstanceKind : \"\"\"Adds sector to progressbar. Parameters ---------- sector : SectorT, / Sector to add. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ... @abc . abstractmethod def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> ProgressbarAware [ SectorT ]: \"\"\"Replaces sector display name. Parameters ---------- sector_pos : int, / To find sector by index to change. new_display_name : str, / New display name value. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ... @property @abc . abstractmethod def length ( self ) -> int : \"\"\" Returns ------- int Length of the progressbar. \"\"\" ... @property @abc . abstractmethod def sectors ( self ) -> collections . abc . MutableSequence [ SectorT ]: \"\"\" Returns ------- collections.abc.Sequence[SectorT] Sequence of sectors. \"\"\" ... __slots__ = () class-attribute \u00a4 __getitem__ ( item ) abstractmethod \u00a4 Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice. RETURNS DESCRIPTION typing . Any Any value depending on context and implementation. Source code in multibar\\api\\progressbars.py 50 51 52 53 54 55 56 57 58 59 60 @abc . abstractmethod def __getitem__ ( self , item : typing . Any ) -> typing . Any : \"\"\"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice. Returns ------- typing.Any Any value depending on context and implementation. \"\"\" ... __len__ () abstractmethod \u00a4 RETURNS DESCRIPTION int Sectors count. Source code in multibar\\api\\progressbars.py 62 63 64 65 66 67 68 69 70 @abc . abstractmethod def __len__ ( self ) -> int : \"\"\" Returns ------- int Sectors count. \"\"\" ... add_sector ( sector ) abstractmethod \u00a4 Adds sector to progressbar. PARAMETER DESCRIPTION sector Sector to add. TYPE: SectorT RETURNS DESCRIPTION Self The progressbar object to allow fluent-style. Source code in multibar\\api\\progressbars.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 @abc . abstractmethod def add_sector ( self : _InstanceKind , sector : sectors . AbstractSector , / ) -> _InstanceKind : \"\"\"Adds sector to progressbar. Parameters ---------- sector : SectorT, / Sector to add. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ... for_each ( consumer ) abstractmethod \u00a4 Pass each sector to a given consumer. PARAMETER DESCRIPTION consumer Function to apply for progressbar sectors. TYPE: typing . Callable [[ SectorT ], typing . Any ] RETURNS DESCRIPTION None Source code in multibar\\api\\progressbars.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 @abc . abstractmethod def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : \"\"\"Pass each sector to a given consumer. Parameters ---------- consumer : typing.Callable[[SectorT], typing.Any], / Function to apply for progressbar sectors. Returns ------- None \"\"\" ... length () abstractmethod property \u00a4 RETURNS DESCRIPTION int Length of the progressbar. Source code in multibar\\api\\progressbars.py 223 224 225 226 227 228 229 230 231 232 @property @abc . abstractmethod def length ( self ) -> int : \"\"\" Returns ------- int Length of the progressbar. \"\"\" ... map ( callback ) abstractmethod \u00a4 Applies callback for every sector in progressbar. Info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. Abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: Expand pseudocode example >>> progressbar = progressbarwriter . write ( value , value ) ... >>> class ExtendedImpl ( AbstractSector ): # Your extended implementation >>> def __init__ ( self , sector_obj : AbstractSector ) -> None : ... super () . __init__ ( sector_obj . name , sector_obj . is_filled , sector_obj . position ) ... self . _origin = sector_obj ... >>> def extended_method ( self ) -> None : ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar . map ( lambda s : ExtendedImpl ( s )) >>> new_progressbar . sectors [ 0 ] . extended_method () # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. RETURNS DESCRIPTION Kind1 [ _InstanceKind , _NewValueType ] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. Source code in multibar\\api\\progressbars.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 @abc . abstractmethod def map ( self : _InstanceKind , callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Applies callback for every sector in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progressbarwriter.write(value, value) ... >>> class ExtendedImpl(AbstractSector): # Your extended implementation >>> def __init__(self, sector_obj: AbstractSector) -> None: ... super().__init__(sector_obj.name, sector_obj.is_filled, sector_obj.position) ... self._origin = sector_obj ... >>> def extended_method(self) -> None: ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar.map(lambda s: ExtendedImpl(s)) >>> new_progressbar.sectors[0].extended_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Returns ------- Kind1[_InstanceKind, _NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" ... replace_display_name_for ( sector_pos , new_display_name ) abstractmethod \u00a4 Replaces sector display name. PARAMETER DESCRIPTION sector_pos To find sector by index to change. TYPE: int new_display_name New display name value. TYPE: str RETURNS DESCRIPTION Self The progressbar object to allow fluent-style. Source code in multibar\\api\\progressbars.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 @abc . abstractmethod def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> ProgressbarAware [ SectorT ]: \"\"\"Replaces sector display name. Parameters ---------- sector_pos : int, / To find sector by index to change. new_display_name : str, / New display name value. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ... sectors () abstractmethod property \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ SectorT ] Sequence of sectors. Source code in multibar\\api\\progressbars.py 234 235 236 237 238 239 240 241 242 243 @property @abc . abstractmethod def sectors ( self ) -> collections . abc . MutableSequence [ SectorT ]: \"\"\" Returns ------- collections.abc.Sequence[SectorT] Sequence of sectors. \"\"\" ... set_new_sectors ( new_value ) abstractmethod classmethod \u00a4 Sets new sectors in progressbar. Info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. Abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: Expand pseudocode example >>> progressbar = progresswriter . write ( value , value ) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors ( ... ) # Extended sectors with .extend_method() >>> new_progressbar = progressbar . set_new_sectors ( sectors ) # Sectors have .extend_method() >>> new_progressbar . sectors [ 0 ] . extend_method () # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. PARAMETER DESCRIPTION new_value Iterable over new sector objects. For example of behavior see info block. TYPE: collections . abc . Iterable [ _NewValueType ] RETURNS DESCRIPTION Kind1 [ _InstanceKind , _NewValueType ] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. Source code in multibar\\api\\progressbars.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 @classmethod @abc . abstractmethod def set_new_sectors ( cls : typing . Type [ _InstanceKind ], new_value : collections . abc . Iterable [ _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Sets new sectors in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progresswriter.write(value, value) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors(...) # Extended sectors with .extend_method() >>> new_progressbar = progressbar.set_new_sectors(sectors) # Sectors have .extend_method() >>> new_progressbar.sectors[0].extend_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Parameters ---------- new_value : collections.abc.Iterable[_NewValueType], / Iterable over new sector objects. For example of behavior see `info` block. Returns ------- Kind1[_InstanceKind, _NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" ...","title":"Progressbars"},{"location":"api/progressbars/#multibar.api.progressbars","text":"Interfaces for progressbar collections.","title":"progressbars"},{"location":"api/progressbars/#multibar.api.progressbars.SectorT","text":"","title":"SectorT"},{"location":"api/progressbars/#multibar.api.progressbars.__all__","text":"","title":"__all__"},{"location":"api/progressbars/#multibar.api.progressbars.ProgressbarAware","text":"Bases: abc . ABC , typing . Generic [ SectorT ] Interface for progressbar implementations. Source code in multibar\\api\\progressbars.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 class ProgressbarAware ( abc . ABC , typing . Generic [ SectorT ]): \"\"\"Interface for progressbar implementations.\"\"\" __slots__ = () @typing . overload @abc . abstractmethod def __getitem__ ( self , item : slice ) -> collections . abc . Sequence [ SectorT ]: ... @typing . overload @abc . abstractmethod def __getitem__ ( self , item : int ) -> SectorT : ... @abc . abstractmethod def __getitem__ ( self , item : typing . Any ) -> typing . Any : \"\"\"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice. Returns ------- typing.Any Any value depending on context and implementation. \"\"\" ... @abc . abstractmethod def __len__ ( self ) -> int : \"\"\" Returns ------- int Sectors count. \"\"\" ... @classmethod @abc . abstractmethod def set_new_sectors ( cls : typing . Type [ _InstanceKind ], new_value : collections . abc . Iterable [ _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Sets new sectors in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progresswriter.write(value, value) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors(...) # Extended sectors with .extend_method() >>> new_progressbar = progressbar.set_new_sectors(sectors) # Sectors have .extend_method() >>> new_progressbar.sectors[0].extend_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Parameters ---------- new_value : collections.abc.Iterable[_NewValueType], / Iterable over new sector objects. For example of behavior see `info` block. Returns ------- Kind1[_InstanceKind, _NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" ... @abc . abstractmethod def map ( self : _InstanceKind , callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Applies callback for every sector in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progressbarwriter.write(value, value) ... >>> class ExtendedImpl(AbstractSector): # Your extended implementation >>> def __init__(self, sector_obj: AbstractSector) -> None: ... super().__init__(sector_obj.name, sector_obj.is_filled, sector_obj.position) ... self._origin = sector_obj ... >>> def extended_method(self) -> None: ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar.map(lambda s: ExtendedImpl(s)) >>> new_progressbar.sectors[0].extended_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Returns ------- Kind1[_InstanceKind, _NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" ... @abc . abstractmethod def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : \"\"\"Pass each sector to a given consumer. Parameters ---------- consumer : typing.Callable[[SectorT], typing.Any], / Function to apply for progressbar sectors. Returns ------- None \"\"\" ... @abc . abstractmethod def add_sector ( self : _InstanceKind , sector : sectors . AbstractSector , / ) -> _InstanceKind : \"\"\"Adds sector to progressbar. Parameters ---------- sector : SectorT, / Sector to add. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ... @abc . abstractmethod def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> ProgressbarAware [ SectorT ]: \"\"\"Replaces sector display name. Parameters ---------- sector_pos : int, / To find sector by index to change. new_display_name : str, / New display name value. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ... @property @abc . abstractmethod def length ( self ) -> int : \"\"\" Returns ------- int Length of the progressbar. \"\"\" ... @property @abc . abstractmethod def sectors ( self ) -> collections . abc . MutableSequence [ SectorT ]: \"\"\" Returns ------- collections.abc.Sequence[SectorT] Sequence of sectors. \"\"\" ...","title":"ProgressbarAware"},{"location":"api/progressbars/#multibar.api.progressbars.ProgressbarAware.__slots__","text":"","title":"__slots__"},{"location":"api/progressbars/#multibar.api.progressbars.ProgressbarAware.__getitem__","text":"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice. RETURNS DESCRIPTION typing . Any Any value depending on context and implementation. Source code in multibar\\api\\progressbars.py 50 51 52 53 54 55 56 57 58 59 60 @abc . abstractmethod def __getitem__ ( self , item : typing . Any ) -> typing . Any : \"\"\"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice. Returns ------- typing.Any Any value depending on context and implementation. \"\"\" ...","title":"__getitem__()"},{"location":"api/progressbars/#multibar.api.progressbars.ProgressbarAware.__len__","text":"RETURNS DESCRIPTION int Sectors count. Source code in multibar\\api\\progressbars.py 62 63 64 65 66 67 68 69 70 @abc . abstractmethod def __len__ ( self ) -> int : \"\"\" Returns ------- int Sectors count. \"\"\" ...","title":"__len__()"},{"location":"api/progressbars/#multibar.api.progressbars.ProgressbarAware.add_sector","text":"Adds sector to progressbar. PARAMETER DESCRIPTION sector Sector to add. TYPE: SectorT RETURNS DESCRIPTION Self The progressbar object to allow fluent-style. Source code in multibar\\api\\progressbars.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 @abc . abstractmethod def add_sector ( self : _InstanceKind , sector : sectors . AbstractSector , / ) -> _InstanceKind : \"\"\"Adds sector to progressbar. Parameters ---------- sector : SectorT, / Sector to add. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ...","title":"add_sector()"},{"location":"api/progressbars/#multibar.api.progressbars.ProgressbarAware.for_each","text":"Pass each sector to a given consumer. PARAMETER DESCRIPTION consumer Function to apply for progressbar sectors. TYPE: typing . Callable [[ SectorT ], typing . Any ] RETURNS DESCRIPTION None Source code in multibar\\api\\progressbars.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 @abc . abstractmethod def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : \"\"\"Pass each sector to a given consumer. Parameters ---------- consumer : typing.Callable[[SectorT], typing.Any], / Function to apply for progressbar sectors. Returns ------- None \"\"\" ...","title":"for_each()"},{"location":"api/progressbars/#multibar.api.progressbars.ProgressbarAware.length","text":"RETURNS DESCRIPTION int Length of the progressbar. Source code in multibar\\api\\progressbars.py 223 224 225 226 227 228 229 230 231 232 @property @abc . abstractmethod def length ( self ) -> int : \"\"\" Returns ------- int Length of the progressbar. \"\"\" ...","title":"length()"},{"location":"api/progressbars/#multibar.api.progressbars.ProgressbarAware.map","text":"Applies callback for every sector in progressbar. Info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. Abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: Expand pseudocode example >>> progressbar = progressbarwriter . write ( value , value ) ... >>> class ExtendedImpl ( AbstractSector ): # Your extended implementation >>> def __init__ ( self , sector_obj : AbstractSector ) -> None : ... super () . __init__ ( sector_obj . name , sector_obj . is_filled , sector_obj . position ) ... self . _origin = sector_obj ... >>> def extended_method ( self ) -> None : ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar . map ( lambda s : ExtendedImpl ( s )) >>> new_progressbar . sectors [ 0 ] . extended_method () # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. RETURNS DESCRIPTION Kind1 [ _InstanceKind , _NewValueType ] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. Source code in multibar\\api\\progressbars.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 @abc . abstractmethod def map ( self : _InstanceKind , callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Applies callback for every sector in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progressbarwriter.write(value, value) ... >>> class ExtendedImpl(AbstractSector): # Your extended implementation >>> def __init__(self, sector_obj: AbstractSector) -> None: ... super().__init__(sector_obj.name, sector_obj.is_filled, sector_obj.position) ... self._origin = sector_obj ... >>> def extended_method(self) -> None: ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar.map(lambda s: ExtendedImpl(s)) >>> new_progressbar.sectors[0].extended_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Returns ------- Kind1[_InstanceKind, _NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" ...","title":"map()"},{"location":"api/progressbars/#multibar.api.progressbars.ProgressbarAware.replace_display_name_for","text":"Replaces sector display name. PARAMETER DESCRIPTION sector_pos To find sector by index to change. TYPE: int new_display_name New display name value. TYPE: str RETURNS DESCRIPTION Self The progressbar object to allow fluent-style. Source code in multibar\\api\\progressbars.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 @abc . abstractmethod def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> ProgressbarAware [ SectorT ]: \"\"\"Replaces sector display name. Parameters ---------- sector_pos : int, / To find sector by index to change. new_display_name : str, / New display name value. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ...","title":"replace_display_name_for()"},{"location":"api/progressbars/#multibar.api.progressbars.ProgressbarAware.sectors","text":"RETURNS DESCRIPTION collections . abc . Sequence [ SectorT ] Sequence of sectors. Source code in multibar\\api\\progressbars.py 234 235 236 237 238 239 240 241 242 243 @property @abc . abstractmethod def sectors ( self ) -> collections . abc . MutableSequence [ SectorT ]: \"\"\" Returns ------- collections.abc.Sequence[SectorT] Sequence of sectors. \"\"\" ...","title":"sectors()"},{"location":"api/progressbars/#multibar.api.progressbars.ProgressbarAware.set_new_sectors","text":"Sets new sectors in progressbar. Info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. Abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: Expand pseudocode example >>> progressbar = progresswriter . write ( value , value ) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors ( ... ) # Extended sectors with .extend_method() >>> new_progressbar = progressbar . set_new_sectors ( sectors ) # Sectors have .extend_method() >>> new_progressbar . sectors [ 0 ] . extend_method () # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. PARAMETER DESCRIPTION new_value Iterable over new sector objects. For example of behavior see info block. TYPE: collections . abc . Iterable [ _NewValueType ] RETURNS DESCRIPTION Kind1 [ _InstanceKind , _NewValueType ] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. Source code in multibar\\api\\progressbars.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 @classmethod @abc . abstractmethod def set_new_sectors ( cls : typing . Type [ _InstanceKind ], new_value : collections . abc . Iterable [ _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Sets new sectors in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progresswriter.write(value, value) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors(...) # Extended sectors with .extend_method() >>> new_progressbar = progressbar.set_new_sectors(sectors) # Sectors have .extend_method() >>> new_progressbar.sectors[0].extend_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Parameters ---------- new_value : collections.abc.Iterable[_NewValueType], / Iterable over new sector objects. For example of behavior see `info` block. Returns ------- Kind1[_InstanceKind, _NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" ...","title":"set_new_sectors()"},{"location":"api/sectors/","text":"multibar.api.sectors \u00a4 Interfaces for progressbar sectors. SelfT = typing . TypeVar ( 'SelfT' , bound = 'AbstractSector' ) module-attribute \u00a4 __all__ = ( 'AbstractSector' ) module-attribute \u00a4 AbstractSector \u00a4 Bases: abc . ABC Abstraction for sector implementations. Source code in multibar\\api\\sectors.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class AbstractSector ( abc . ABC ): \"\"\"Abstraction for sector implementations.\"\"\" __slots__ = ( \"_name\" , \"_is_filled\" , \"_position\" ) def __init__ ( self , name : str , is_filled : bool , position : int ) -> None : \"\"\" Parameters ---------- name : str Sector display name. is_filled : bool Sector filled value. position : int Sector position in the progressbar. \"\"\" self . _name = name self . _is_filled = is_filled self . _position = position @abc . abstractmethod def add_to_progressbar ( self : SelfT , progressbar : progressbars . ProgressbarAware [ SelfT ], / ) -> SelfT : \"\"\"Adds sector self to progressbar. Parameters ---------- progressbar : progressbars.ProgressbarAware[SelfT], / Progressbar to add self for. Returns ------- Self The sector object to allow fluent-style. \"\"\" ... @abc . abstractmethod def change_name ( self , new_display_name : str , / ) -> AbstractSector : \"\"\"Changes sector display name. Parameters ---------- new_display_name : str, / New display name to set. Returns ------- Self The sector object to allow fluent-style. \"\"\" ... @property @abc . abstractmethod def name ( self ) -> str : \"\"\" Returns ------- str Sector display name. \"\"\" ... @property @abc . abstractmethod def is_filled ( self ) -> bool : \"\"\" Returns ------- str Sector filled value. \"\"\" ... @property @abc . abstractmethod def position ( self ) -> int : \"\"\" Returns ------- str Sector position in the progressbar. \"\"\" ... __slots__ = ( '_name' , '_is_filled' , '_position' ) class-attribute \u00a4 __init__ ( name , is_filled , position ) \u00a4 PARAMETER DESCRIPTION name Sector display name. TYPE: str is_filled Sector filled value. TYPE: bool position Sector position in the progressbar. TYPE: int Source code in multibar\\api\\sectors.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , name : str , is_filled : bool , position : int ) -> None : \"\"\" Parameters ---------- name : str Sector display name. is_filled : bool Sector filled value. position : int Sector position in the progressbar. \"\"\" self . _name = name self . _is_filled = is_filled self . _position = position add_to_progressbar ( progressbar ) abstractmethod \u00a4 Adds sector self to progressbar. PARAMETER DESCRIPTION progressbar Progressbar to add self for. TYPE: progressbars . ProgressbarAware [ SelfT ] RETURNS DESCRIPTION Self The sector object to allow fluent-style. Source code in multibar\\api\\sectors.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @abc . abstractmethod def add_to_progressbar ( self : SelfT , progressbar : progressbars . ProgressbarAware [ SelfT ], / ) -> SelfT : \"\"\"Adds sector self to progressbar. Parameters ---------- progressbar : progressbars.ProgressbarAware[SelfT], / Progressbar to add self for. Returns ------- Self The sector object to allow fluent-style. \"\"\" ... change_name ( new_display_name ) abstractmethod \u00a4 Changes sector display name. PARAMETER DESCRIPTION new_display_name New display name to set. TYPE: str RETURNS DESCRIPTION Self The sector object to allow fluent-style. Source code in multibar\\api\\sectors.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @abc . abstractmethod def change_name ( self , new_display_name : str , / ) -> AbstractSector : \"\"\"Changes sector display name. Parameters ---------- new_display_name : str, / New display name to set. Returns ------- Self The sector object to allow fluent-style. \"\"\" ... is_filled () abstractmethod property \u00a4 RETURNS DESCRIPTION str Sector filled value. Source code in multibar\\api\\sectors.py 93 94 95 96 97 98 99 100 101 102 @property @abc . abstractmethod def is_filled ( self ) -> bool : \"\"\" Returns ------- str Sector filled value. \"\"\" ... name () abstractmethod property \u00a4 RETURNS DESCRIPTION str Sector display name. Source code in multibar\\api\\sectors.py 82 83 84 85 86 87 88 89 90 91 @property @abc . abstractmethod def name ( self ) -> str : \"\"\" Returns ------- str Sector display name. \"\"\" ... position () abstractmethod property \u00a4 RETURNS DESCRIPTION str Sector position in the progressbar. Source code in multibar\\api\\sectors.py 104 105 106 107 108 109 110 111 112 113 @property @abc . abstractmethod def position ( self ) -> int : \"\"\" Returns ------- str Sector position in the progressbar. \"\"\" ...","title":"Sectors"},{"location":"api/sectors/#multibar.api.sectors","text":"Interfaces for progressbar sectors.","title":"sectors"},{"location":"api/sectors/#multibar.api.sectors.SelfT","text":"","title":"SelfT"},{"location":"api/sectors/#multibar.api.sectors.__all__","text":"","title":"__all__"},{"location":"api/sectors/#multibar.api.sectors.AbstractSector","text":"Bases: abc . ABC Abstraction for sector implementations. Source code in multibar\\api\\sectors.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class AbstractSector ( abc . ABC ): \"\"\"Abstraction for sector implementations.\"\"\" __slots__ = ( \"_name\" , \"_is_filled\" , \"_position\" ) def __init__ ( self , name : str , is_filled : bool , position : int ) -> None : \"\"\" Parameters ---------- name : str Sector display name. is_filled : bool Sector filled value. position : int Sector position in the progressbar. \"\"\" self . _name = name self . _is_filled = is_filled self . _position = position @abc . abstractmethod def add_to_progressbar ( self : SelfT , progressbar : progressbars . ProgressbarAware [ SelfT ], / ) -> SelfT : \"\"\"Adds sector self to progressbar. Parameters ---------- progressbar : progressbars.ProgressbarAware[SelfT], / Progressbar to add self for. Returns ------- Self The sector object to allow fluent-style. \"\"\" ... @abc . abstractmethod def change_name ( self , new_display_name : str , / ) -> AbstractSector : \"\"\"Changes sector display name. Parameters ---------- new_display_name : str, / New display name to set. Returns ------- Self The sector object to allow fluent-style. \"\"\" ... @property @abc . abstractmethod def name ( self ) -> str : \"\"\" Returns ------- str Sector display name. \"\"\" ... @property @abc . abstractmethod def is_filled ( self ) -> bool : \"\"\" Returns ------- str Sector filled value. \"\"\" ... @property @abc . abstractmethod def position ( self ) -> int : \"\"\" Returns ------- str Sector position in the progressbar. \"\"\" ...","title":"AbstractSector"},{"location":"api/sectors/#multibar.api.sectors.AbstractSector.__slots__","text":"","title":"__slots__"},{"location":"api/sectors/#multibar.api.sectors.AbstractSector.__init__","text":"PARAMETER DESCRIPTION name Sector display name. TYPE: str is_filled Sector filled value. TYPE: bool position Sector position in the progressbar. TYPE: int Source code in multibar\\api\\sectors.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , name : str , is_filled : bool , position : int ) -> None : \"\"\" Parameters ---------- name : str Sector display name. is_filled : bool Sector filled value. position : int Sector position in the progressbar. \"\"\" self . _name = name self . _is_filled = is_filled self . _position = position","title":"__init__()"},{"location":"api/sectors/#multibar.api.sectors.AbstractSector.add_to_progressbar","text":"Adds sector self to progressbar. PARAMETER DESCRIPTION progressbar Progressbar to add self for. TYPE: progressbars . ProgressbarAware [ SelfT ] RETURNS DESCRIPTION Self The sector object to allow fluent-style. Source code in multibar\\api\\sectors.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @abc . abstractmethod def add_to_progressbar ( self : SelfT , progressbar : progressbars . ProgressbarAware [ SelfT ], / ) -> SelfT : \"\"\"Adds sector self to progressbar. Parameters ---------- progressbar : progressbars.ProgressbarAware[SelfT], / Progressbar to add self for. Returns ------- Self The sector object to allow fluent-style. \"\"\" ...","title":"add_to_progressbar()"},{"location":"api/sectors/#multibar.api.sectors.AbstractSector.change_name","text":"Changes sector display name. PARAMETER DESCRIPTION new_display_name New display name to set. TYPE: str RETURNS DESCRIPTION Self The sector object to allow fluent-style. Source code in multibar\\api\\sectors.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @abc . abstractmethod def change_name ( self , new_display_name : str , / ) -> AbstractSector : \"\"\"Changes sector display name. Parameters ---------- new_display_name : str, / New display name to set. Returns ------- Self The sector object to allow fluent-style. \"\"\" ...","title":"change_name()"},{"location":"api/sectors/#multibar.api.sectors.AbstractSector.is_filled","text":"RETURNS DESCRIPTION str Sector filled value. Source code in multibar\\api\\sectors.py 93 94 95 96 97 98 99 100 101 102 @property @abc . abstractmethod def is_filled ( self ) -> bool : \"\"\" Returns ------- str Sector filled value. \"\"\" ...","title":"is_filled()"},{"location":"api/sectors/#multibar.api.sectors.AbstractSector.name","text":"RETURNS DESCRIPTION str Sector display name. Source code in multibar\\api\\sectors.py 82 83 84 85 86 87 88 89 90 91 @property @abc . abstractmethod def name ( self ) -> str : \"\"\" Returns ------- str Sector display name. \"\"\" ...","title":"name()"},{"location":"api/sectors/#multibar.api.sectors.AbstractSector.position","text":"RETURNS DESCRIPTION str Sector position in the progressbar. Source code in multibar\\api\\sectors.py 104 105 106 107 108 109 110 111 112 113 @property @abc . abstractmethod def position ( self ) -> int : \"\"\" Returns ------- str Sector position in the progressbar. \"\"\" ...","title":"position()"},{"location":"api/signatures/","text":"multibar.api.signatures \u00a4 Interfaces for progressbar signatures. __all__ = ( 'SignatureSegmentProtocol' , 'ProgressbarSignatureProtocol' ) module-attribute \u00a4 ProgressbarSignatureProtocol \u00a4 Bases: typing . Protocol Signature protocol. Examples: Expand example of usage >>> import dataclasses >>> from unittest.mock import Mock # mock for signature segment ... >>> @dataclasses.dataclass ... class Signature: ... start: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... middle: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... end: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... >>> def function_that_checks_signature( ... signature: ProgressbarSignatureProtocol, / ... ) -> bool: ... return isinstance(signature, ProgressbarSignatureProtocol) ... >>> function_that_checks_signature(Signature()) # Mypy happy :) True Source code in multibar\\api\\signatures.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 @typing . runtime_checkable class ProgressbarSignatureProtocol ( typing . Protocol ): \"\"\"Signature protocol. Examples -------- ??? example \"Expand example of usage\" ``` >>> import dataclasses >>> from unittest.mock import Mock # mock for signature segment ... >>> @dataclasses.dataclass ... class Signature: ... start: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... middle: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... end: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... >>> def function_that_checks_signature( ... signature: ProgressbarSignatureProtocol, / ... ) -> bool: ... return isinstance(signature, ProgressbarSignatureProtocol) ... >>> function_that_checks_signature(Signature()) # Mypy happy :) True ``` \"\"\" @property def start ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar start char. \"\"\" raise NotImplementedError @property def end ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar end char. \"\"\" raise NotImplementedError @property def middle ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar middle char (between start and and). \"\"\" raise NotImplementedError end () property \u00a4 RETURNS DESCRIPTION SignatureSegmentProtocol Progressbar end char. Source code in multibar\\api\\signatures.py 113 114 115 116 117 118 119 120 121 @property def end ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar end char. \"\"\" raise NotImplementedError middle () property \u00a4 RETURNS DESCRIPTION SignatureSegmentProtocol Progressbar middle char (between start and and). Source code in multibar\\api\\signatures.py 123 124 125 126 127 128 129 130 131 @property def middle ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar middle char (between start and and). \"\"\" raise NotImplementedError start () property \u00a4 RETURNS DESCRIPTION SignatureSegmentProtocol Progressbar start char. Source code in multibar\\api\\signatures.py 103 104 105 106 107 108 109 110 111 @property def start ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar start char. \"\"\" raise NotImplementedError SignatureSegmentProtocol \u00a4 Bases: typing . Protocol Signature segment protocol (protocol for one char, that has two states). Examples: Expand example of usage >>> import dataclasses ... >>> @dataclasses . dataclass ... class SignatureSegment : ... on_filled : str = dataclasses . field ( default = \"+\" ) ... on_unfilled : str = dataclasses . field ( default = \"-\" ) ... >>> isinstance ( SignatureSegment (), SignatureSegmentProtocol ) True >>> def function_that_accepts_signature_segment ( ... segment : SignatureSegmentProtocol , / ... ) -> tuple [ str , str ]: ... return segment . on_filled , segment . on_unfilled ... >>> function_that_accepts_signature_segment ( SignatureSegment ()) # Mypy happy :) ( '+' , '-' ) Source code in multibar\\api\\signatures.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @typing . runtime_checkable class SignatureSegmentProtocol ( typing . Protocol ): \"\"\"Signature segment protocol (protocol for one char, that has two states). Examples -------- ??? example \"Expand example of usage\" ```py >>> import dataclasses ... >>> @dataclasses.dataclass ... class SignatureSegment: ... on_filled: str = dataclasses.field(default=\"+\") ... on_unfilled: str = dataclasses.field(default=\"-\") ... >>> isinstance(SignatureSegment(), SignatureSegmentProtocol) True >>> def function_that_accepts_signature_segment( ... segment: SignatureSegmentProtocol, / ... ) -> tuple[str, str]: ... return segment.on_filled, segment.on_unfilled ... >>> function_that_accepts_signature_segment(SignatureSegment()) # Mypy happy :) ('+', '-') ``` \"\"\" @property def on_filled ( self ) -> str : \"\"\" Returns ------- str On filled state. \"\"\" raise NotImplementedError @property def on_unfilled ( self ) -> str : \"\"\" Returns ------- str On unfilled state. \"\"\" raise NotImplementedError on_filled () property \u00a4 RETURNS DESCRIPTION str On filled state. Source code in multibar\\api\\signatures.py 55 56 57 58 59 60 61 62 63 @property def on_filled ( self ) -> str : \"\"\" Returns ------- str On filled state. \"\"\" raise NotImplementedError on_unfilled () property \u00a4 RETURNS DESCRIPTION str On unfilled state. Source code in multibar\\api\\signatures.py 65 66 67 68 69 70 71 72 73 @property def on_unfilled ( self ) -> str : \"\"\" Returns ------- str On unfilled state. \"\"\" raise NotImplementedError","title":"Signatures"},{"location":"api/signatures/#multibar.api.signatures","text":"Interfaces for progressbar signatures.","title":"signatures"},{"location":"api/signatures/#multibar.api.signatures.__all__","text":"","title":"__all__"},{"location":"api/signatures/#multibar.api.signatures.ProgressbarSignatureProtocol","text":"Bases: typing . Protocol Signature protocol. Examples: Expand example of usage >>> import dataclasses >>> from unittest.mock import Mock # mock for signature segment ... >>> @dataclasses.dataclass ... class Signature: ... start: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... middle: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... end: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... >>> def function_that_checks_signature( ... signature: ProgressbarSignatureProtocol, / ... ) -> bool: ... return isinstance(signature, ProgressbarSignatureProtocol) ... >>> function_that_checks_signature(Signature()) # Mypy happy :) True Source code in multibar\\api\\signatures.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 @typing . runtime_checkable class ProgressbarSignatureProtocol ( typing . Protocol ): \"\"\"Signature protocol. Examples -------- ??? example \"Expand example of usage\" ``` >>> import dataclasses >>> from unittest.mock import Mock # mock for signature segment ... >>> @dataclasses.dataclass ... class Signature: ... start: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... middle: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... end: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... >>> def function_that_checks_signature( ... signature: ProgressbarSignatureProtocol, / ... ) -> bool: ... return isinstance(signature, ProgressbarSignatureProtocol) ... >>> function_that_checks_signature(Signature()) # Mypy happy :) True ``` \"\"\" @property def start ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar start char. \"\"\" raise NotImplementedError @property def end ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar end char. \"\"\" raise NotImplementedError @property def middle ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar middle char (between start and and). \"\"\" raise NotImplementedError","title":"ProgressbarSignatureProtocol"},{"location":"api/signatures/#multibar.api.signatures.ProgressbarSignatureProtocol.end","text":"RETURNS DESCRIPTION SignatureSegmentProtocol Progressbar end char. Source code in multibar\\api\\signatures.py 113 114 115 116 117 118 119 120 121 @property def end ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar end char. \"\"\" raise NotImplementedError","title":"end()"},{"location":"api/signatures/#multibar.api.signatures.ProgressbarSignatureProtocol.middle","text":"RETURNS DESCRIPTION SignatureSegmentProtocol Progressbar middle char (between start and and). Source code in multibar\\api\\signatures.py 123 124 125 126 127 128 129 130 131 @property def middle ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar middle char (between start and and). \"\"\" raise NotImplementedError","title":"middle()"},{"location":"api/signatures/#multibar.api.signatures.ProgressbarSignatureProtocol.start","text":"RETURNS DESCRIPTION SignatureSegmentProtocol Progressbar start char. Source code in multibar\\api\\signatures.py 103 104 105 106 107 108 109 110 111 @property def start ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar start char. \"\"\" raise NotImplementedError","title":"start()"},{"location":"api/signatures/#multibar.api.signatures.SignatureSegmentProtocol","text":"Bases: typing . Protocol Signature segment protocol (protocol for one char, that has two states). Examples: Expand example of usage >>> import dataclasses ... >>> @dataclasses . dataclass ... class SignatureSegment : ... on_filled : str = dataclasses . field ( default = \"+\" ) ... on_unfilled : str = dataclasses . field ( default = \"-\" ) ... >>> isinstance ( SignatureSegment (), SignatureSegmentProtocol ) True >>> def function_that_accepts_signature_segment ( ... segment : SignatureSegmentProtocol , / ... ) -> tuple [ str , str ]: ... return segment . on_filled , segment . on_unfilled ... >>> function_that_accepts_signature_segment ( SignatureSegment ()) # Mypy happy :) ( '+' , '-' ) Source code in multibar\\api\\signatures.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @typing . runtime_checkable class SignatureSegmentProtocol ( typing . Protocol ): \"\"\"Signature segment protocol (protocol for one char, that has two states). Examples -------- ??? example \"Expand example of usage\" ```py >>> import dataclasses ... >>> @dataclasses.dataclass ... class SignatureSegment: ... on_filled: str = dataclasses.field(default=\"+\") ... on_unfilled: str = dataclasses.field(default=\"-\") ... >>> isinstance(SignatureSegment(), SignatureSegmentProtocol) True >>> def function_that_accepts_signature_segment( ... segment: SignatureSegmentProtocol, / ... ) -> tuple[str, str]: ... return segment.on_filled, segment.on_unfilled ... >>> function_that_accepts_signature_segment(SignatureSegment()) # Mypy happy :) ('+', '-') ``` \"\"\" @property def on_filled ( self ) -> str : \"\"\" Returns ------- str On filled state. \"\"\" raise NotImplementedError @property def on_unfilled ( self ) -> str : \"\"\" Returns ------- str On unfilled state. \"\"\" raise NotImplementedError","title":"SignatureSegmentProtocol"},{"location":"api/signatures/#multibar.api.signatures.SignatureSegmentProtocol.on_filled","text":"RETURNS DESCRIPTION str On filled state. Source code in multibar\\api\\signatures.py 55 56 57 58 59 60 61 62 63 @property def on_filled ( self ) -> str : \"\"\" Returns ------- str On filled state. \"\"\" raise NotImplementedError","title":"on_filled()"},{"location":"api/signatures/#multibar.api.signatures.SignatureSegmentProtocol.on_unfilled","text":"RETURNS DESCRIPTION str On unfilled state. Source code in multibar\\api\\signatures.py 65 66 67 68 69 70 71 72 73 @property def on_unfilled ( self ) -> str : \"\"\" Returns ------- str On unfilled state. \"\"\" raise NotImplementedError","title":"on_unfilled()"},{"location":"api/writers/","text":"multibar.api.writers \u00a4 Interfaces for progressbar writers. __all__ = ( 'ProgressbarWriterAware' ) module-attribute \u00a4 ProgressbarWriterAware \u00a4 Bases: abc . ABC Interface for progressbar writer implementations. Source code in multibar\\api\\writers.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 class ProgressbarWriterAware ( abc . ABC ): \"\"\"Interface for progressbar writer implementations.\"\"\" __slots__ = () @classmethod @abc . abstractmethod def from_signature ( cls , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Alternative constructor from signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / Signature to init. Returns ------- ProgressbarWriterAware[sectors.AbstractSector] Instance of progressbar writer. \"\"\" ... @typing . overload @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @typing . overload @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , * , length : int , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Writes progress without any hooks or checks. Parameters ---------- start_value : int, / Start value (current progress). end_value : int, / End value (needed progress). length : int, * Length of progressbar. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar object. \"\"\" ... @abc . abstractmethod def bind_signature ( self , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Sets new progressbar signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / New signature to set. Returns ------- Self Progressbar writer object to allow fluent-style. \"\"\" ... @property @abc . abstractmethod def signature ( self ) -> signatures . ProgressbarSignatureProtocol : \"\"\" Returns ------- signatures.ProgressbarSignatureProtocol Progressbar signature. \"\"\" ... @property @abc . abstractmethod def sector_cls ( self ) -> typing . Type [ sectors . AbstractSector ]: \"\"\" Returns ------- typing.Type[sectors.AbstractSector] Progressbar sector cls. \"\"\" ... @property @abc . abstractmethod def progressbar_cls ( self ) -> typing . Type [ progressbars . ProgressbarAware [ sectors . AbstractSector ]]: \"\"\" Returns ------- typing.Type[progressbars.ProgressbarAware[sectors.AbstractSector]] Progressbar cls. \"\"\" ... @property @abc . abstractmethod def calculation_cls ( self ) -> typing . Type [ math_operations . AbstractCalculationService ]: \"\"\" Returns ------- typing.Type[math_operations.AbstractCalculationService] Calculation cls. \"\"\" ... __slots__ = () class-attribute \u00a4 bind_signature ( signature ) abstractmethod \u00a4 Sets new progressbar signature. PARAMETER DESCRIPTION signature New signature to set. TYPE: signatures . ProgressbarSignatureProtocol RETURNS DESCRIPTION Self Progressbar writer object to allow fluent-style. Source code in multibar\\api\\writers.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @abc . abstractmethod def bind_signature ( self , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Sets new progressbar signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / New signature to set. Returns ------- Self Progressbar writer object to allow fluent-style. \"\"\" ... calculation_cls () abstractmethod property \u00a4 RETURNS DESCRIPTION typing . Type [ math_operations . AbstractCalculationService ] Calculation cls. Source code in multibar\\api\\writers.py 148 149 150 151 152 153 154 155 156 157 @property @abc . abstractmethod def calculation_cls ( self ) -> typing . Type [ math_operations . AbstractCalculationService ]: \"\"\" Returns ------- typing.Type[math_operations.AbstractCalculationService] Calculation cls. \"\"\" ... from_signature ( signature ) abstractmethod classmethod \u00a4 Alternative constructor from signature. PARAMETER DESCRIPTION signature Signature to init. TYPE: signatures . ProgressbarSignatureProtocol RETURNS DESCRIPTION ProgressbarWriterAware [ sectors . AbstractSector ] Instance of progressbar writer. Source code in multibar\\api\\writers.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @classmethod @abc . abstractmethod def from_signature ( cls , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Alternative constructor from signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / Signature to init. Returns ------- ProgressbarWriterAware[sectors.AbstractSector] Instance of progressbar writer. \"\"\" ... progressbar_cls () abstractmethod property \u00a4 RETURNS DESCRIPTION typing . Type [ progressbars . ProgressbarAware [ sectors . AbstractSector ]] Progressbar cls. Source code in multibar\\api\\writers.py 137 138 139 140 141 142 143 144 145 146 @property @abc . abstractmethod def progressbar_cls ( self ) -> typing . Type [ progressbars . ProgressbarAware [ sectors . AbstractSector ]]: \"\"\" Returns ------- typing.Type[progressbars.ProgressbarAware[sectors.AbstractSector]] Progressbar cls. \"\"\" ... sector_cls () abstractmethod property \u00a4 RETURNS DESCRIPTION typing . Type [ sectors . AbstractSector ] Progressbar sector cls. Source code in multibar\\api\\writers.py 126 127 128 129 130 131 132 133 134 135 @property @abc . abstractmethod def sector_cls ( self ) -> typing . Type [ sectors . AbstractSector ]: \"\"\" Returns ------- typing.Type[sectors.AbstractSector] Progressbar sector cls. \"\"\" ... signature () abstractmethod property \u00a4 RETURNS DESCRIPTION signatures . ProgressbarSignatureProtocol Progressbar signature. Source code in multibar\\api\\writers.py 115 116 117 118 119 120 121 122 123 124 @property @abc . abstractmethod def signature ( self ) -> signatures . ProgressbarSignatureProtocol : \"\"\" Returns ------- signatures.ProgressbarSignatureProtocol Progressbar signature. \"\"\" ... write ( start_value , end_value , / , * , length = 20 ) abstractmethod \u00a4 Writes progress without any hooks or checks. PARAMETER DESCRIPTION start_value Start value (current progress). TYPE: int end_value End value (needed progress). TYPE: int length Length of progressbar. TYPE: int DEFAULT: 20 RETURNS DESCRIPTION progressbars . ProgressbarAware [ sectors . AbstractSector ] Progressbar object. Source code in multibar\\api\\writers.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Writes progress without any hooks or checks. Parameters ---------- start_value : int, / Start value (current progress). end_value : int, / End value (needed progress). length : int, * Length of progressbar. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar object. \"\"\" ...","title":"Writers"},{"location":"api/writers/#multibar.api.writers","text":"Interfaces for progressbar writers.","title":"writers"},{"location":"api/writers/#multibar.api.writers.__all__","text":"","title":"__all__"},{"location":"api/writers/#multibar.api.writers.ProgressbarWriterAware","text":"Bases: abc . ABC Interface for progressbar writer implementations. Source code in multibar\\api\\writers.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 class ProgressbarWriterAware ( abc . ABC ): \"\"\"Interface for progressbar writer implementations.\"\"\" __slots__ = () @classmethod @abc . abstractmethod def from_signature ( cls , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Alternative constructor from signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / Signature to init. Returns ------- ProgressbarWriterAware[sectors.AbstractSector] Instance of progressbar writer. \"\"\" ... @typing . overload @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @typing . overload @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , * , length : int , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Writes progress without any hooks or checks. Parameters ---------- start_value : int, / Start value (current progress). end_value : int, / End value (needed progress). length : int, * Length of progressbar. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar object. \"\"\" ... @abc . abstractmethod def bind_signature ( self , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Sets new progressbar signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / New signature to set. Returns ------- Self Progressbar writer object to allow fluent-style. \"\"\" ... @property @abc . abstractmethod def signature ( self ) -> signatures . ProgressbarSignatureProtocol : \"\"\" Returns ------- signatures.ProgressbarSignatureProtocol Progressbar signature. \"\"\" ... @property @abc . abstractmethod def sector_cls ( self ) -> typing . Type [ sectors . AbstractSector ]: \"\"\" Returns ------- typing.Type[sectors.AbstractSector] Progressbar sector cls. \"\"\" ... @property @abc . abstractmethod def progressbar_cls ( self ) -> typing . Type [ progressbars . ProgressbarAware [ sectors . AbstractSector ]]: \"\"\" Returns ------- typing.Type[progressbars.ProgressbarAware[sectors.AbstractSector]] Progressbar cls. \"\"\" ... @property @abc . abstractmethod def calculation_cls ( self ) -> typing . Type [ math_operations . AbstractCalculationService ]: \"\"\" Returns ------- typing.Type[math_operations.AbstractCalculationService] Calculation cls. \"\"\" ...","title":"ProgressbarWriterAware"},{"location":"api/writers/#multibar.api.writers.ProgressbarWriterAware.__slots__","text":"","title":"__slots__"},{"location":"api/writers/#multibar.api.writers.ProgressbarWriterAware.bind_signature","text":"Sets new progressbar signature. PARAMETER DESCRIPTION signature New signature to set. TYPE: signatures . ProgressbarSignatureProtocol RETURNS DESCRIPTION Self Progressbar writer object to allow fluent-style. Source code in multibar\\api\\writers.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @abc . abstractmethod def bind_signature ( self , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Sets new progressbar signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / New signature to set. Returns ------- Self Progressbar writer object to allow fluent-style. \"\"\" ...","title":"bind_signature()"},{"location":"api/writers/#multibar.api.writers.ProgressbarWriterAware.calculation_cls","text":"RETURNS DESCRIPTION typing . Type [ math_operations . AbstractCalculationService ] Calculation cls. Source code in multibar\\api\\writers.py 148 149 150 151 152 153 154 155 156 157 @property @abc . abstractmethod def calculation_cls ( self ) -> typing . Type [ math_operations . AbstractCalculationService ]: \"\"\" Returns ------- typing.Type[math_operations.AbstractCalculationService] Calculation cls. \"\"\" ...","title":"calculation_cls()"},{"location":"api/writers/#multibar.api.writers.ProgressbarWriterAware.from_signature","text":"Alternative constructor from signature. PARAMETER DESCRIPTION signature Signature to init. TYPE: signatures . ProgressbarSignatureProtocol RETURNS DESCRIPTION ProgressbarWriterAware [ sectors . AbstractSector ] Instance of progressbar writer. Source code in multibar\\api\\writers.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @classmethod @abc . abstractmethod def from_signature ( cls , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Alternative constructor from signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / Signature to init. Returns ------- ProgressbarWriterAware[sectors.AbstractSector] Instance of progressbar writer. \"\"\" ...","title":"from_signature()"},{"location":"api/writers/#multibar.api.writers.ProgressbarWriterAware.progressbar_cls","text":"RETURNS DESCRIPTION typing . Type [ progressbars . ProgressbarAware [ sectors . AbstractSector ]] Progressbar cls. Source code in multibar\\api\\writers.py 137 138 139 140 141 142 143 144 145 146 @property @abc . abstractmethod def progressbar_cls ( self ) -> typing . Type [ progressbars . ProgressbarAware [ sectors . AbstractSector ]]: \"\"\" Returns ------- typing.Type[progressbars.ProgressbarAware[sectors.AbstractSector]] Progressbar cls. \"\"\" ...","title":"progressbar_cls()"},{"location":"api/writers/#multibar.api.writers.ProgressbarWriterAware.sector_cls","text":"RETURNS DESCRIPTION typing . Type [ sectors . AbstractSector ] Progressbar sector cls. Source code in multibar\\api\\writers.py 126 127 128 129 130 131 132 133 134 135 @property @abc . abstractmethod def sector_cls ( self ) -> typing . Type [ sectors . AbstractSector ]: \"\"\" Returns ------- typing.Type[sectors.AbstractSector] Progressbar sector cls. \"\"\" ...","title":"sector_cls()"},{"location":"api/writers/#multibar.api.writers.ProgressbarWriterAware.signature","text":"RETURNS DESCRIPTION signatures . ProgressbarSignatureProtocol Progressbar signature. Source code in multibar\\api\\writers.py 115 116 117 118 119 120 121 122 123 124 @property @abc . abstractmethod def signature ( self ) -> signatures . ProgressbarSignatureProtocol : \"\"\" Returns ------- signatures.ProgressbarSignatureProtocol Progressbar signature. \"\"\" ...","title":"signature()"},{"location":"api/writers/#multibar.api.writers.ProgressbarWriterAware.write","text":"Writes progress without any hooks or checks. PARAMETER DESCRIPTION start_value Start value (current progress). TYPE: int end_value End value (needed progress). TYPE: int length Length of progressbar. TYPE: int DEFAULT: 20 RETURNS DESCRIPTION progressbars . ProgressbarAware [ sectors . AbstractSector ] Progressbar object. Source code in multibar\\api\\writers.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Writes progress without any hooks or checks. Parameters ---------- start_value : int, / Start value (current progress). end_value : int, / End value (needed progress). length : int, * Length of progressbar. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar object. \"\"\" ...","title":"write()"},{"location":"impl/clients/","text":"multibar.impl.clients \u00a4 Implementations of Python-Multibar clients. __all__ = ( 'ProgressbarClient' ) module-attribute \u00a4 ProgressbarClient \u00a4 Bases: abc_clients . ProgressbarClientAware Implementation of abc_clients.ProgressbarClientAware. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\clients.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class ProgressbarClient ( abc_clients . ProgressbarClientAware ): \"\"\"Implementation of abc_clients.ProgressbarClientAware. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" __slots__ = ( \"_hooks\" , \"_writer\" , \"_contract_manager\" ) def __init__ ( self , * , hooks : typing . Optional [ abc_hooks . HooksAware ] = None , progress_writer : typing . Optional [ abc_writers . ProgressbarWriterAware ] = None , contract_manager : typing . Optional [ abc_contracts . ContractManagerAware ] = None , ) -> None : \"\"\" Parameters ---------- hooks : typing.Optional[HooksAware] = None Progressbar client hooks. progress_writer : typing.Optional[ProgressbarWriterAware[AbstractSector]] = None Writer for progressbar generation. contract_manager : typing.Optional[ContractManagerAware] = None Contract manager for any progress checks. \"\"\" self . _hooks = utils . none_or ( hooks_ . Hooks (), hooks ) self . _writer = utils . none_or ( writers . ProgressbarWriter (), progress_writer ) if contract_manager is None : contract_manager = contracts . ContractManager () contract_manager . subscribe ( contracts . WRITE_PROGRESS_CONTRACT ) self . _contract_manager : abc_contracts . ContractManagerAware = contract_manager def _validate_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers on-error hooks if broken contract raise error. !!! warning It will not handle broken contract, if contract.raise_errors equals to False. Parameters ---------- *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. \"\"\" try : self . _contract_manager . check_contracts ( * args , ** kwargs ) except Exception as exc : self . _hooks . trigger_on_error ( * args , exc , ** kwargs ) def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: \"\"\"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. Parameters ---------- start_value : int, / Start value (current progress) for progressbar math operations. end_value : int, / End value (needed progress) for progressbar math operations. length : int = 20, * Length of progressbar for progressbar math operations. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar instance. \"\"\" writer = self . _writer call_metadata : progress_types . ProgressMetadataType = { \"calculation_service_cls\" : writer . calculation_cls , \"progressbar\" : None , \"start_value\" : start_value , \"end_value\" : end_value , \"length\" : length , \"sig\" : writer . signature , } self . _validate_contracts ( self . _writer , metadata = call_metadata ) self . _hooks . trigger_pre_execution ( self , metadata = call_metadata ) progressbar = self . _writer . write ( start_value , end_value , length = length ) call_metadata [ \"progressbar\" ] = progressbar self . _hooks . trigger_post_execution ( self , metadata = call_metadata ) return progressbar def set_hooks ( self , hooks : abc_hooks . HooksAware , / ) -> ProgressbarClient : \"\"\"Sets hooks to the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to set. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" self . _hooks = hooks return self def update_hooks ( self , hooks : abc_hooks . HooksAware , / ) -> ProgressbarClient : \"\"\"Updates hooks for the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to update. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" self . _hooks . update ( hooks ) return self @property def hooks ( self ) -> abc_hooks . HooksAware : \"\"\" Returns ------- hooks_.HooksAware Client hooks. \"\"\" return self . _hooks @property def contract_manager ( self ) -> abc_contracts . ContractManagerAware : \"\"\" Returns ------- contracts.ContractManagerAware Client contract manager for checks. \"\"\" return self . _contract_manager @property def writer ( self ) -> abc_writers . ProgressbarWriterAware : \"\"\" Returns ------- writers.ProgressbarWriterAware[sectors.AbstractSector] Progressbar writer for progress generating. \"\"\" return self . _writer __slots__ = ( '_hooks' , '_writer' , '_contract_manager' ) class-attribute \u00a4 __init__ ( * , hooks = None , progress_writer = None , contract_manager = None ) \u00a4 PARAMETER DESCRIPTION hooks Progressbar client hooks. TYPE: typing . Optional [ HooksAware ] DEFAULT: None progress_writer Writer for progressbar generation. TYPE: typing . Optional [ ProgressbarWriterAware [ AbstractSector ]] DEFAULT: None contract_manager Contract manager for any progress checks. TYPE: typing . Optional [ ContractManagerAware ] DEFAULT: None Source code in multibar\\impl\\clients.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , * , hooks : typing . Optional [ abc_hooks . HooksAware ] = None , progress_writer : typing . Optional [ abc_writers . ProgressbarWriterAware ] = None , contract_manager : typing . Optional [ abc_contracts . ContractManagerAware ] = None , ) -> None : \"\"\" Parameters ---------- hooks : typing.Optional[HooksAware] = None Progressbar client hooks. progress_writer : typing.Optional[ProgressbarWriterAware[AbstractSector]] = None Writer for progressbar generation. contract_manager : typing.Optional[ContractManagerAware] = None Contract manager for any progress checks. \"\"\" self . _hooks = utils . none_or ( hooks_ . Hooks (), hooks ) self . _writer = utils . none_or ( writers . ProgressbarWriter (), progress_writer ) if contract_manager is None : contract_manager = contracts . ContractManager () contract_manager . subscribe ( contracts . WRITE_PROGRESS_CONTRACT ) self . _contract_manager : abc_contracts . ContractManagerAware = contract_manager contract_manager () property \u00a4 RETURNS DESCRIPTION contracts . ContractManagerAware Client contract manager for checks. Source code in multibar\\impl\\clients.py 179 180 181 182 183 184 185 186 187 @property def contract_manager ( self ) -> abc_contracts . ContractManagerAware : \"\"\" Returns ------- contracts.ContractManagerAware Client contract manager for checks. \"\"\" return self . _contract_manager get_progress ( start_value , end_value , / , * , length = 20 ) \u00a4 Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. PARAMETER DESCRIPTION start_value Start value (current progress) for progressbar math operations. TYPE: int end_value End value (needed progress) for progressbar math operations. TYPE: int length Length of progressbar for progressbar math operations. TYPE: int DEFAULT: 20 RETURNS DESCRIPTION progressbars . ProgressbarAware [ sectors . AbstractSector ] Progressbar instance. Source code in multibar\\impl\\clients.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: \"\"\"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. Parameters ---------- start_value : int, / Start value (current progress) for progressbar math operations. end_value : int, / End value (needed progress) for progressbar math operations. length : int = 20, * Length of progressbar for progressbar math operations. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar instance. \"\"\" writer = self . _writer call_metadata : progress_types . ProgressMetadataType = { \"calculation_service_cls\" : writer . calculation_cls , \"progressbar\" : None , \"start_value\" : start_value , \"end_value\" : end_value , \"length\" : length , \"sig\" : writer . signature , } self . _validate_contracts ( self . _writer , metadata = call_metadata ) self . _hooks . trigger_pre_execution ( self , metadata = call_metadata ) progressbar = self . _writer . write ( start_value , end_value , length = length ) call_metadata [ \"progressbar\" ] = progressbar self . _hooks . trigger_post_execution ( self , metadata = call_metadata ) return progressbar hooks () property \u00a4 RETURNS DESCRIPTION hooks_ . HooksAware Client hooks. Source code in multibar\\impl\\clients.py 169 170 171 172 173 174 175 176 177 @property def hooks ( self ) -> abc_hooks . HooksAware : \"\"\" Returns ------- hooks_.HooksAware Client hooks. \"\"\" return self . _hooks set_hooks ( hooks ) \u00a4 Sets hooks to the client. PARAMETER DESCRIPTION hooks Any hooks to set. TYPE: hooks_ . HooksAware RETURNS DESCRIPTION Self ProgressbarClient object to allow fluent-style. Source code in multibar\\impl\\clients.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def set_hooks ( self , hooks : abc_hooks . HooksAware , / ) -> ProgressbarClient : \"\"\"Sets hooks to the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to set. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" self . _hooks = hooks return self update_hooks ( hooks ) \u00a4 Updates hooks for the client. PARAMETER DESCRIPTION hooks Any hooks to update. TYPE: hooks_ . HooksAware RETURNS DESCRIPTION Self ProgressbarClient object to allow fluent-style. Source code in multibar\\impl\\clients.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def update_hooks ( self , hooks : abc_hooks . HooksAware , / ) -> ProgressbarClient : \"\"\"Updates hooks for the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to update. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" self . _hooks . update ( hooks ) return self writer () property \u00a4 RETURNS DESCRIPTION writers . ProgressbarWriterAware [ sectors . AbstractSector ] Progressbar writer for progress generating. Source code in multibar\\impl\\clients.py 189 190 191 192 193 194 195 196 197 @property def writer ( self ) -> abc_writers . ProgressbarWriterAware : \"\"\" Returns ------- writers.ProgressbarWriterAware[sectors.AbstractSector] Progressbar writer for progress generating. \"\"\" return self . _writer","title":"Clients"},{"location":"impl/clients/#multibar.impl.clients","text":"Implementations of Python-Multibar clients.","title":"clients"},{"location":"impl/clients/#multibar.impl.clients.__all__","text":"","title":"__all__"},{"location":"impl/clients/#multibar.impl.clients.ProgressbarClient","text":"Bases: abc_clients . ProgressbarClientAware Implementation of abc_clients.ProgressbarClientAware. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\clients.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class ProgressbarClient ( abc_clients . ProgressbarClientAware ): \"\"\"Implementation of abc_clients.ProgressbarClientAware. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" __slots__ = ( \"_hooks\" , \"_writer\" , \"_contract_manager\" ) def __init__ ( self , * , hooks : typing . Optional [ abc_hooks . HooksAware ] = None , progress_writer : typing . Optional [ abc_writers . ProgressbarWriterAware ] = None , contract_manager : typing . Optional [ abc_contracts . ContractManagerAware ] = None , ) -> None : \"\"\" Parameters ---------- hooks : typing.Optional[HooksAware] = None Progressbar client hooks. progress_writer : typing.Optional[ProgressbarWriterAware[AbstractSector]] = None Writer for progressbar generation. contract_manager : typing.Optional[ContractManagerAware] = None Contract manager for any progress checks. \"\"\" self . _hooks = utils . none_or ( hooks_ . Hooks (), hooks ) self . _writer = utils . none_or ( writers . ProgressbarWriter (), progress_writer ) if contract_manager is None : contract_manager = contracts . ContractManager () contract_manager . subscribe ( contracts . WRITE_PROGRESS_CONTRACT ) self . _contract_manager : abc_contracts . ContractManagerAware = contract_manager def _validate_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers on-error hooks if broken contract raise error. !!! warning It will not handle broken contract, if contract.raise_errors equals to False. Parameters ---------- *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. \"\"\" try : self . _contract_manager . check_contracts ( * args , ** kwargs ) except Exception as exc : self . _hooks . trigger_on_error ( * args , exc , ** kwargs ) def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: \"\"\"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. Parameters ---------- start_value : int, / Start value (current progress) for progressbar math operations. end_value : int, / End value (needed progress) for progressbar math operations. length : int = 20, * Length of progressbar for progressbar math operations. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar instance. \"\"\" writer = self . _writer call_metadata : progress_types . ProgressMetadataType = { \"calculation_service_cls\" : writer . calculation_cls , \"progressbar\" : None , \"start_value\" : start_value , \"end_value\" : end_value , \"length\" : length , \"sig\" : writer . signature , } self . _validate_contracts ( self . _writer , metadata = call_metadata ) self . _hooks . trigger_pre_execution ( self , metadata = call_metadata ) progressbar = self . _writer . write ( start_value , end_value , length = length ) call_metadata [ \"progressbar\" ] = progressbar self . _hooks . trigger_post_execution ( self , metadata = call_metadata ) return progressbar def set_hooks ( self , hooks : abc_hooks . HooksAware , / ) -> ProgressbarClient : \"\"\"Sets hooks to the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to set. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" self . _hooks = hooks return self def update_hooks ( self , hooks : abc_hooks . HooksAware , / ) -> ProgressbarClient : \"\"\"Updates hooks for the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to update. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" self . _hooks . update ( hooks ) return self @property def hooks ( self ) -> abc_hooks . HooksAware : \"\"\" Returns ------- hooks_.HooksAware Client hooks. \"\"\" return self . _hooks @property def contract_manager ( self ) -> abc_contracts . ContractManagerAware : \"\"\" Returns ------- contracts.ContractManagerAware Client contract manager for checks. \"\"\" return self . _contract_manager @property def writer ( self ) -> abc_writers . ProgressbarWriterAware : \"\"\" Returns ------- writers.ProgressbarWriterAware[sectors.AbstractSector] Progressbar writer for progress generating. \"\"\" return self . _writer","title":"ProgressbarClient"},{"location":"impl/clients/#multibar.impl.clients.ProgressbarClient.__slots__","text":"","title":"__slots__"},{"location":"impl/clients/#multibar.impl.clients.ProgressbarClient.__init__","text":"PARAMETER DESCRIPTION hooks Progressbar client hooks. TYPE: typing . Optional [ HooksAware ] DEFAULT: None progress_writer Writer for progressbar generation. TYPE: typing . Optional [ ProgressbarWriterAware [ AbstractSector ]] DEFAULT: None contract_manager Contract manager for any progress checks. TYPE: typing . Optional [ ContractManagerAware ] DEFAULT: None Source code in multibar\\impl\\clients.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , * , hooks : typing . Optional [ abc_hooks . HooksAware ] = None , progress_writer : typing . Optional [ abc_writers . ProgressbarWriterAware ] = None , contract_manager : typing . Optional [ abc_contracts . ContractManagerAware ] = None , ) -> None : \"\"\" Parameters ---------- hooks : typing.Optional[HooksAware] = None Progressbar client hooks. progress_writer : typing.Optional[ProgressbarWriterAware[AbstractSector]] = None Writer for progressbar generation. contract_manager : typing.Optional[ContractManagerAware] = None Contract manager for any progress checks. \"\"\" self . _hooks = utils . none_or ( hooks_ . Hooks (), hooks ) self . _writer = utils . none_or ( writers . ProgressbarWriter (), progress_writer ) if contract_manager is None : contract_manager = contracts . ContractManager () contract_manager . subscribe ( contracts . WRITE_PROGRESS_CONTRACT ) self . _contract_manager : abc_contracts . ContractManagerAware = contract_manager","title":"__init__()"},{"location":"impl/clients/#multibar.impl.clients.ProgressbarClient.contract_manager","text":"RETURNS DESCRIPTION contracts . ContractManagerAware Client contract manager for checks. Source code in multibar\\impl\\clients.py 179 180 181 182 183 184 185 186 187 @property def contract_manager ( self ) -> abc_contracts . ContractManagerAware : \"\"\" Returns ------- contracts.ContractManagerAware Client contract manager for checks. \"\"\" return self . _contract_manager","title":"contract_manager()"},{"location":"impl/clients/#multibar.impl.clients.ProgressbarClient.get_progress","text":"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. PARAMETER DESCRIPTION start_value Start value (current progress) for progressbar math operations. TYPE: int end_value End value (needed progress) for progressbar math operations. TYPE: int length Length of progressbar for progressbar math operations. TYPE: int DEFAULT: 20 RETURNS DESCRIPTION progressbars . ProgressbarAware [ sectors . AbstractSector ] Progressbar instance. Source code in multibar\\impl\\clients.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: \"\"\"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. Parameters ---------- start_value : int, / Start value (current progress) for progressbar math operations. end_value : int, / End value (needed progress) for progressbar math operations. length : int = 20, * Length of progressbar for progressbar math operations. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar instance. \"\"\" writer = self . _writer call_metadata : progress_types . ProgressMetadataType = { \"calculation_service_cls\" : writer . calculation_cls , \"progressbar\" : None , \"start_value\" : start_value , \"end_value\" : end_value , \"length\" : length , \"sig\" : writer . signature , } self . _validate_contracts ( self . _writer , metadata = call_metadata ) self . _hooks . trigger_pre_execution ( self , metadata = call_metadata ) progressbar = self . _writer . write ( start_value , end_value , length = length ) call_metadata [ \"progressbar\" ] = progressbar self . _hooks . trigger_post_execution ( self , metadata = call_metadata ) return progressbar","title":"get_progress()"},{"location":"impl/clients/#multibar.impl.clients.ProgressbarClient.hooks","text":"RETURNS DESCRIPTION hooks_ . HooksAware Client hooks. Source code in multibar\\impl\\clients.py 169 170 171 172 173 174 175 176 177 @property def hooks ( self ) -> abc_hooks . HooksAware : \"\"\" Returns ------- hooks_.HooksAware Client hooks. \"\"\" return self . _hooks","title":"hooks()"},{"location":"impl/clients/#multibar.impl.clients.ProgressbarClient.set_hooks","text":"Sets hooks to the client. PARAMETER DESCRIPTION hooks Any hooks to set. TYPE: hooks_ . HooksAware RETURNS DESCRIPTION Self ProgressbarClient object to allow fluent-style. Source code in multibar\\impl\\clients.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def set_hooks ( self , hooks : abc_hooks . HooksAware , / ) -> ProgressbarClient : \"\"\"Sets hooks to the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to set. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" self . _hooks = hooks return self","title":"set_hooks()"},{"location":"impl/clients/#multibar.impl.clients.ProgressbarClient.update_hooks","text":"Updates hooks for the client. PARAMETER DESCRIPTION hooks Any hooks to update. TYPE: hooks_ . HooksAware RETURNS DESCRIPTION Self ProgressbarClient object to allow fluent-style. Source code in multibar\\impl\\clients.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def update_hooks ( self , hooks : abc_hooks . HooksAware , / ) -> ProgressbarClient : \"\"\"Updates hooks for the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to update. Returns ------- Self ProgressbarClient object to allow fluent-style. \"\"\" self . _hooks . update ( hooks ) return self","title":"update_hooks()"},{"location":"impl/clients/#multibar.impl.clients.ProgressbarClient.writer","text":"RETURNS DESCRIPTION writers . ProgressbarWriterAware [ sectors . AbstractSector ] Progressbar writer for progress generating. Source code in multibar\\impl\\clients.py 189 190 191 192 193 194 195 196 197 @property def writer ( self ) -> abc_writers . ProgressbarWriterAware : \"\"\" Returns ------- writers.ProgressbarWriterAware[sectors.AbstractSector] Progressbar writer for progress generating. \"\"\" return self . _writer","title":"writer()"},{"location":"impl/contracts/","text":"multibar.impl.contracts \u00a4 Implementation of progressbar contracts. WRITE_PROGRESS_CONTRACT = WriteProgressContract () module-attribute \u00a4 Contract that checks if start_value is not more than end_value and if length is more that zero. Warning For subscribing or unsubscribing of WriteProgressContract its recommended to use this variable, because this methods depends on object id . __all__ = ( 'ContractManager' , 'WriteProgressContract' , 'WRITE_PROGRESS_CONTRACT' ) module-attribute \u00a4 ContractManager \u00a4 Bases: contracts . ContractManagerAware Implementation of contracts.ContractManagerAware. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\contracts.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class ContractManager ( contracts . ContractManagerAware ): \"\"\"Implementation of contracts.ContractManagerAware. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" __slots__ = ( \"_contracts\" , \"_raise_errors\" ) def __init__ ( self , * , raise_errors : bool = True ) -> None : \"\"\" Parameters ---------- raise_errors : bool = True If True, will raise errors when contract is broken. \"\"\" self . _contracts : list [ contracts . ContractAware ] = [] self . _raise_errors = raise_errors def _agreed_with_manager ( self , contract : contracts . ContractAware , / ) -> bool : return contract in self . _contracts def set_raise_errors ( self , value : bool , / ) -> None : \"\"\"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- value : bool Raise errors boolean value. Returns ------- None \"\"\" self . _raise_errors = value def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Checks all contracts. Parameters ---------- *args: typing.Any Arguments to contracts check. **kwargs: typing.Any Keyword arguments to contracts check. Returns ------- None \"\"\" for contract in self . _contracts : self . check_contract ( contract , * args , ** kwargs ) def check_contract ( self , contract : contracts . ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : \"\"\"Checks contract for any errors or warnings. Parameters ---------- contract : ContractAware Contract to check. *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. Raises ------ errors.UnsignedContractError If manager is not subscribed for specify contract. Returns ------- None \"\"\" if not self . _agreed_with_manager ( contract ): raise errors . UnsignedContractError ( f \"Contract { type ( contract ) . __name__ } is unsigned.\" ) contract_check = contract . check ( * args , ** kwargs ) if not contract_check . kept : contract . render_terminated_contract ( contract_check , raise_errors = self . _raise_errors , ) def subscribe ( self , contract : contracts . ContractAware , / ) -> None : \"\"\"Subscribes for contract. Parameters ---------- contract : ContractAware Contract to subscribe. Returns ------- None \"\"\" self . _contracts . append ( contract ) def terminate ( self , contract : contracts . ContractAware , / ) -> None : \"\"\"Terminates any contract. Parameters ---------- contract : ContractAware Contract to terminate. Returns ------- None \"\"\" self . _contracts . remove ( contract ) def terminate_all ( self ) -> None : \"\"\"Terminates all contracts. Returns ------- None \"\"\" self . _contracts . clear () @property def contracts ( self ) -> list [ contracts . ContractAware ]: \"\"\" Returns ------- collections.abc.Sequence[ContractAware] Sequence of the contracts. \"\"\" return self . _contracts @property def raise_errors ( self ) -> bool : \"\"\" Returns ------- bool Raise errors boolean value. \"\"\" return self . _raise_errors __slots__ = ( '_contracts' , '_raise_errors' ) class-attribute \u00a4 __init__ ( * , raise_errors = True ) \u00a4 PARAMETER DESCRIPTION raise_errors If True, will raise errors when contract is broken. TYPE: bool DEFAULT: True Source code in multibar\\impl\\contracts.py 43 44 45 46 47 48 49 50 51 def __init__ ( self , * , raise_errors : bool = True ) -> None : \"\"\" Parameters ---------- raise_errors : bool = True If True, will raise errors when contract is broken. \"\"\" self . _contracts : list [ contracts . ContractAware ] = [] self . _raise_errors = raise_errors check_contract ( contract , / , * args , ** kwargs ) \u00a4 Checks contract for any errors or warnings. PARAMETER DESCRIPTION contract Contract to check. TYPE: ContractAware *args Arguments to contract check. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to contract check. TYPE: typing . Any DEFAULT: {} RAISES DESCRIPTION errors . UnsignedContractError If manager is not subscribed for specify contract. RETURNS DESCRIPTION None Source code in multibar\\impl\\contracts.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def check_contract ( self , contract : contracts . ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : \"\"\"Checks contract for any errors or warnings. Parameters ---------- contract : ContractAware Contract to check. *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. Raises ------ errors.UnsignedContractError If manager is not subscribed for specify contract. Returns ------- None \"\"\" if not self . _agreed_with_manager ( contract ): raise errors . UnsignedContractError ( f \"Contract { type ( contract ) . __name__ } is unsigned.\" ) contract_check = contract . check ( * args , ** kwargs ) if not contract_check . kept : contract . render_terminated_contract ( contract_check , raise_errors = self . _raise_errors , ) check_contracts ( * args , ** kwargs ) \u00a4 Checks all contracts. PARAMETER DESCRIPTION *args Arguments to contracts check. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to contracts check. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\impl\\contracts.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Checks all contracts. Parameters ---------- *args: typing.Any Arguments to contracts check. **kwargs: typing.Any Keyword arguments to contracts check. Returns ------- None \"\"\" for contract in self . _contracts : self . check_contract ( contract , * args , ** kwargs ) contracts () property \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ ContractAware ] Sequence of the contracts. Source code in multibar\\impl\\contracts.py 163 164 165 166 167 168 169 170 171 @property def contracts ( self ) -> list [ contracts . ContractAware ]: \"\"\" Returns ------- collections.abc.Sequence[ContractAware] Sequence of the contracts. \"\"\" return self . _contracts raise_errors () property \u00a4 RETURNS DESCRIPTION bool Raise errors boolean value. Source code in multibar\\impl\\contracts.py 173 174 175 176 177 178 179 180 181 @property def raise_errors ( self ) -> bool : \"\"\" Returns ------- bool Raise errors boolean value. \"\"\" return self . _raise_errors set_raise_errors ( value ) \u00a4 Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. PARAMETER DESCRIPTION value Raise errors boolean value. TYPE: bool RETURNS DESCRIPTION None Source code in multibar\\impl\\contracts.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def set_raise_errors ( self , value : bool , / ) -> None : \"\"\"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- value : bool Raise errors boolean value. Returns ------- None \"\"\" self . _raise_errors = value subscribe ( contract ) \u00a4 Subscribes for contract. PARAMETER DESCRIPTION contract Contract to subscribe. TYPE: ContractAware RETURNS DESCRIPTION None Source code in multibar\\impl\\contracts.py 126 127 128 129 130 131 132 133 134 135 136 137 138 def subscribe ( self , contract : contracts . ContractAware , / ) -> None : \"\"\"Subscribes for contract. Parameters ---------- contract : ContractAware Contract to subscribe. Returns ------- None \"\"\" self . _contracts . append ( contract ) terminate ( contract ) \u00a4 Terminates any contract. PARAMETER DESCRIPTION contract Contract to terminate. TYPE: ContractAware RETURNS DESCRIPTION None Source code in multibar\\impl\\contracts.py 140 141 142 143 144 145 146 147 148 149 150 151 152 def terminate ( self , contract : contracts . ContractAware , / ) -> None : \"\"\"Terminates any contract. Parameters ---------- contract : ContractAware Contract to terminate. Returns ------- None \"\"\" self . _contracts . remove ( contract ) terminate_all () \u00a4 Terminates all contracts. RETURNS DESCRIPTION None Source code in multibar\\impl\\contracts.py 154 155 156 157 158 159 160 161 def terminate_all ( self ) -> None : \"\"\"Terminates all contracts. Returns ------- None \"\"\" self . _contracts . clear () WriteProgressContract \u00a4 Bases: contracts . ContractAware Implementation of contracts.ContractAware. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\contracts.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 class WriteProgressContract ( contracts . ContractAware ): \"\"\"Implementation of contracts.ContractAware. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> contracts . ContractCheck : \"\"\"Checks contract for errors and warnings. Parameters ---------- *args : typing.Any Arguments to check. **kwargs : typing.Any Keyword arguments to check. Returns ------- contracts.ContractCheck Contract response. \"\"\" call_metadata = meta = typing . cast ( typing . MutableMapping [ typing . Any , typing . Any ], kwargs . pop ( \"metadata\" , {})) if not call_metadata : return contracts . ContractCheck . terminated ( errors = [ \"Needs metadata argument.\" ], metadata = call_metadata , ) start , end , length = meta [ \"start_value\" ], meta [ \"end_value\" ], meta [ \"length\" ] if start > end : return contracts . ContractCheck . terminated ( errors = [ \"Start value cannot be more than end value.\" ], metadata = call_metadata , ) if length <= 0 : return contracts . ContractCheck . terminated ( errors = [ \"Length of progress bar must be more than 0.\" ], metadata = call_metadata , ) return contracts . ContractCheck . done ( metadata = call_metadata , ) @typing . overload def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : typing . Literal [ False ], ) -> typing . NoReturn : # Will raise any error. ... @typing . overload def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : typing . Literal [ True ], ) -> IO [ None ]: # Will print any errors/warnings in console. ... @typing . overload def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : ... @impure def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : \"\"\"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- check : ContractCheck Contract response. raise_errors : bool If True, will raise errors when contract is broken. Raises ------ errors.TerminatedContractError If `raise_errors` parameter is `True`. Returns ------- typing.Any Any value depending on context and implementation. \"\"\" if raise_errors : raise errors . TerminatedContractError ( check ) self_module = self . __module__ + \".\" + \"WriteProgressContract\" output . print_heading ( f \" { self_module } was broken\" , level = 1 , indent = False ) output . print ( f \"Warnings: { len ( check . warnings ) } \" , bold = True ) for warning in check . warnings : output . print_warning ( warning ) output . print ( f \"Errors: { len ( check . errors ) } \" , bold = True ) for error in check . errors : output . print_error ( error ) return IO ( None ) check ( * args , ** kwargs ) \u00a4 Checks contract for errors and warnings. PARAMETER DESCRIPTION *args Arguments to check. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to check. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION contracts . ContractCheck Contract response. Source code in multibar\\impl\\contracts.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> contracts . ContractCheck : \"\"\"Checks contract for errors and warnings. Parameters ---------- *args : typing.Any Arguments to check. **kwargs : typing.Any Keyword arguments to check. Returns ------- contracts.ContractCheck Contract response. \"\"\" call_metadata = meta = typing . cast ( typing . MutableMapping [ typing . Any , typing . Any ], kwargs . pop ( \"metadata\" , {})) if not call_metadata : return contracts . ContractCheck . terminated ( errors = [ \"Needs metadata argument.\" ], metadata = call_metadata , ) start , end , length = meta [ \"start_value\" ], meta [ \"end_value\" ], meta [ \"length\" ] if start > end : return contracts . ContractCheck . terminated ( errors = [ \"Start value cannot be more than end value.\" ], metadata = call_metadata , ) if length <= 0 : return contracts . ContractCheck . terminated ( errors = [ \"Length of progress bar must be more than 0.\" ], metadata = call_metadata , ) return contracts . ContractCheck . done ( metadata = call_metadata , ) render_terminated_contract ( check , / , * , raise_errors ) \u00a4 Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. PARAMETER DESCRIPTION check Contract response. TYPE: ContractCheck raise_errors If True, will raise errors when contract is broken. TYPE: bool RAISES DESCRIPTION errors . TerminatedContractError If raise_errors parameter is True . RETURNS DESCRIPTION typing . Any Any value depending on context and implementation. Source code in multibar\\impl\\contracts.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 @impure def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : \"\"\"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- check : ContractCheck Contract response. raise_errors : bool If True, will raise errors when contract is broken. Raises ------ errors.TerminatedContractError If `raise_errors` parameter is `True`. Returns ------- typing.Any Any value depending on context and implementation. \"\"\" if raise_errors : raise errors . TerminatedContractError ( check ) self_module = self . __module__ + \".\" + \"WriteProgressContract\" output . print_heading ( f \" { self_module } was broken\" , level = 1 , indent = False ) output . print ( f \"Warnings: { len ( check . warnings ) } \" , bold = True ) for warning in check . warnings : output . print_warning ( warning ) output . print ( f \"Errors: { len ( check . errors ) } \" , bold = True ) for error in check . errors : output . print_error ( error ) return IO ( None )","title":"Contracts"},{"location":"impl/contracts/#multibar.impl.contracts","text":"Implementation of progressbar contracts.","title":"contracts"},{"location":"impl/contracts/#multibar.impl.contracts.WRITE_PROGRESS_CONTRACT","text":"Contract that checks if start_value is not more than end_value and if length is more that zero. Warning For subscribing or unsubscribing of WriteProgressContract its recommended to use this variable, because this methods depends on object id .","title":"WRITE_PROGRESS_CONTRACT"},{"location":"impl/contracts/#multibar.impl.contracts.__all__","text":"","title":"__all__"},{"location":"impl/contracts/#multibar.impl.contracts.ContractManager","text":"Bases: contracts . ContractManagerAware Implementation of contracts.ContractManagerAware. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\contracts.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class ContractManager ( contracts . ContractManagerAware ): \"\"\"Implementation of contracts.ContractManagerAware. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" __slots__ = ( \"_contracts\" , \"_raise_errors\" ) def __init__ ( self , * , raise_errors : bool = True ) -> None : \"\"\" Parameters ---------- raise_errors : bool = True If True, will raise errors when contract is broken. \"\"\" self . _contracts : list [ contracts . ContractAware ] = [] self . _raise_errors = raise_errors def _agreed_with_manager ( self , contract : contracts . ContractAware , / ) -> bool : return contract in self . _contracts def set_raise_errors ( self , value : bool , / ) -> None : \"\"\"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- value : bool Raise errors boolean value. Returns ------- None \"\"\" self . _raise_errors = value def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Checks all contracts. Parameters ---------- *args: typing.Any Arguments to contracts check. **kwargs: typing.Any Keyword arguments to contracts check. Returns ------- None \"\"\" for contract in self . _contracts : self . check_contract ( contract , * args , ** kwargs ) def check_contract ( self , contract : contracts . ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : \"\"\"Checks contract for any errors or warnings. Parameters ---------- contract : ContractAware Contract to check. *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. Raises ------ errors.UnsignedContractError If manager is not subscribed for specify contract. Returns ------- None \"\"\" if not self . _agreed_with_manager ( contract ): raise errors . UnsignedContractError ( f \"Contract { type ( contract ) . __name__ } is unsigned.\" ) contract_check = contract . check ( * args , ** kwargs ) if not contract_check . kept : contract . render_terminated_contract ( contract_check , raise_errors = self . _raise_errors , ) def subscribe ( self , contract : contracts . ContractAware , / ) -> None : \"\"\"Subscribes for contract. Parameters ---------- contract : ContractAware Contract to subscribe. Returns ------- None \"\"\" self . _contracts . append ( contract ) def terminate ( self , contract : contracts . ContractAware , / ) -> None : \"\"\"Terminates any contract. Parameters ---------- contract : ContractAware Contract to terminate. Returns ------- None \"\"\" self . _contracts . remove ( contract ) def terminate_all ( self ) -> None : \"\"\"Terminates all contracts. Returns ------- None \"\"\" self . _contracts . clear () @property def contracts ( self ) -> list [ contracts . ContractAware ]: \"\"\" Returns ------- collections.abc.Sequence[ContractAware] Sequence of the contracts. \"\"\" return self . _contracts @property def raise_errors ( self ) -> bool : \"\"\" Returns ------- bool Raise errors boolean value. \"\"\" return self . _raise_errors","title":"ContractManager"},{"location":"impl/contracts/#multibar.impl.contracts.ContractManager.__slots__","text":"","title":"__slots__"},{"location":"impl/contracts/#multibar.impl.contracts.ContractManager.__init__","text":"PARAMETER DESCRIPTION raise_errors If True, will raise errors when contract is broken. TYPE: bool DEFAULT: True Source code in multibar\\impl\\contracts.py 43 44 45 46 47 48 49 50 51 def __init__ ( self , * , raise_errors : bool = True ) -> None : \"\"\" Parameters ---------- raise_errors : bool = True If True, will raise errors when contract is broken. \"\"\" self . _contracts : list [ contracts . ContractAware ] = [] self . _raise_errors = raise_errors","title":"__init__()"},{"location":"impl/contracts/#multibar.impl.contracts.ContractManager.check_contract","text":"Checks contract for any errors or warnings. PARAMETER DESCRIPTION contract Contract to check. TYPE: ContractAware *args Arguments to contract check. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to contract check. TYPE: typing . Any DEFAULT: {} RAISES DESCRIPTION errors . UnsignedContractError If manager is not subscribed for specify contract. RETURNS DESCRIPTION None Source code in multibar\\impl\\contracts.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def check_contract ( self , contract : contracts . ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : \"\"\"Checks contract for any errors or warnings. Parameters ---------- contract : ContractAware Contract to check. *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. Raises ------ errors.UnsignedContractError If manager is not subscribed for specify contract. Returns ------- None \"\"\" if not self . _agreed_with_manager ( contract ): raise errors . UnsignedContractError ( f \"Contract { type ( contract ) . __name__ } is unsigned.\" ) contract_check = contract . check ( * args , ** kwargs ) if not contract_check . kept : contract . render_terminated_contract ( contract_check , raise_errors = self . _raise_errors , )","title":"check_contract()"},{"location":"impl/contracts/#multibar.impl.contracts.ContractManager.check_contracts","text":"Checks all contracts. PARAMETER DESCRIPTION *args Arguments to contracts check. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to contracts check. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\impl\\contracts.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Checks all contracts. Parameters ---------- *args: typing.Any Arguments to contracts check. **kwargs: typing.Any Keyword arguments to contracts check. Returns ------- None \"\"\" for contract in self . _contracts : self . check_contract ( contract , * args , ** kwargs )","title":"check_contracts()"},{"location":"impl/contracts/#multibar.impl.contracts.ContractManager.contracts","text":"RETURNS DESCRIPTION collections . abc . Sequence [ ContractAware ] Sequence of the contracts. Source code in multibar\\impl\\contracts.py 163 164 165 166 167 168 169 170 171 @property def contracts ( self ) -> list [ contracts . ContractAware ]: \"\"\" Returns ------- collections.abc.Sequence[ContractAware] Sequence of the contracts. \"\"\" return self . _contracts","title":"contracts()"},{"location":"impl/contracts/#multibar.impl.contracts.ContractManager.raise_errors","text":"RETURNS DESCRIPTION bool Raise errors boolean value. Source code in multibar\\impl\\contracts.py 173 174 175 176 177 178 179 180 181 @property def raise_errors ( self ) -> bool : \"\"\" Returns ------- bool Raise errors boolean value. \"\"\" return self . _raise_errors","title":"raise_errors()"},{"location":"impl/contracts/#multibar.impl.contracts.ContractManager.set_raise_errors","text":"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. PARAMETER DESCRIPTION value Raise errors boolean value. TYPE: bool RETURNS DESCRIPTION None Source code in multibar\\impl\\contracts.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def set_raise_errors ( self , value : bool , / ) -> None : \"\"\"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- value : bool Raise errors boolean value. Returns ------- None \"\"\" self . _raise_errors = value","title":"set_raise_errors()"},{"location":"impl/contracts/#multibar.impl.contracts.ContractManager.subscribe","text":"Subscribes for contract. PARAMETER DESCRIPTION contract Contract to subscribe. TYPE: ContractAware RETURNS DESCRIPTION None Source code in multibar\\impl\\contracts.py 126 127 128 129 130 131 132 133 134 135 136 137 138 def subscribe ( self , contract : contracts . ContractAware , / ) -> None : \"\"\"Subscribes for contract. Parameters ---------- contract : ContractAware Contract to subscribe. Returns ------- None \"\"\" self . _contracts . append ( contract )","title":"subscribe()"},{"location":"impl/contracts/#multibar.impl.contracts.ContractManager.terminate","text":"Terminates any contract. PARAMETER DESCRIPTION contract Contract to terminate. TYPE: ContractAware RETURNS DESCRIPTION None Source code in multibar\\impl\\contracts.py 140 141 142 143 144 145 146 147 148 149 150 151 152 def terminate ( self , contract : contracts . ContractAware , / ) -> None : \"\"\"Terminates any contract. Parameters ---------- contract : ContractAware Contract to terminate. Returns ------- None \"\"\" self . _contracts . remove ( contract )","title":"terminate()"},{"location":"impl/contracts/#multibar.impl.contracts.ContractManager.terminate_all","text":"Terminates all contracts. RETURNS DESCRIPTION None Source code in multibar\\impl\\contracts.py 154 155 156 157 158 159 160 161 def terminate_all ( self ) -> None : \"\"\"Terminates all contracts. Returns ------- None \"\"\" self . _contracts . clear ()","title":"terminate_all()"},{"location":"impl/contracts/#multibar.impl.contracts.WriteProgressContract","text":"Bases: contracts . ContractAware Implementation of contracts.ContractAware. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\contracts.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 class WriteProgressContract ( contracts . ContractAware ): \"\"\"Implementation of contracts.ContractAware. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> contracts . ContractCheck : \"\"\"Checks contract for errors and warnings. Parameters ---------- *args : typing.Any Arguments to check. **kwargs : typing.Any Keyword arguments to check. Returns ------- contracts.ContractCheck Contract response. \"\"\" call_metadata = meta = typing . cast ( typing . MutableMapping [ typing . Any , typing . Any ], kwargs . pop ( \"metadata\" , {})) if not call_metadata : return contracts . ContractCheck . terminated ( errors = [ \"Needs metadata argument.\" ], metadata = call_metadata , ) start , end , length = meta [ \"start_value\" ], meta [ \"end_value\" ], meta [ \"length\" ] if start > end : return contracts . ContractCheck . terminated ( errors = [ \"Start value cannot be more than end value.\" ], metadata = call_metadata , ) if length <= 0 : return contracts . ContractCheck . terminated ( errors = [ \"Length of progress bar must be more than 0.\" ], metadata = call_metadata , ) return contracts . ContractCheck . done ( metadata = call_metadata , ) @typing . overload def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : typing . Literal [ False ], ) -> typing . NoReturn : # Will raise any error. ... @typing . overload def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : typing . Literal [ True ], ) -> IO [ None ]: # Will print any errors/warnings in console. ... @typing . overload def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : ... @impure def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : \"\"\"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- check : ContractCheck Contract response. raise_errors : bool If True, will raise errors when contract is broken. Raises ------ errors.TerminatedContractError If `raise_errors` parameter is `True`. Returns ------- typing.Any Any value depending on context and implementation. \"\"\" if raise_errors : raise errors . TerminatedContractError ( check ) self_module = self . __module__ + \".\" + \"WriteProgressContract\" output . print_heading ( f \" { self_module } was broken\" , level = 1 , indent = False ) output . print ( f \"Warnings: { len ( check . warnings ) } \" , bold = True ) for warning in check . warnings : output . print_warning ( warning ) output . print ( f \"Errors: { len ( check . errors ) } \" , bold = True ) for error in check . errors : output . print_error ( error ) return IO ( None )","title":"WriteProgressContract"},{"location":"impl/contracts/#multibar.impl.contracts.WriteProgressContract.check","text":"Checks contract for errors and warnings. PARAMETER DESCRIPTION *args Arguments to check. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to check. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION contracts . ContractCheck Contract response. Source code in multibar\\impl\\contracts.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> contracts . ContractCheck : \"\"\"Checks contract for errors and warnings. Parameters ---------- *args : typing.Any Arguments to check. **kwargs : typing.Any Keyword arguments to check. Returns ------- contracts.ContractCheck Contract response. \"\"\" call_metadata = meta = typing . cast ( typing . MutableMapping [ typing . Any , typing . Any ], kwargs . pop ( \"metadata\" , {})) if not call_metadata : return contracts . ContractCheck . terminated ( errors = [ \"Needs metadata argument.\" ], metadata = call_metadata , ) start , end , length = meta [ \"start_value\" ], meta [ \"end_value\" ], meta [ \"length\" ] if start > end : return contracts . ContractCheck . terminated ( errors = [ \"Start value cannot be more than end value.\" ], metadata = call_metadata , ) if length <= 0 : return contracts . ContractCheck . terminated ( errors = [ \"Length of progress bar must be more than 0.\" ], metadata = call_metadata , ) return contracts . ContractCheck . done ( metadata = call_metadata , )","title":"check()"},{"location":"impl/contracts/#multibar.impl.contracts.WriteProgressContract.render_terminated_contract","text":"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. PARAMETER DESCRIPTION check Contract response. TYPE: ContractCheck raise_errors If True, will raise errors when contract is broken. TYPE: bool RAISES DESCRIPTION errors . TerminatedContractError If raise_errors parameter is True . RETURNS DESCRIPTION typing . Any Any value depending on context and implementation. Source code in multibar\\impl\\contracts.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 @impure def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : \"\"\"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- check : ContractCheck Contract response. raise_errors : bool If True, will raise errors when contract is broken. Raises ------ errors.TerminatedContractError If `raise_errors` parameter is `True`. Returns ------- typing.Any Any value depending on context and implementation. \"\"\" if raise_errors : raise errors . TerminatedContractError ( check ) self_module = self . __module__ + \".\" + \"WriteProgressContract\" output . print_heading ( f \" { self_module } was broken\" , level = 1 , indent = False ) output . print ( f \"Warnings: { len ( check . warnings ) } \" , bold = True ) for warning in check . warnings : output . print_warning ( warning ) output . print ( f \"Errors: { len ( check . errors ) } \" , bold = True ) for error in check . errors : output . print_error ( error ) return IO ( None )","title":"render_terminated_contract()"},{"location":"impl/hooks/","text":"multibar.impl.hooks \u00a4 Implementation of hooks interfaces. WRITER_HOOKS = Hooks () module-attribute \u00a4 Hooks that by default supports in post-execution hook progressbar start & end chars. __all__ = ( 'Hooks' , 'WRITER_HOOKS' ) module-attribute \u00a4 Hooks \u00a4 Bases: hooks . HooksAware Implementation of hooks.HooksAware. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\hooks.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 class Hooks ( hooks . HooksAware ): \"\"\"Implementation of hooks.HooksAware. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" __slots__ = ( \"_on_error_hooks\" , \"_pre_execution_hooks\" , \"_post_execution_hooks\" ) def __init__ ( self ) -> None : self . _on_error_hooks : list [ ptypes . HookSignatureType ] = [] self . _pre_execution_hooks : list [ ptypes . HookSignatureType ] = [] self . _post_execution_hooks : list [ ptypes . HookSignatureType ] = [] def __len__ ( self ) -> int : \"\"\" Returns ------- int Length of all hooks. \"\"\" return len ( self . _on_error_hooks + self . _pre_execution_hooks + self . _post_execution_hooks ) def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> Hooks : \"\"\"Adds hooks to the client. Parameters ---------- client : clients.ProgressbarClientAware, / Client to add. Returns ------- Self The hook object to allow fluent-style. \"\"\" if not client . hooks : client . set_hooks ( self ) else : client . update_hooks ( self ) return self def update ( self , other : hooks . HooksAware , / ) -> Hooks : \"\"\"Updates self hooks from other hooks object. Parameters ---------- other : HooksAware, / Other hooks object to update. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _on_error_hooks . extend ( other . on_error_hooks ) self . _post_execution_hooks . extend ( other . post_execution_hooks ) self . _pre_execution_hooks . extend ( other . pre_execution_hooks ) return self def add_pre_execution ( self , callback : ptypes . HookSignatureType , / ) -> Hooks : \"\"\"Adds pre-execution callback. Parameters ---------- callback : ptypes.HookSignatureType, / Pre-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _pre_execution_hooks . append ( callback ) return self def add_post_execution ( self , callback : ptypes . HookSignatureType , / ) -> Hooks : \"\"\"Adds post-execution callback. Parameters ---------- callback : ptypes.HookSignatureType, / Post-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _post_execution_hooks . append ( callback ) return self def add_on_error ( self , callback : ptypes . HookSignatureType , / ) -> Hooks : \"\"\"Adds on-error callback. Parameters ---------- callback : ptypes.HookSignatureType, / On-error callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _on_error_hooks . append ( callback ) return self def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all post-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" for hook in self . _post_execution_hooks : hook ( * args , ** kwargs ) def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all pre-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" for hook in self . _pre_execution_hooks : hook ( * args , ** kwargs ) def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all on-error callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" if not self . _on_error_hooks : raise else : for hook in self . _on_error_hooks : hook ( * args , ** kwargs ) @property def pre_execution_hooks ( self ) -> list [ ptypes . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[ptypes.HookSignatureType] Sequence of pre-execution hooks. \"\"\" return self . _pre_execution_hooks @property def post_execution_hooks ( self ) -> list [ ptypes . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[ptypes.HookSignatureType] Sequence of post-execution hooks. \"\"\" return self . _post_execution_hooks @property def on_error_hooks ( self ) -> list [ ptypes . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[ptypes.HookSignatureType] Sequence of on-error hooks. \"\"\" return self . _on_error_hooks __slots__ = ( '_on_error_hooks' , '_pre_execution_hooks' , '_post_execution_hooks' ) class-attribute \u00a4 __init__ () \u00a4 Source code in multibar\\impl\\hooks.py 43 44 45 46 def __init__ ( self ) -> None : self . _on_error_hooks : list [ ptypes . HookSignatureType ] = [] self . _pre_execution_hooks : list [ ptypes . HookSignatureType ] = [] self . _post_execution_hooks : list [ ptypes . HookSignatureType ] = [] __len__ () \u00a4 RETURNS DESCRIPTION int Length of all hooks. Source code in multibar\\impl\\hooks.py 48 49 50 51 52 53 54 55 def __len__ ( self ) -> int : \"\"\" Returns ------- int Length of all hooks. \"\"\" return len ( self . _on_error_hooks + self . _pre_execution_hooks + self . _post_execution_hooks ) add_on_error ( callback ) \u00a4 Adds on-error callback. PARAMETER DESCRIPTION callback On-error callback. TYPE: ptypes . HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\impl\\hooks.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def add_on_error ( self , callback : ptypes . HookSignatureType , / ) -> Hooks : \"\"\"Adds on-error callback. Parameters ---------- callback : ptypes.HookSignatureType, / On-error callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _on_error_hooks . append ( callback ) return self add_post_execution ( callback ) \u00a4 Adds post-execution callback. PARAMETER DESCRIPTION callback Post-execution callback. TYPE: ptypes . HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\impl\\hooks.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def add_post_execution ( self , callback : ptypes . HookSignatureType , / ) -> Hooks : \"\"\"Adds post-execution callback. Parameters ---------- callback : ptypes.HookSignatureType, / Post-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _post_execution_hooks . append ( callback ) return self add_pre_execution ( callback ) \u00a4 Adds pre-execution callback. PARAMETER DESCRIPTION callback Pre-execution callback. TYPE: ptypes . HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\impl\\hooks.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def add_pre_execution ( self , callback : ptypes . HookSignatureType , / ) -> Hooks : \"\"\"Adds pre-execution callback. Parameters ---------- callback : ptypes.HookSignatureType, / Pre-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _pre_execution_hooks . append ( callback ) return self add_to_client ( client ) \u00a4 Adds hooks to the client. PARAMETER DESCRIPTION client Client to add. TYPE: clients . ProgressbarClientAware RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\impl\\hooks.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> Hooks : \"\"\"Adds hooks to the client. Parameters ---------- client : clients.ProgressbarClientAware, / Client to add. Returns ------- Self The hook object to allow fluent-style. \"\"\" if not client . hooks : client . set_hooks ( self ) else : client . update_hooks ( self ) return self on_error_hooks () property \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ ptypes . HookSignatureType ] Sequence of on-error hooks. Source code in multibar\\impl\\hooks.py 218 219 220 221 222 223 224 225 226 @property def on_error_hooks ( self ) -> list [ ptypes . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[ptypes.HookSignatureType] Sequence of on-error hooks. \"\"\" return self . _on_error_hooks post_execution_hooks () property \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ ptypes . HookSignatureType ] Sequence of post-execution hooks. Source code in multibar\\impl\\hooks.py 208 209 210 211 212 213 214 215 216 @property def post_execution_hooks ( self ) -> list [ ptypes . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[ptypes.HookSignatureType] Sequence of post-execution hooks. \"\"\" return self . _post_execution_hooks pre_execution_hooks () property \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ ptypes . HookSignatureType ] Sequence of pre-execution hooks. Source code in multibar\\impl\\hooks.py 198 199 200 201 202 203 204 205 206 @property def pre_execution_hooks ( self ) -> list [ ptypes . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[ptypes.HookSignatureType] Sequence of pre-execution hooks. \"\"\" return self . _pre_execution_hooks trigger_on_error ( * args , ** kwargs ) \u00a4 Triggers all on-error callbacks. PARAMETER DESCRIPTION *args Arguments to trigger. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to trigger. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\impl\\hooks.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all on-error callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" if not self . _on_error_hooks : raise else : for hook in self . _on_error_hooks : hook ( * args , ** kwargs ) trigger_post_execution ( * args , ** kwargs ) \u00a4 Triggers all post-execution callbacks. PARAMETER DESCRIPTION *args Arguments to trigger. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to trigger. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\impl\\hooks.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all post-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" for hook in self . _post_execution_hooks : hook ( * args , ** kwargs ) trigger_pre_execution ( * args , ** kwargs ) \u00a4 Triggers all pre-execution callbacks. PARAMETER DESCRIPTION *args Arguments to trigger. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to trigger. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\impl\\hooks.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all pre-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" for hook in self . _pre_execution_hooks : hook ( * args , ** kwargs ) update ( other ) \u00a4 Updates self hooks from other hooks object. PARAMETER DESCRIPTION other Other hooks object to update. TYPE: HooksAware RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\impl\\hooks.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def update ( self , other : hooks . HooksAware , / ) -> Hooks : \"\"\"Updates self hooks from other hooks object. Parameters ---------- other : HooksAware, / Other hooks object to update. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _on_error_hooks . extend ( other . on_error_hooks ) self . _post_execution_hooks . extend ( other . post_execution_hooks ) self . _pre_execution_hooks . extend ( other . pre_execution_hooks ) return self","title":"Hooks"},{"location":"impl/hooks/#multibar.impl.hooks","text":"Implementation of hooks interfaces.","title":"hooks"},{"location":"impl/hooks/#multibar.impl.hooks.WRITER_HOOKS","text":"Hooks that by default supports in post-execution hook progressbar start & end chars.","title":"WRITER_HOOKS"},{"location":"impl/hooks/#multibar.impl.hooks.__all__","text":"","title":"__all__"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks","text":"Bases: hooks . HooksAware Implementation of hooks.HooksAware. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\hooks.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 class Hooks ( hooks . HooksAware ): \"\"\"Implementation of hooks.HooksAware. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" __slots__ = ( \"_on_error_hooks\" , \"_pre_execution_hooks\" , \"_post_execution_hooks\" ) def __init__ ( self ) -> None : self . _on_error_hooks : list [ ptypes . HookSignatureType ] = [] self . _pre_execution_hooks : list [ ptypes . HookSignatureType ] = [] self . _post_execution_hooks : list [ ptypes . HookSignatureType ] = [] def __len__ ( self ) -> int : \"\"\" Returns ------- int Length of all hooks. \"\"\" return len ( self . _on_error_hooks + self . _pre_execution_hooks + self . _post_execution_hooks ) def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> Hooks : \"\"\"Adds hooks to the client. Parameters ---------- client : clients.ProgressbarClientAware, / Client to add. Returns ------- Self The hook object to allow fluent-style. \"\"\" if not client . hooks : client . set_hooks ( self ) else : client . update_hooks ( self ) return self def update ( self , other : hooks . HooksAware , / ) -> Hooks : \"\"\"Updates self hooks from other hooks object. Parameters ---------- other : HooksAware, / Other hooks object to update. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _on_error_hooks . extend ( other . on_error_hooks ) self . _post_execution_hooks . extend ( other . post_execution_hooks ) self . _pre_execution_hooks . extend ( other . pre_execution_hooks ) return self def add_pre_execution ( self , callback : ptypes . HookSignatureType , / ) -> Hooks : \"\"\"Adds pre-execution callback. Parameters ---------- callback : ptypes.HookSignatureType, / Pre-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _pre_execution_hooks . append ( callback ) return self def add_post_execution ( self , callback : ptypes . HookSignatureType , / ) -> Hooks : \"\"\"Adds post-execution callback. Parameters ---------- callback : ptypes.HookSignatureType, / Post-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _post_execution_hooks . append ( callback ) return self def add_on_error ( self , callback : ptypes . HookSignatureType , / ) -> Hooks : \"\"\"Adds on-error callback. Parameters ---------- callback : ptypes.HookSignatureType, / On-error callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _on_error_hooks . append ( callback ) return self def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all post-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" for hook in self . _post_execution_hooks : hook ( * args , ** kwargs ) def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all pre-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" for hook in self . _pre_execution_hooks : hook ( * args , ** kwargs ) def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all on-error callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" if not self . _on_error_hooks : raise else : for hook in self . _on_error_hooks : hook ( * args , ** kwargs ) @property def pre_execution_hooks ( self ) -> list [ ptypes . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[ptypes.HookSignatureType] Sequence of pre-execution hooks. \"\"\" return self . _pre_execution_hooks @property def post_execution_hooks ( self ) -> list [ ptypes . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[ptypes.HookSignatureType] Sequence of post-execution hooks. \"\"\" return self . _post_execution_hooks @property def on_error_hooks ( self ) -> list [ ptypes . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[ptypes.HookSignatureType] Sequence of on-error hooks. \"\"\" return self . _on_error_hooks","title":"Hooks"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks.__slots__","text":"","title":"__slots__"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks.__init__","text":"Source code in multibar\\impl\\hooks.py 43 44 45 46 def __init__ ( self ) -> None : self . _on_error_hooks : list [ ptypes . HookSignatureType ] = [] self . _pre_execution_hooks : list [ ptypes . HookSignatureType ] = [] self . _post_execution_hooks : list [ ptypes . HookSignatureType ] = []","title":"__init__()"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks.__len__","text":"RETURNS DESCRIPTION int Length of all hooks. Source code in multibar\\impl\\hooks.py 48 49 50 51 52 53 54 55 def __len__ ( self ) -> int : \"\"\" Returns ------- int Length of all hooks. \"\"\" return len ( self . _on_error_hooks + self . _pre_execution_hooks + self . _post_execution_hooks )","title":"__len__()"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks.add_on_error","text":"Adds on-error callback. PARAMETER DESCRIPTION callback On-error callback. TYPE: ptypes . HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\impl\\hooks.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def add_on_error ( self , callback : ptypes . HookSignatureType , / ) -> Hooks : \"\"\"Adds on-error callback. Parameters ---------- callback : ptypes.HookSignatureType, / On-error callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _on_error_hooks . append ( callback ) return self","title":"add_on_error()"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks.add_post_execution","text":"Adds post-execution callback. PARAMETER DESCRIPTION callback Post-execution callback. TYPE: ptypes . HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\impl\\hooks.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def add_post_execution ( self , callback : ptypes . HookSignatureType , / ) -> Hooks : \"\"\"Adds post-execution callback. Parameters ---------- callback : ptypes.HookSignatureType, / Post-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _post_execution_hooks . append ( callback ) return self","title":"add_post_execution()"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks.add_pre_execution","text":"Adds pre-execution callback. PARAMETER DESCRIPTION callback Pre-execution callback. TYPE: ptypes . HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\impl\\hooks.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def add_pre_execution ( self , callback : ptypes . HookSignatureType , / ) -> Hooks : \"\"\"Adds pre-execution callback. Parameters ---------- callback : ptypes.HookSignatureType, / Pre-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _pre_execution_hooks . append ( callback ) return self","title":"add_pre_execution()"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks.add_to_client","text":"Adds hooks to the client. PARAMETER DESCRIPTION client Client to add. TYPE: clients . ProgressbarClientAware RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\impl\\hooks.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> Hooks : \"\"\"Adds hooks to the client. Parameters ---------- client : clients.ProgressbarClientAware, / Client to add. Returns ------- Self The hook object to allow fluent-style. \"\"\" if not client . hooks : client . set_hooks ( self ) else : client . update_hooks ( self ) return self","title":"add_to_client()"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks.on_error_hooks","text":"RETURNS DESCRIPTION collections . abc . Sequence [ ptypes . HookSignatureType ] Sequence of on-error hooks. Source code in multibar\\impl\\hooks.py 218 219 220 221 222 223 224 225 226 @property def on_error_hooks ( self ) -> list [ ptypes . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[ptypes.HookSignatureType] Sequence of on-error hooks. \"\"\" return self . _on_error_hooks","title":"on_error_hooks()"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks.post_execution_hooks","text":"RETURNS DESCRIPTION collections . abc . Sequence [ ptypes . HookSignatureType ] Sequence of post-execution hooks. Source code in multibar\\impl\\hooks.py 208 209 210 211 212 213 214 215 216 @property def post_execution_hooks ( self ) -> list [ ptypes . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[ptypes.HookSignatureType] Sequence of post-execution hooks. \"\"\" return self . _post_execution_hooks","title":"post_execution_hooks()"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks.pre_execution_hooks","text":"RETURNS DESCRIPTION collections . abc . Sequence [ ptypes . HookSignatureType ] Sequence of pre-execution hooks. Source code in multibar\\impl\\hooks.py 198 199 200 201 202 203 204 205 206 @property def pre_execution_hooks ( self ) -> list [ ptypes . HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[ptypes.HookSignatureType] Sequence of pre-execution hooks. \"\"\" return self . _pre_execution_hooks","title":"pre_execution_hooks()"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks.trigger_on_error","text":"Triggers all on-error callbacks. PARAMETER DESCRIPTION *args Arguments to trigger. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to trigger. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\impl\\hooks.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all on-error callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" if not self . _on_error_hooks : raise else : for hook in self . _on_error_hooks : hook ( * args , ** kwargs )","title":"trigger_on_error()"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks.trigger_post_execution","text":"Triggers all post-execution callbacks. PARAMETER DESCRIPTION *args Arguments to trigger. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to trigger. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\impl\\hooks.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all post-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" for hook in self . _post_execution_hooks : hook ( * args , ** kwargs )","title":"trigger_post_execution()"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks.trigger_pre_execution","text":"Triggers all pre-execution callbacks. PARAMETER DESCRIPTION *args Arguments to trigger. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to trigger. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION None Source code in multibar\\impl\\hooks.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all pre-execution callbacks. Parameters ---------- *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Returns ------- None \"\"\" for hook in self . _pre_execution_hooks : hook ( * args , ** kwargs )","title":"trigger_pre_execution()"},{"location":"impl/hooks/#multibar.impl.hooks.Hooks.update","text":"Updates self hooks from other hooks object. PARAMETER DESCRIPTION other Other hooks object to update. TYPE: HooksAware RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\impl\\hooks.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def update ( self , other : hooks . HooksAware , / ) -> Hooks : \"\"\"Updates self hooks from other hooks object. Parameters ---------- other : HooksAware, / Other hooks object to update. Returns ------- Self The hook object to allow fluent-style. \"\"\" self . _on_error_hooks . extend ( other . on_error_hooks ) self . _post_execution_hooks . extend ( other . post_execution_hooks ) self . _pre_execution_hooks . extend ( other . pre_execution_hooks ) return self","title":"update()"},{"location":"impl/math_operations/","text":"multibar.impl.calculation_service \u00a4 Implementations of Python-Multibar math operations. __all__ = ( 'ProgressbarCalculationService' ) module-attribute \u00a4 ProgressbarCalculationService \u00a4 Bases: calculation_service . AbstractCalculationService Implementation of calculation_service.AbstractCalculationService. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\calculation_service.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class ProgressbarCalculationService ( calculation_service . AbstractCalculationService ): \"\"\"Implementation of calculation_service.AbstractCalculationService. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar filled sector indexes. \"\"\" filled_range = range ( round ( self . progress_percents / ( 100 / self . _length ))) return iter ( filled_range ) def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar unfilled sector indexes. \"\"\" filled_range_len = len ( tuple ( self . calculate_filled_indexes ())) unfilled_range = range ( self . _length - filled_range_len ) return map ( lambda i : i + filled_range_len , unfilled_range ) @staticmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : \"\"\"Alternative staticmethod to get progress percentage. Parameters ----------- start : typing.Union[int, float] Start value (current progress) for progressbar math operations. end : typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" return ( start / end ) * 100 @property def progress_percents ( self ) -> float : \"\"\"Returns current progress percentage. Returns ------- float Float progress percentage. \"\"\" return self . get_progress_percentage ( self . _start_value , self . _end_value ) calculate_filled_indexes () \u00a4 Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. RETURNS DESCRIPTION collections . abc . Iterator [ int ] Iterator over progressbar filled sector indexes. Source code in multibar\\impl\\calculation_service.py 35 36 37 38 39 40 41 42 43 44 45 46 def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar filled sector indexes. \"\"\" filled_range = range ( round ( self . progress_percents / ( 100 / self . _length ))) return iter ( filled_range ) calculate_unfilled_indexes () \u00a4 Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. RETURNS DESCRIPTION collections . abc . Iterator [ int ] Iterator over progressbar unfilled sector indexes. Source code in multibar\\impl\\calculation_service.py 48 49 50 51 52 53 54 55 56 57 58 59 60 def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar unfilled sector indexes. \"\"\" filled_range_len = len ( tuple ( self . calculate_filled_indexes ())) unfilled_range = range ( self . _length - filled_range_len ) return map ( lambda i : i + filled_range_len , unfilled_range ) get_progress_percentage ( start , end ) staticmethod \u00a4 Alternative staticmethod to get progress percentage. PARAMETER DESCRIPTION start Start value (current progress) for progressbar math operations. TYPE: typing . Union [ int , float ] end End value (needed progress) for progressbar math operations. TYPE: typing . Union [ int , float ] Source code in multibar\\impl\\calculation_service.py 62 63 64 65 66 67 68 69 70 71 72 73 @staticmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : \"\"\"Alternative staticmethod to get progress percentage. Parameters ----------- start : typing.Union[int, float] Start value (current progress) for progressbar math operations. end : typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" return ( start / end ) * 100 progress_percents () property \u00a4 Returns current progress percentage. RETURNS DESCRIPTION float Float progress percentage. Source code in multibar\\impl\\calculation_service.py 75 76 77 78 79 80 81 82 83 84 @property def progress_percents ( self ) -> float : \"\"\"Returns current progress percentage. Returns ------- float Float progress percentage. \"\"\" return self . get_progress_percentage ( self . _start_value , self . _end_value )","title":"Math operations"},{"location":"impl/math_operations/#multibar.impl.calculation_service","text":"Implementations of Python-Multibar math operations.","title":"calculation_service"},{"location":"impl/math_operations/#multibar.impl.calculation_service.__all__","text":"","title":"__all__"},{"location":"impl/math_operations/#multibar.impl.calculation_service.ProgressbarCalculationService","text":"Bases: calculation_service . AbstractCalculationService Implementation of calculation_service.AbstractCalculationService. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\calculation_service.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class ProgressbarCalculationService ( calculation_service . AbstractCalculationService ): \"\"\"Implementation of calculation_service.AbstractCalculationService. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar filled sector indexes. \"\"\" filled_range = range ( round ( self . progress_percents / ( 100 / self . _length ))) return iter ( filled_range ) def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar unfilled sector indexes. \"\"\" filled_range_len = len ( tuple ( self . calculate_filled_indexes ())) unfilled_range = range ( self . _length - filled_range_len ) return map ( lambda i : i + filled_range_len , unfilled_range ) @staticmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : \"\"\"Alternative staticmethod to get progress percentage. Parameters ----------- start : typing.Union[int, float] Start value (current progress) for progressbar math operations. end : typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" return ( start / end ) * 100 @property def progress_percents ( self ) -> float : \"\"\"Returns current progress percentage. Returns ------- float Float progress percentage. \"\"\" return self . get_progress_percentage ( self . _start_value , self . _end_value )","title":"ProgressbarCalculationService"},{"location":"impl/math_operations/#multibar.impl.calculation_service.ProgressbarCalculationService.calculate_filled_indexes","text":"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. RETURNS DESCRIPTION collections . abc . Iterator [ int ] Iterator over progressbar filled sector indexes. Source code in multibar\\impl\\calculation_service.py 35 36 37 38 39 40 41 42 43 44 45 46 def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar filled sector indexes. \"\"\" filled_range = range ( round ( self . progress_percents / ( 100 / self . _length ))) return iter ( filled_range )","title":"calculate_filled_indexes()"},{"location":"impl/math_operations/#multibar.impl.calculation_service.ProgressbarCalculationService.calculate_unfilled_indexes","text":"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. RETURNS DESCRIPTION collections . abc . Iterator [ int ] Iterator over progressbar unfilled sector indexes. Source code in multibar\\impl\\calculation_service.py 48 49 50 51 52 53 54 55 56 57 58 59 60 def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar unfilled sector indexes. \"\"\" filled_range_len = len ( tuple ( self . calculate_filled_indexes ())) unfilled_range = range ( self . _length - filled_range_len ) return map ( lambda i : i + filled_range_len , unfilled_range )","title":"calculate_unfilled_indexes()"},{"location":"impl/math_operations/#multibar.impl.calculation_service.ProgressbarCalculationService.get_progress_percentage","text":"Alternative staticmethod to get progress percentage. PARAMETER DESCRIPTION start Start value (current progress) for progressbar math operations. TYPE: typing . Union [ int , float ] end End value (needed progress) for progressbar math operations. TYPE: typing . Union [ int , float ] Source code in multibar\\impl\\calculation_service.py 62 63 64 65 66 67 68 69 70 71 72 73 @staticmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : \"\"\"Alternative staticmethod to get progress percentage. Parameters ----------- start : typing.Union[int, float] Start value (current progress) for progressbar math operations. end : typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" return ( start / end ) * 100","title":"get_progress_percentage()"},{"location":"impl/math_operations/#multibar.impl.calculation_service.ProgressbarCalculationService.progress_percents","text":"Returns current progress percentage. RETURNS DESCRIPTION float Float progress percentage. Source code in multibar\\impl\\calculation_service.py 75 76 77 78 79 80 81 82 83 84 @property def progress_percents ( self ) -> float : \"\"\"Returns current progress percentage. Returns ------- float Float progress percentage. \"\"\" return self . get_progress_percentage ( self . _start_value , self . _end_value )","title":"progress_percents()"},{"location":"impl/progressbars/","text":"multibar.impl.progressbars \u00a4 Implementation of progressbar interfaces. SectorT = typing . TypeVar ( 'SectorT' , bound = abc_sectors . AbstractSector ) module-attribute \u00a4 __all__ = ( 'Progressbar' ) module-attribute \u00a4 Progressbar \u00a4 Bases: SupportsKind1 [ Any] , SectorT ] , abc_progressbars . ProgressbarAware [ SectorT ] Implementation of abc_progressbars.ProgressbarAware[SectorT]. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\progressbars.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 class Progressbar ( SupportsKind1 [ \"Progressbar[typing.Any]\" , SectorT ], abc_progressbars . ProgressbarAware [ SectorT ]): \"\"\"Implementation of abc_progressbars.ProgressbarAware[SectorT]. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" __slots__ = ( \"_storage\" ,) def __init__ ( self ) -> None : self . _storage : typing . MutableSequence [ SectorT ] = [] def __len__ ( self ) -> int : \"\"\" Returns ------- int Sectors count. \"\"\" return len ( self . _storage ) def __getitem__ ( self , item : typing . Any ) -> typing . Any : \"\"\"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice. Returns ------- typing.Any Any value depending on context and implementation. If item is instance of (int, slice), will return sequence of sectors or sector object. \"\"\" if not isinstance ( item , ( int , slice )): return NotImplemented return self . _storage [ item ] def __reversed__ ( self ) -> typing . Iterator [ SectorT ]: \"\"\"Returns reversed progressbar.\"\"\" self . _storage . reverse () return iter ( self . _storage ) def __repr__ ( self ) -> str : \"\"\"Returns string representation of progressbar.\"\"\" return \"\" . join ( s . name for s in self . _storage ) def map ( self : Kind1 [ _InstanceKind , SectorT ], callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: \"\"\"Applies callback for every sector in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progressbarwriter.write(value, value) ... >>> class ExtendedImpl(AbstractSector): # Your extended implementation >>> def __init__(self, sector_obj: AbstractSector) -> None: ... super().__init__(sector_obj.name, sector_obj.is_filled, sector_obj.position) ... self._origin = sector_obj ... >>> def extended_method(self) -> None: ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar.map(lambda s: ExtendedImpl(s)) >>> new_progressbar.sectors[0].extended_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Returns ------- Progressbar[_NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" return self . set_new_sectors ( callback ( s ) for s in self . _storage ) @classmethod def set_new_sectors ( cls , new_value : typing . Iterable [ _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: \"\"\"Sets new sectors in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progresswriter.write(value, value) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors(...) # Extended sectors with .extend_method() >>> new_progressbar = progressbar.set_new_sectors(sectors) # Sectors have .extend_method() >>> new_progressbar.sectors[0].extend_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Parameters ---------- new_value : collections.abc.Iterable[_NewValueType], / Iterable over new sector objects. For example of behavior see `info` block. Returns ------- Progressbar[_NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" # Alternative to cls[_NewValueType](), to avoid mypy \"is not indexable\" error. bar = typing . cast ( Progressbar [ _NewValueType ], cls ()) for new_sector in new_value : bar . add_sector ( new_sector ) return bar def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : \"\"\"Pass each sector to a given consumer. Parameters ---------- consumer : typing.Callable[[SectorT], typing.Any], / Function to apply for progressbar sectors. Returns ------- None \"\"\" for sector in self . _storage : consumer ( sector ) def add_sector ( self : _InstanceKind , sector : abc_sectors . AbstractSector , / ) -> _InstanceKind : \"\"\"Adds sector to progressbar. Parameters ---------- sector : SectorT, / Sector to add. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" self . _storage . append ( sector ) return self def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> Progressbar [ SectorT ]: \"\"\"Replaces sector display name. Parameters ---------- sector_pos : int, / To find sector by index to change. new_display_name : str, / New display name value. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" self . _storage [ sector_pos ] . change_name ( new_display_name ) return self @property def length ( self ) -> int : \"\"\" Returns ------- int Length of the progressbar. \"\"\" return len ( self . _storage ) @property def sectors ( self ) -> typing . MutableSequence [ SectorT ]: \"\"\" Returns ------- collections.abc.Sequence[SectorT] Sequence of sectors. \"\"\" return self . _storage __slots__ = ( '_storage' ) class-attribute \u00a4 __getitem__ ( item ) \u00a4 Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice. RETURNS DESCRIPTION typing . Any Any value depending on context and implementation. If item is instance of (int, slice), will return sequence of sectors or sector object. Source code in multibar\\impl\\progressbars.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __getitem__ ( self , item : typing . Any ) -> typing . Any : \"\"\"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice. Returns ------- typing.Any Any value depending on context and implementation. If item is instance of (int, slice), will return sequence of sectors or sector object. \"\"\" if not isinstance ( item , ( int , slice )): return NotImplemented return self . _storage [ item ] __init__ () \u00a4 Source code in multibar\\impl\\progressbars.py 43 44 def __init__ ( self ) -> None : self . _storage : typing . MutableSequence [ SectorT ] = [] __len__ () \u00a4 RETURNS DESCRIPTION int Sectors count. Source code in multibar\\impl\\progressbars.py 46 47 48 49 50 51 52 53 def __len__ ( self ) -> int : \"\"\" Returns ------- int Sectors count. \"\"\" return len ( self . _storage ) __repr__ () \u00a4 Returns string representation of progressbar. Source code in multibar\\impl\\progressbars.py 75 76 77 def __repr__ ( self ) -> str : \"\"\"Returns string representation of progressbar.\"\"\" return \"\" . join ( s . name for s in self . _storage ) __reversed__ () \u00a4 Returns reversed progressbar. Source code in multibar\\impl\\progressbars.py 70 71 72 73 def __reversed__ ( self ) -> typing . Iterator [ SectorT ]: \"\"\"Returns reversed progressbar.\"\"\" self . _storage . reverse () return iter ( self . _storage ) add_sector ( sector ) \u00a4 Adds sector to progressbar. PARAMETER DESCRIPTION sector Sector to add. TYPE: SectorT RETURNS DESCRIPTION Self The progressbar object to allow fluent-style. Source code in multibar\\impl\\progressbars.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def add_sector ( self : _InstanceKind , sector : abc_sectors . AbstractSector , / ) -> _InstanceKind : \"\"\"Adds sector to progressbar. Parameters ---------- sector : SectorT, / Sector to add. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" self . _storage . append ( sector ) return self for_each ( consumer ) \u00a4 Pass each sector to a given consumer. PARAMETER DESCRIPTION consumer Function to apply for progressbar sectors. TYPE: typing . Callable [[ SectorT ], typing . Any ] RETURNS DESCRIPTION None Source code in multibar\\impl\\progressbars.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : \"\"\"Pass each sector to a given consumer. Parameters ---------- consumer : typing.Callable[[SectorT], typing.Any], / Function to apply for progressbar sectors. Returns ------- None \"\"\" for sector in self . _storage : consumer ( sector ) length () property \u00a4 RETURNS DESCRIPTION int Length of the progressbar. Source code in multibar\\impl\\progressbars.py 232 233 234 235 236 237 238 239 240 @property def length ( self ) -> int : \"\"\" Returns ------- int Length of the progressbar. \"\"\" return len ( self . _storage ) map ( callback ) \u00a4 Applies callback for every sector in progressbar. Info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. Abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: Expand pseudocode example >>> progressbar = progressbarwriter . write ( value , value ) ... >>> class ExtendedImpl ( AbstractSector ): # Your extended implementation >>> def __init__ ( self , sector_obj : AbstractSector ) -> None : ... super () . __init__ ( sector_obj . name , sector_obj . is_filled , sector_obj . position ) ... self . _origin = sector_obj ... >>> def extended_method ( self ) -> None : ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar . map ( lambda s : ExtendedImpl ( s )) >>> new_progressbar . sectors [ 0 ] . extended_method () # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. RETURNS DESCRIPTION Progressbar [ _NewValueType ] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. Source code in multibar\\impl\\progressbars.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def map ( self : Kind1 [ _InstanceKind , SectorT ], callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: \"\"\"Applies callback for every sector in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progressbarwriter.write(value, value) ... >>> class ExtendedImpl(AbstractSector): # Your extended implementation >>> def __init__(self, sector_obj: AbstractSector) -> None: ... super().__init__(sector_obj.name, sector_obj.is_filled, sector_obj.position) ... self._origin = sector_obj ... >>> def extended_method(self) -> None: ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar.map(lambda s: ExtendedImpl(s)) >>> new_progressbar.sectors[0].extended_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Returns ------- Progressbar[_NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" return self . set_new_sectors ( callback ( s ) for s in self . _storage ) replace_display_name_for ( sector_pos , new_display_name ) \u00a4 Replaces sector display name. PARAMETER DESCRIPTION sector_pos To find sector by index to change. TYPE: int new_display_name New display name value. TYPE: str RETURNS DESCRIPTION Self The progressbar object to allow fluent-style. Source code in multibar\\impl\\progressbars.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> Progressbar [ SectorT ]: \"\"\"Replaces sector display name. Parameters ---------- sector_pos : int, / To find sector by index to change. new_display_name : str, / New display name value. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" self . _storage [ sector_pos ] . change_name ( new_display_name ) return self sectors () property \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ SectorT ] Sequence of sectors. Source code in multibar\\impl\\progressbars.py 242 243 244 245 246 247 248 249 250 @property def sectors ( self ) -> typing . MutableSequence [ SectorT ]: \"\"\" Returns ------- collections.abc.Sequence[SectorT] Sequence of sectors. \"\"\" return self . _storage set_new_sectors ( new_value ) classmethod \u00a4 Sets new sectors in progressbar. Info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. Abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: Expand pseudocode example >>> progressbar = progresswriter . write ( value , value ) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors ( ... ) # Extended sectors with .extend_method() >>> new_progressbar = progressbar . set_new_sectors ( sectors ) # Sectors have .extend_method() >>> new_progressbar . sectors [ 0 ] . extend_method () # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. PARAMETER DESCRIPTION new_value Iterable over new sector objects. For example of behavior see info block. TYPE: collections . abc . Iterable [ _NewValueType ] RETURNS DESCRIPTION Progressbar [ _NewValueType ] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. Source code in multibar\\impl\\progressbars.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @classmethod def set_new_sectors ( cls , new_value : typing . Iterable [ _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: \"\"\"Sets new sectors in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progresswriter.write(value, value) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors(...) # Extended sectors with .extend_method() >>> new_progressbar = progressbar.set_new_sectors(sectors) # Sectors have .extend_method() >>> new_progressbar.sectors[0].extend_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Parameters ---------- new_value : collections.abc.Iterable[_NewValueType], / Iterable over new sector objects. For example of behavior see `info` block. Returns ------- Progressbar[_NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" # Alternative to cls[_NewValueType](), to avoid mypy \"is not indexable\" error. bar = typing . cast ( Progressbar [ _NewValueType ], cls ()) for new_sector in new_value : bar . add_sector ( new_sector ) return bar","title":"Progressbars"},{"location":"impl/progressbars/#multibar.impl.progressbars","text":"Implementation of progressbar interfaces.","title":"progressbars"},{"location":"impl/progressbars/#multibar.impl.progressbars.SectorT","text":"","title":"SectorT"},{"location":"impl/progressbars/#multibar.impl.progressbars.__all__","text":"","title":"__all__"},{"location":"impl/progressbars/#multibar.impl.progressbars.Progressbar","text":"Bases: SupportsKind1 [ Any] , SectorT ] , abc_progressbars . ProgressbarAware [ SectorT ] Implementation of abc_progressbars.ProgressbarAware[SectorT]. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\progressbars.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 class Progressbar ( SupportsKind1 [ \"Progressbar[typing.Any]\" , SectorT ], abc_progressbars . ProgressbarAware [ SectorT ]): \"\"\"Implementation of abc_progressbars.ProgressbarAware[SectorT]. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" __slots__ = ( \"_storage\" ,) def __init__ ( self ) -> None : self . _storage : typing . MutableSequence [ SectorT ] = [] def __len__ ( self ) -> int : \"\"\" Returns ------- int Sectors count. \"\"\" return len ( self . _storage ) def __getitem__ ( self , item : typing . Any ) -> typing . Any : \"\"\"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice. Returns ------- typing.Any Any value depending on context and implementation. If item is instance of (int, slice), will return sequence of sectors or sector object. \"\"\" if not isinstance ( item , ( int , slice )): return NotImplemented return self . _storage [ item ] def __reversed__ ( self ) -> typing . Iterator [ SectorT ]: \"\"\"Returns reversed progressbar.\"\"\" self . _storage . reverse () return iter ( self . _storage ) def __repr__ ( self ) -> str : \"\"\"Returns string representation of progressbar.\"\"\" return \"\" . join ( s . name for s in self . _storage ) def map ( self : Kind1 [ _InstanceKind , SectorT ], callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: \"\"\"Applies callback for every sector in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progressbarwriter.write(value, value) ... >>> class ExtendedImpl(AbstractSector): # Your extended implementation >>> def __init__(self, sector_obj: AbstractSector) -> None: ... super().__init__(sector_obj.name, sector_obj.is_filled, sector_obj.position) ... self._origin = sector_obj ... >>> def extended_method(self) -> None: ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar.map(lambda s: ExtendedImpl(s)) >>> new_progressbar.sectors[0].extended_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Returns ------- Progressbar[_NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" return self . set_new_sectors ( callback ( s ) for s in self . _storage ) @classmethod def set_new_sectors ( cls , new_value : typing . Iterable [ _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: \"\"\"Sets new sectors in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progresswriter.write(value, value) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors(...) # Extended sectors with .extend_method() >>> new_progressbar = progressbar.set_new_sectors(sectors) # Sectors have .extend_method() >>> new_progressbar.sectors[0].extend_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Parameters ---------- new_value : collections.abc.Iterable[_NewValueType], / Iterable over new sector objects. For example of behavior see `info` block. Returns ------- Progressbar[_NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" # Alternative to cls[_NewValueType](), to avoid mypy \"is not indexable\" error. bar = typing . cast ( Progressbar [ _NewValueType ], cls ()) for new_sector in new_value : bar . add_sector ( new_sector ) return bar def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : \"\"\"Pass each sector to a given consumer. Parameters ---------- consumer : typing.Callable[[SectorT], typing.Any], / Function to apply for progressbar sectors. Returns ------- None \"\"\" for sector in self . _storage : consumer ( sector ) def add_sector ( self : _InstanceKind , sector : abc_sectors . AbstractSector , / ) -> _InstanceKind : \"\"\"Adds sector to progressbar. Parameters ---------- sector : SectorT, / Sector to add. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" self . _storage . append ( sector ) return self def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> Progressbar [ SectorT ]: \"\"\"Replaces sector display name. Parameters ---------- sector_pos : int, / To find sector by index to change. new_display_name : str, / New display name value. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" self . _storage [ sector_pos ] . change_name ( new_display_name ) return self @property def length ( self ) -> int : \"\"\" Returns ------- int Length of the progressbar. \"\"\" return len ( self . _storage ) @property def sectors ( self ) -> typing . MutableSequence [ SectorT ]: \"\"\" Returns ------- collections.abc.Sequence[SectorT] Sequence of sectors. \"\"\" return self . _storage","title":"Progressbar"},{"location":"impl/progressbars/#multibar.impl.progressbars.Progressbar.__slots__","text":"","title":"__slots__"},{"location":"impl/progressbars/#multibar.impl.progressbars.Progressbar.__getitem__","text":"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice. RETURNS DESCRIPTION typing . Any Any value depending on context and implementation. If item is instance of (int, slice), will return sequence of sectors or sector object. Source code in multibar\\impl\\progressbars.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __getitem__ ( self , item : typing . Any ) -> typing . Any : \"\"\"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice. Returns ------- typing.Any Any value depending on context and implementation. If item is instance of (int, slice), will return sequence of sectors or sector object. \"\"\" if not isinstance ( item , ( int , slice )): return NotImplemented return self . _storage [ item ]","title":"__getitem__()"},{"location":"impl/progressbars/#multibar.impl.progressbars.Progressbar.__init__","text":"Source code in multibar\\impl\\progressbars.py 43 44 def __init__ ( self ) -> None : self . _storage : typing . MutableSequence [ SectorT ] = []","title":"__init__()"},{"location":"impl/progressbars/#multibar.impl.progressbars.Progressbar.__len__","text":"RETURNS DESCRIPTION int Sectors count. Source code in multibar\\impl\\progressbars.py 46 47 48 49 50 51 52 53 def __len__ ( self ) -> int : \"\"\" Returns ------- int Sectors count. \"\"\" return len ( self . _storage )","title":"__len__()"},{"location":"impl/progressbars/#multibar.impl.progressbars.Progressbar.__repr__","text":"Returns string representation of progressbar. Source code in multibar\\impl\\progressbars.py 75 76 77 def __repr__ ( self ) -> str : \"\"\"Returns string representation of progressbar.\"\"\" return \"\" . join ( s . name for s in self . _storage )","title":"__repr__()"},{"location":"impl/progressbars/#multibar.impl.progressbars.Progressbar.__reversed__","text":"Returns reversed progressbar. Source code in multibar\\impl\\progressbars.py 70 71 72 73 def __reversed__ ( self ) -> typing . Iterator [ SectorT ]: \"\"\"Returns reversed progressbar.\"\"\" self . _storage . reverse () return iter ( self . _storage )","title":"__reversed__()"},{"location":"impl/progressbars/#multibar.impl.progressbars.Progressbar.add_sector","text":"Adds sector to progressbar. PARAMETER DESCRIPTION sector Sector to add. TYPE: SectorT RETURNS DESCRIPTION Self The progressbar object to allow fluent-style. Source code in multibar\\impl\\progressbars.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def add_sector ( self : _InstanceKind , sector : abc_sectors . AbstractSector , / ) -> _InstanceKind : \"\"\"Adds sector to progressbar. Parameters ---------- sector : SectorT, / Sector to add. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" self . _storage . append ( sector ) return self","title":"add_sector()"},{"location":"impl/progressbars/#multibar.impl.progressbars.Progressbar.for_each","text":"Pass each sector to a given consumer. PARAMETER DESCRIPTION consumer Function to apply for progressbar sectors. TYPE: typing . Callable [[ SectorT ], typing . Any ] RETURNS DESCRIPTION None Source code in multibar\\impl\\progressbars.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : \"\"\"Pass each sector to a given consumer. Parameters ---------- consumer : typing.Callable[[SectorT], typing.Any], / Function to apply for progressbar sectors. Returns ------- None \"\"\" for sector in self . _storage : consumer ( sector )","title":"for_each()"},{"location":"impl/progressbars/#multibar.impl.progressbars.Progressbar.length","text":"RETURNS DESCRIPTION int Length of the progressbar. Source code in multibar\\impl\\progressbars.py 232 233 234 235 236 237 238 239 240 @property def length ( self ) -> int : \"\"\" Returns ------- int Length of the progressbar. \"\"\" return len ( self . _storage )","title":"length()"},{"location":"impl/progressbars/#multibar.impl.progressbars.Progressbar.map","text":"Applies callback for every sector in progressbar. Info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. Abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: Expand pseudocode example >>> progressbar = progressbarwriter . write ( value , value ) ... >>> class ExtendedImpl ( AbstractSector ): # Your extended implementation >>> def __init__ ( self , sector_obj : AbstractSector ) -> None : ... super () . __init__ ( sector_obj . name , sector_obj . is_filled , sector_obj . position ) ... self . _origin = sector_obj ... >>> def extended_method ( self ) -> None : ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar . map ( lambda s : ExtendedImpl ( s )) >>> new_progressbar . sectors [ 0 ] . extended_method () # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. RETURNS DESCRIPTION Progressbar [ _NewValueType ] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. Source code in multibar\\impl\\progressbars.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def map ( self : Kind1 [ _InstanceKind , SectorT ], callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: \"\"\"Applies callback for every sector in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progressbarwriter.write(value, value) ... >>> class ExtendedImpl(AbstractSector): # Your extended implementation >>> def __init__(self, sector_obj: AbstractSector) -> None: ... super().__init__(sector_obj.name, sector_obj.is_filled, sector_obj.position) ... self._origin = sector_obj ... >>> def extended_method(self) -> None: ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar.map(lambda s: ExtendedImpl(s)) >>> new_progressbar.sectors[0].extended_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Returns ------- Progressbar[_NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" return self . set_new_sectors ( callback ( s ) for s in self . _storage )","title":"map()"},{"location":"impl/progressbars/#multibar.impl.progressbars.Progressbar.replace_display_name_for","text":"Replaces sector display name. PARAMETER DESCRIPTION sector_pos To find sector by index to change. TYPE: int new_display_name New display name value. TYPE: str RETURNS DESCRIPTION Self The progressbar object to allow fluent-style. Source code in multibar\\impl\\progressbars.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> Progressbar [ SectorT ]: \"\"\"Replaces sector display name. Parameters ---------- sector_pos : int, / To find sector by index to change. new_display_name : str, / New display name value. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" self . _storage [ sector_pos ] . change_name ( new_display_name ) return self","title":"replace_display_name_for()"},{"location":"impl/progressbars/#multibar.impl.progressbars.Progressbar.sectors","text":"RETURNS DESCRIPTION collections . abc . Sequence [ SectorT ] Sequence of sectors. Source code in multibar\\impl\\progressbars.py 242 243 244 245 246 247 248 249 250 @property def sectors ( self ) -> typing . MutableSequence [ SectorT ]: \"\"\" Returns ------- collections.abc.Sequence[SectorT] Sequence of sectors. \"\"\" return self . _storage","title":"sectors()"},{"location":"impl/progressbars/#multibar.impl.progressbars.Progressbar.set_new_sectors","text":"Sets new sectors in progressbar. Info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. Abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: Expand pseudocode example >>> progressbar = progresswriter . write ( value , value ) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors ( ... ) # Extended sectors with .extend_method() >>> new_progressbar = progressbar . set_new_sectors ( sectors ) # Sectors have .extend_method() >>> new_progressbar . sectors [ 0 ] . extend_method () # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. PARAMETER DESCRIPTION new_value Iterable over new sector objects. For example of behavior see info block. TYPE: collections . abc . Iterable [ _NewValueType ] RETURNS DESCRIPTION Progressbar [ _NewValueType ] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. Source code in multibar\\impl\\progressbars.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @classmethod def set_new_sectors ( cls , new_value : typing . Iterable [ _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: \"\"\"Sets new sectors in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: ??? example \"Expand pseudocode example\" ```py >>> progressbar = progresswriter.write(value, value) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors(...) # Extended sectors with .extend_method() >>> new_progressbar = progressbar.set_new_sectors(sectors) # Sectors have .extend_method() >>> new_progressbar.sectors[0].extend_method() # Mypy happy. ``` It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Parameters ---------- new_value : collections.abc.Iterable[_NewValueType], / Iterable over new sector objects. For example of behavior see `info` block. Returns ------- Progressbar[_NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" # Alternative to cls[_NewValueType](), to avoid mypy \"is not indexable\" error. bar = typing . cast ( Progressbar [ _NewValueType ], cls ()) for new_sector in new_value : bar . add_sector ( new_sector ) return bar","title":"set_new_sectors()"},{"location":"impl/sectors/","text":"multibar.impl.sectors \u00a4 Implementation of progressbar sector interfaces. __all__ = ( 'Sector' ) module-attribute \u00a4 Sector \u00a4 Bases: sectors . AbstractSector Implementation of sectors.AbstractSector. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\sectors.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class Sector ( sectors . AbstractSector ): \"\"\"Implementation of sectors.AbstractSector. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" def add_to_progressbar ( self : Sector , progressbar : progressbars . ProgressbarAware [ Sector ], / ) -> Sector : \"\"\"Adds sector self to progressbar. Parameters ---------- progressbar : progressbars.ProgressbarAware[SelfT], / Progressbar to add self for. Returns ------- Self The sector object to allow fluent-style. \"\"\" progressbar . add_sector ( self ) return self def change_name ( self , new_display_name : str , / ) -> Sector : \"\"\"Changes sector display name. Parameters ---------- new_display_name : str, / New display name to set. Returns ------- Self The sector object to allow fluent-style. \"\"\" self . _name = new_display_name return self @property def name ( self ) -> str : \"\"\" Returns ------- str Sector display name. \"\"\" return self . _name @property def is_filled ( self ) -> bool : \"\"\" Returns ------- str Sector filled value. \"\"\" return self . _is_filled @property def position ( self ) -> int : \"\"\" Returns ------- str Sector position in the progressbar. \"\"\" return self . _position add_to_progressbar ( progressbar ) \u00a4 Adds sector self to progressbar. PARAMETER DESCRIPTION progressbar Progressbar to add self for. TYPE: progressbars . ProgressbarAware [ SelfT ] RETURNS DESCRIPTION Self The sector object to allow fluent-style. Source code in multibar\\impl\\sectors.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def add_to_progressbar ( self : Sector , progressbar : progressbars . ProgressbarAware [ Sector ], / ) -> Sector : \"\"\"Adds sector self to progressbar. Parameters ---------- progressbar : progressbars.ProgressbarAware[SelfT], / Progressbar to add self for. Returns ------- Self The sector object to allow fluent-style. \"\"\" progressbar . add_sector ( self ) return self change_name ( new_display_name ) \u00a4 Changes sector display name. PARAMETER DESCRIPTION new_display_name New display name to set. TYPE: str RETURNS DESCRIPTION Self The sector object to allow fluent-style. Source code in multibar\\impl\\sectors.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def change_name ( self , new_display_name : str , / ) -> Sector : \"\"\"Changes sector display name. Parameters ---------- new_display_name : str, / New display name to set. Returns ------- Self The sector object to allow fluent-style. \"\"\" self . _name = new_display_name return self is_filled () property \u00a4 RETURNS DESCRIPTION str Sector filled value. Source code in multibar\\impl\\sectors.py 79 80 81 82 83 84 85 86 87 @property def is_filled ( self ) -> bool : \"\"\" Returns ------- str Sector filled value. \"\"\" return self . _is_filled name () property \u00a4 RETURNS DESCRIPTION str Sector display name. Source code in multibar\\impl\\sectors.py 69 70 71 72 73 74 75 76 77 @property def name ( self ) -> str : \"\"\" Returns ------- str Sector display name. \"\"\" return self . _name position () property \u00a4 RETURNS DESCRIPTION str Sector position in the progressbar. Source code in multibar\\impl\\sectors.py 89 90 91 92 93 94 95 96 97 @property def position ( self ) -> int : \"\"\" Returns ------- str Sector position in the progressbar. \"\"\" return self . _position","title":"Sectors"},{"location":"impl/sectors/#multibar.impl.sectors","text":"Implementation of progressbar sector interfaces.","title":"sectors"},{"location":"impl/sectors/#multibar.impl.sectors.__all__","text":"","title":"__all__"},{"location":"impl/sectors/#multibar.impl.sectors.Sector","text":"Bases: sectors . AbstractSector Implementation of sectors.AbstractSector. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\sectors.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class Sector ( sectors . AbstractSector ): \"\"\"Implementation of sectors.AbstractSector. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" def add_to_progressbar ( self : Sector , progressbar : progressbars . ProgressbarAware [ Sector ], / ) -> Sector : \"\"\"Adds sector self to progressbar. Parameters ---------- progressbar : progressbars.ProgressbarAware[SelfT], / Progressbar to add self for. Returns ------- Self The sector object to allow fluent-style. \"\"\" progressbar . add_sector ( self ) return self def change_name ( self , new_display_name : str , / ) -> Sector : \"\"\"Changes sector display name. Parameters ---------- new_display_name : str, / New display name to set. Returns ------- Self The sector object to allow fluent-style. \"\"\" self . _name = new_display_name return self @property def name ( self ) -> str : \"\"\" Returns ------- str Sector display name. \"\"\" return self . _name @property def is_filled ( self ) -> bool : \"\"\" Returns ------- str Sector filled value. \"\"\" return self . _is_filled @property def position ( self ) -> int : \"\"\" Returns ------- str Sector position in the progressbar. \"\"\" return self . _position","title":"Sector"},{"location":"impl/sectors/#multibar.impl.sectors.Sector.add_to_progressbar","text":"Adds sector self to progressbar. PARAMETER DESCRIPTION progressbar Progressbar to add self for. TYPE: progressbars . ProgressbarAware [ SelfT ] RETURNS DESCRIPTION Self The sector object to allow fluent-style. Source code in multibar\\impl\\sectors.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def add_to_progressbar ( self : Sector , progressbar : progressbars . ProgressbarAware [ Sector ], / ) -> Sector : \"\"\"Adds sector self to progressbar. Parameters ---------- progressbar : progressbars.ProgressbarAware[SelfT], / Progressbar to add self for. Returns ------- Self The sector object to allow fluent-style. \"\"\" progressbar . add_sector ( self ) return self","title":"add_to_progressbar()"},{"location":"impl/sectors/#multibar.impl.sectors.Sector.change_name","text":"Changes sector display name. PARAMETER DESCRIPTION new_display_name New display name to set. TYPE: str RETURNS DESCRIPTION Self The sector object to allow fluent-style. Source code in multibar\\impl\\sectors.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def change_name ( self , new_display_name : str , / ) -> Sector : \"\"\"Changes sector display name. Parameters ---------- new_display_name : str, / New display name to set. Returns ------- Self The sector object to allow fluent-style. \"\"\" self . _name = new_display_name return self","title":"change_name()"},{"location":"impl/sectors/#multibar.impl.sectors.Sector.is_filled","text":"RETURNS DESCRIPTION str Sector filled value. Source code in multibar\\impl\\sectors.py 79 80 81 82 83 84 85 86 87 @property def is_filled ( self ) -> bool : \"\"\" Returns ------- str Sector filled value. \"\"\" return self . _is_filled","title":"is_filled()"},{"location":"impl/sectors/#multibar.impl.sectors.Sector.name","text":"RETURNS DESCRIPTION str Sector display name. Source code in multibar\\impl\\sectors.py 69 70 71 72 73 74 75 76 77 @property def name ( self ) -> str : \"\"\" Returns ------- str Sector display name. \"\"\" return self . _name","title":"name()"},{"location":"impl/sectors/#multibar.impl.sectors.Sector.position","text":"RETURNS DESCRIPTION str Sector position in the progressbar. Source code in multibar\\impl\\sectors.py 89 90 91 92 93 94 95 96 97 @property def position ( self ) -> int : \"\"\" Returns ------- str Sector position in the progressbar. \"\"\" return self . _position","title":"position()"},{"location":"impl/signatures/","text":"multibar.impl.signatures \u00a4 Python-Multibar signature implementations. __all__ = ( 'SimpleSignature' , 'SignatureSegment' , 'SquareEmojiSignature' ) module-attribute \u00a4 SignatureSegment dataclass \u00a4 Dataclass that stores segment data. Source code in multibar\\impl\\signatures.py 28 29 30 31 32 33 34 35 36 @dataclasses . dataclass class SignatureSegment : \"\"\"Dataclass that stores segment data.\"\"\" on_filled : str \"\"\"On filled state.\"\"\" on_unfilled : str \"\"\"On unfilled state.\"\"\" on_filled : str class-attribute \u00a4 On filled state. on_unfilled : str class-attribute \u00a4 On unfilled state. SimpleSignature dataclass \u00a4 Dataclass that stores simple signature data. Source code in multibar\\impl\\signatures.py 39 40 41 42 43 44 45 46 47 48 49 50 @dataclasses . dataclass class SimpleSignature : \"\"\"Dataclass that stores simple signature data.\"\"\" start : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \"<\" , on_unfilled = \"-\" )) \"\"\"Progressbar start char.\"\"\" end : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \">\" , on_unfilled = \"-\" )) \"\"\"Progressbar end char.\"\"\" middle : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \"+\" , on_unfilled = \"-\" )) \"\"\"Progressbar middle char (between start and and).\"\"\" end : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = '>' , on_unfilled = '-' )) class-attribute \u00a4 Progressbar end char. middle : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = '+' , on_unfilled = '-' )) class-attribute \u00a4 Progressbar middle char (between start and and). start : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = '<' , on_unfilled = '-' )) class-attribute \u00a4 Progressbar start char. SquareEmojiSignature dataclass \u00a4 Dataclass that stores square emoji signature data. Source code in multibar\\impl\\signatures.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @dataclasses . dataclass class SquareEmojiSignature : \"\"\"Dataclass that stores square emoji signature data.\"\"\" start : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \":small_orange_diamond:\" , on_unfilled = \":black_large_square:\" ) ) \"\"\"Progressbar start char.\"\"\" end : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \":small_orange_diamond:\" , on_unfilled = \":black_large_square:\" ) ) \"\"\"Progressbar end char.\"\"\" \"\"\"\"\"\" middle : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \":orange_square:\" , on_unfilled = \":black_large_square:\" ) ) \"\"\"Progressbar middle char (between start and and).\"\"\" end : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = ':small_orange_diamond:' , on_unfilled = ':black_large_square:' )) class-attribute \u00a4 Progressbar end char. middle : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = ':orange_square:' , on_unfilled = ':black_large_square:' )) class-attribute \u00a4 Progressbar middle char (between start and and). start : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = ':small_orange_diamond:' , on_unfilled = ':black_large_square:' )) class-attribute \u00a4 Progressbar start char.","title":"Signatures"},{"location":"impl/signatures/#multibar.impl.signatures","text":"Python-Multibar signature implementations.","title":"signatures"},{"location":"impl/signatures/#multibar.impl.signatures.__all__","text":"","title":"__all__"},{"location":"impl/signatures/#multibar.impl.signatures.SignatureSegment","text":"Dataclass that stores segment data. Source code in multibar\\impl\\signatures.py 28 29 30 31 32 33 34 35 36 @dataclasses . dataclass class SignatureSegment : \"\"\"Dataclass that stores segment data.\"\"\" on_filled : str \"\"\"On filled state.\"\"\" on_unfilled : str \"\"\"On unfilled state.\"\"\"","title":"SignatureSegment"},{"location":"impl/signatures/#multibar.impl.signatures.SignatureSegment.on_filled","text":"On filled state.","title":"on_filled"},{"location":"impl/signatures/#multibar.impl.signatures.SignatureSegment.on_unfilled","text":"On unfilled state.","title":"on_unfilled"},{"location":"impl/signatures/#multibar.impl.signatures.SimpleSignature","text":"Dataclass that stores simple signature data. Source code in multibar\\impl\\signatures.py 39 40 41 42 43 44 45 46 47 48 49 50 @dataclasses . dataclass class SimpleSignature : \"\"\"Dataclass that stores simple signature data.\"\"\" start : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \"<\" , on_unfilled = \"-\" )) \"\"\"Progressbar start char.\"\"\" end : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \">\" , on_unfilled = \"-\" )) \"\"\"Progressbar end char.\"\"\" middle : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \"+\" , on_unfilled = \"-\" )) \"\"\"Progressbar middle char (between start and and).\"\"\"","title":"SimpleSignature"},{"location":"impl/signatures/#multibar.impl.signatures.SimpleSignature.end","text":"Progressbar end char.","title":"end"},{"location":"impl/signatures/#multibar.impl.signatures.SimpleSignature.middle","text":"Progressbar middle char (between start and and).","title":"middle"},{"location":"impl/signatures/#multibar.impl.signatures.SimpleSignature.start","text":"Progressbar start char.","title":"start"},{"location":"impl/signatures/#multibar.impl.signatures.SquareEmojiSignature","text":"Dataclass that stores square emoji signature data. Source code in multibar\\impl\\signatures.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @dataclasses . dataclass class SquareEmojiSignature : \"\"\"Dataclass that stores square emoji signature data.\"\"\" start : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \":small_orange_diamond:\" , on_unfilled = \":black_large_square:\" ) ) \"\"\"Progressbar start char.\"\"\" end : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \":small_orange_diamond:\" , on_unfilled = \":black_large_square:\" ) ) \"\"\"Progressbar end char.\"\"\" \"\"\"\"\"\" middle : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \":orange_square:\" , on_unfilled = \":black_large_square:\" ) ) \"\"\"Progressbar middle char (between start and and).\"\"\"","title":"SquareEmojiSignature"},{"location":"impl/signatures/#multibar.impl.signatures.SquareEmojiSignature.end","text":"Progressbar end char.","title":"end"},{"location":"impl/signatures/#multibar.impl.signatures.SquareEmojiSignature.middle","text":"Progressbar middle char (between start and and).","title":"middle"},{"location":"impl/signatures/#multibar.impl.signatures.SquareEmojiSignature.start","text":"Progressbar start char.","title":"start"},{"location":"impl/writers/","text":"multibar.impl.writers \u00a4 Implementation of progressbar writer interfaces. __all__ = ( 'ProgressbarWriter' ) module-attribute \u00a4 ProgressbarWriter \u00a4 Bases: abc_writers . ProgressbarWriterAware Implementation of abc_writers.ProgressbarWriterAware. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\writers.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 class ProgressbarWriter ( abc_writers . ProgressbarWriterAware ): \"\"\"Implementation of abc_writers.ProgressbarWriterAware. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" __slots__ = ( \"_signature\" , \"_sector_cls\" , \"_progressbar_cls\" , \"_calculation_service\" ) def __init__ ( self , * , sector_cls : typing . Optional [ typing . Type [ abc_sectors . AbstractSector ]] = None , progressbar_cls : typing . Optional [ typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]] ] = None , signature : typing . Optional [ abc_signatures . ProgressbarSignatureProtocol ] = None , calculation_service : typing . Optional [ typing . Type [ abc_math_operations . AbstractCalculationService ]] = None , ) -> None : \"\"\" Parameters ---------- sector_cls: typing.Optional[typing.Type[abc_sectors.AbstractSector]] = None Progressbar sector cls for writer. progressbar_cls: typing.Optional[typing.Type[ProgressbarT_co]] = None Progressbar cls for writer. signature: typing.Optional[abc_signatures.ProgressbarSignatureProtocol] = None Progressbar signature for writer. calculation_service: typing.Optional[typing.Type[abc_math_operations.AbstractCalculationService]] = None Math operations for writer. \"\"\" self . _signature = utils . none_or ( signatures . SimpleSignature (), signature ) self . _sector_cls = utils . none_or ( sectors . Sector , sector_cls ) self . _progressbar_cls = utils . none_or ( progressbars . Progressbar [ abc_sectors . AbstractSector ], progressbar_cls ) self . _calculation_service = utils . none_or ( math_operations . ProgressbarCalculationService , calculation_service ) @classmethod def from_signature ( cls , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : \"\"\"Alternative constructor from signature. Parameters ---------- signature : abc_signatures.ProgressbarSignatureProtocol, / Signature to init. Returns ------- ProgressbarWriterAware[sectors.AbstractSector] Instance of progressbar writer. \"\"\" return cls ( sector_cls = None , progressbar_cls = None , signature = signature , calculation_service = None , ) @typing . final def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: \"\"\"Writes progress without any hooks or checks. Parameters ---------- start_value : int, / Start value (current progress). end_value : int, / End value (needed progress). length : int, * Length of progressbar. Returns ------- abc_progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar object. \"\"\" sig = self . _signature sector_cls = self . _sector_cls progressbar = self . _progressbar_cls () calculation_service = self . _calculation_service ( start_value , end_value , length ) for sector_index in calculation_service . calculate_filled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_filled , True , sector_index )) for sector_index in calculation_service . calculate_unfilled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_unfilled , False , sector_index )) return progressbar def bind_signature ( self , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : \"\"\"Sets new progressbar signature. Parameters ---------- signature : abc_signatures.ProgressbarSignatureProtocol, / New signature to set. Returns ------- Self Progressbar writer object to allow fluent-style. \"\"\" self . _signature = signature return self @property def signature ( self ) -> abc_signatures . ProgressbarSignatureProtocol : \"\"\" Returns ------- abc_signatures.ProgressbarSignatureProtocol Progressbar signature. \"\"\" return self . _signature @property def sector_cls ( self ) -> typing . Type [ abc_sectors . AbstractSector ]: \"\"\" Returns ------- typing.Type[abc_sectors.AbstractSector] Progressbar sector cls. \"\"\" return self . _sector_cls @property def progressbar_cls ( self ) -> typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]]: \"\"\" Returns ------- typing.Type[progressbars.ProgressbarAware[abc_progressbars.AbstractSector]] Progressbar cls. \"\"\" return self . _progressbar_cls @property def calculation_cls ( self ) -> typing . Type [ abc_math_operations . AbstractCalculationService ]: \"\"\" Returns ------- typing.Type[abc_math_operations.AbstractCalculationService] Calculation cls. \"\"\" return self . _calculation_service __slots__ = ( '_signature' , '_sector_cls' , '_progressbar_cls' , '_calculation_service' ) class-attribute \u00a4 __init__ ( * , sector_cls = None , progressbar_cls = None , signature = None , calculation_service = None ) \u00a4 PARAMETER DESCRIPTION sector_cls Progressbar sector cls for writer. TYPE: typing . Optional [ typing . Type [ abc_sectors . AbstractSector ]] DEFAULT: None progressbar_cls Progressbar cls for writer. TYPE: typing . Optional [ typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]]] DEFAULT: None signature Progressbar signature for writer. TYPE: typing . Optional [ abc_signatures . ProgressbarSignatureProtocol ] DEFAULT: None calculation_service Math operations for writer. TYPE: typing . Optional [ typing . Type [ abc_math_operations . AbstractCalculationService ]] DEFAULT: None Source code in multibar\\impl\\writers.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def __init__ ( self , * , sector_cls : typing . Optional [ typing . Type [ abc_sectors . AbstractSector ]] = None , progressbar_cls : typing . Optional [ typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]] ] = None , signature : typing . Optional [ abc_signatures . ProgressbarSignatureProtocol ] = None , calculation_service : typing . Optional [ typing . Type [ abc_math_operations . AbstractCalculationService ]] = None , ) -> None : \"\"\" Parameters ---------- sector_cls: typing.Optional[typing.Type[abc_sectors.AbstractSector]] = None Progressbar sector cls for writer. progressbar_cls: typing.Optional[typing.Type[ProgressbarT_co]] = None Progressbar cls for writer. signature: typing.Optional[abc_signatures.ProgressbarSignatureProtocol] = None Progressbar signature for writer. calculation_service: typing.Optional[typing.Type[abc_math_operations.AbstractCalculationService]] = None Math operations for writer. \"\"\" self . _signature = utils . none_or ( signatures . SimpleSignature (), signature ) self . _sector_cls = utils . none_or ( sectors . Sector , sector_cls ) self . _progressbar_cls = utils . none_or ( progressbars . Progressbar [ abc_sectors . AbstractSector ], progressbar_cls ) self . _calculation_service = utils . none_or ( math_operations . ProgressbarCalculationService , calculation_service ) bind_signature ( signature ) \u00a4 Sets new progressbar signature. PARAMETER DESCRIPTION signature New signature to set. TYPE: abc_signatures . ProgressbarSignatureProtocol RETURNS DESCRIPTION Self Progressbar writer object to allow fluent-style. Source code in multibar\\impl\\writers.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def bind_signature ( self , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : \"\"\"Sets new progressbar signature. Parameters ---------- signature : abc_signatures.ProgressbarSignatureProtocol, / New signature to set. Returns ------- Self Progressbar writer object to allow fluent-style. \"\"\" self . _signature = signature return self calculation_cls () property \u00a4 RETURNS DESCRIPTION typing . Type [ abc_math_operations . AbstractCalculationService ] Calculation cls. Source code in multibar\\impl\\writers.py 186 187 188 189 190 191 192 193 194 @property def calculation_cls ( self ) -> typing . Type [ abc_math_operations . AbstractCalculationService ]: \"\"\" Returns ------- typing.Type[abc_math_operations.AbstractCalculationService] Calculation cls. \"\"\" return self . _calculation_service from_signature ( signature ) classmethod \u00a4 Alternative constructor from signature. PARAMETER DESCRIPTION signature Signature to init. TYPE: abc_signatures . ProgressbarSignatureProtocol RETURNS DESCRIPTION ProgressbarWriterAware [ sectors . AbstractSector ] Instance of progressbar writer. Source code in multibar\\impl\\writers.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @classmethod def from_signature ( cls , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : \"\"\"Alternative constructor from signature. Parameters ---------- signature : abc_signatures.ProgressbarSignatureProtocol, / Signature to init. Returns ------- ProgressbarWriterAware[sectors.AbstractSector] Instance of progressbar writer. \"\"\" return cls ( sector_cls = None , progressbar_cls = None , signature = signature , calculation_service = None , ) progressbar_cls () property \u00a4 RETURNS DESCRIPTION typing . Type [ progressbars . ProgressbarAware [ abc_progressbars . AbstractSector ]] Progressbar cls. Source code in multibar\\impl\\writers.py 176 177 178 179 180 181 182 183 184 @property def progressbar_cls ( self ) -> typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]]: \"\"\" Returns ------- typing.Type[progressbars.ProgressbarAware[abc_progressbars.AbstractSector]] Progressbar cls. \"\"\" return self . _progressbar_cls sector_cls () property \u00a4 RETURNS DESCRIPTION typing . Type [ abc_sectors . AbstractSector ] Progressbar sector cls. Source code in multibar\\impl\\writers.py 166 167 168 169 170 171 172 173 174 @property def sector_cls ( self ) -> typing . Type [ abc_sectors . AbstractSector ]: \"\"\" Returns ------- typing.Type[abc_sectors.AbstractSector] Progressbar sector cls. \"\"\" return self . _sector_cls signature () property \u00a4 RETURNS DESCRIPTION abc_signatures . ProgressbarSignatureProtocol Progressbar signature. Source code in multibar\\impl\\writers.py 156 157 158 159 160 161 162 163 164 @property def signature ( self ) -> abc_signatures . ProgressbarSignatureProtocol : \"\"\" Returns ------- abc_signatures.ProgressbarSignatureProtocol Progressbar signature. \"\"\" return self . _signature write ( start_value , end_value , / , * , length = 20 ) \u00a4 Writes progress without any hooks or checks. PARAMETER DESCRIPTION start_value Start value (current progress). TYPE: int end_value End value (needed progress). TYPE: int length Length of progressbar. TYPE: int DEFAULT: 20 RETURNS DESCRIPTION abc_progressbars . ProgressbarAware [ sectors . AbstractSector ] Progressbar object. Source code in multibar\\impl\\writers.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @typing . final def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: \"\"\"Writes progress without any hooks or checks. Parameters ---------- start_value : int, / Start value (current progress). end_value : int, / End value (needed progress). length : int, * Length of progressbar. Returns ------- abc_progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar object. \"\"\" sig = self . _signature sector_cls = self . _sector_cls progressbar = self . _progressbar_cls () calculation_service = self . _calculation_service ( start_value , end_value , length ) for sector_index in calculation_service . calculate_filled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_filled , True , sector_index )) for sector_index in calculation_service . calculate_unfilled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_unfilled , False , sector_index )) return progressbar","title":"Writers"},{"location":"impl/writers/#multibar.impl.writers","text":"Implementation of progressbar writer interfaces.","title":"writers"},{"location":"impl/writers/#multibar.impl.writers.__all__","text":"","title":"__all__"},{"location":"impl/writers/#multibar.impl.writers.ProgressbarWriter","text":"Bases: abc_writers . ProgressbarWriterAware Implementation of abc_writers.ProgressbarWriterAware. Note Documentation duplicated for mkdocs auto-reference plugin. Source code in multibar\\impl\\writers.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 class ProgressbarWriter ( abc_writers . ProgressbarWriterAware ): \"\"\"Implementation of abc_writers.ProgressbarWriterAware. !!! note Documentation duplicated for mkdocs auto-reference plugin. \"\"\" __slots__ = ( \"_signature\" , \"_sector_cls\" , \"_progressbar_cls\" , \"_calculation_service\" ) def __init__ ( self , * , sector_cls : typing . Optional [ typing . Type [ abc_sectors . AbstractSector ]] = None , progressbar_cls : typing . Optional [ typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]] ] = None , signature : typing . Optional [ abc_signatures . ProgressbarSignatureProtocol ] = None , calculation_service : typing . Optional [ typing . Type [ abc_math_operations . AbstractCalculationService ]] = None , ) -> None : \"\"\" Parameters ---------- sector_cls: typing.Optional[typing.Type[abc_sectors.AbstractSector]] = None Progressbar sector cls for writer. progressbar_cls: typing.Optional[typing.Type[ProgressbarT_co]] = None Progressbar cls for writer. signature: typing.Optional[abc_signatures.ProgressbarSignatureProtocol] = None Progressbar signature for writer. calculation_service: typing.Optional[typing.Type[abc_math_operations.AbstractCalculationService]] = None Math operations for writer. \"\"\" self . _signature = utils . none_or ( signatures . SimpleSignature (), signature ) self . _sector_cls = utils . none_or ( sectors . Sector , sector_cls ) self . _progressbar_cls = utils . none_or ( progressbars . Progressbar [ abc_sectors . AbstractSector ], progressbar_cls ) self . _calculation_service = utils . none_or ( math_operations . ProgressbarCalculationService , calculation_service ) @classmethod def from_signature ( cls , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : \"\"\"Alternative constructor from signature. Parameters ---------- signature : abc_signatures.ProgressbarSignatureProtocol, / Signature to init. Returns ------- ProgressbarWriterAware[sectors.AbstractSector] Instance of progressbar writer. \"\"\" return cls ( sector_cls = None , progressbar_cls = None , signature = signature , calculation_service = None , ) @typing . final def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: \"\"\"Writes progress without any hooks or checks. Parameters ---------- start_value : int, / Start value (current progress). end_value : int, / End value (needed progress). length : int, * Length of progressbar. Returns ------- abc_progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar object. \"\"\" sig = self . _signature sector_cls = self . _sector_cls progressbar = self . _progressbar_cls () calculation_service = self . _calculation_service ( start_value , end_value , length ) for sector_index in calculation_service . calculate_filled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_filled , True , sector_index )) for sector_index in calculation_service . calculate_unfilled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_unfilled , False , sector_index )) return progressbar def bind_signature ( self , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : \"\"\"Sets new progressbar signature. Parameters ---------- signature : abc_signatures.ProgressbarSignatureProtocol, / New signature to set. Returns ------- Self Progressbar writer object to allow fluent-style. \"\"\" self . _signature = signature return self @property def signature ( self ) -> abc_signatures . ProgressbarSignatureProtocol : \"\"\" Returns ------- abc_signatures.ProgressbarSignatureProtocol Progressbar signature. \"\"\" return self . _signature @property def sector_cls ( self ) -> typing . Type [ abc_sectors . AbstractSector ]: \"\"\" Returns ------- typing.Type[abc_sectors.AbstractSector] Progressbar sector cls. \"\"\" return self . _sector_cls @property def progressbar_cls ( self ) -> typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]]: \"\"\" Returns ------- typing.Type[progressbars.ProgressbarAware[abc_progressbars.AbstractSector]] Progressbar cls. \"\"\" return self . _progressbar_cls @property def calculation_cls ( self ) -> typing . Type [ abc_math_operations . AbstractCalculationService ]: \"\"\" Returns ------- typing.Type[abc_math_operations.AbstractCalculationService] Calculation cls. \"\"\" return self . _calculation_service","title":"ProgressbarWriter"},{"location":"impl/writers/#multibar.impl.writers.ProgressbarWriter.__slots__","text":"","title":"__slots__"},{"location":"impl/writers/#multibar.impl.writers.ProgressbarWriter.__init__","text":"PARAMETER DESCRIPTION sector_cls Progressbar sector cls for writer. TYPE: typing . Optional [ typing . Type [ abc_sectors . AbstractSector ]] DEFAULT: None progressbar_cls Progressbar cls for writer. TYPE: typing . Optional [ typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]]] DEFAULT: None signature Progressbar signature for writer. TYPE: typing . Optional [ abc_signatures . ProgressbarSignatureProtocol ] DEFAULT: None calculation_service Math operations for writer. TYPE: typing . Optional [ typing . Type [ abc_math_operations . AbstractCalculationService ]] DEFAULT: None Source code in multibar\\impl\\writers.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def __init__ ( self , * , sector_cls : typing . Optional [ typing . Type [ abc_sectors . AbstractSector ]] = None , progressbar_cls : typing . Optional [ typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]] ] = None , signature : typing . Optional [ abc_signatures . ProgressbarSignatureProtocol ] = None , calculation_service : typing . Optional [ typing . Type [ abc_math_operations . AbstractCalculationService ]] = None , ) -> None : \"\"\" Parameters ---------- sector_cls: typing.Optional[typing.Type[abc_sectors.AbstractSector]] = None Progressbar sector cls for writer. progressbar_cls: typing.Optional[typing.Type[ProgressbarT_co]] = None Progressbar cls for writer. signature: typing.Optional[abc_signatures.ProgressbarSignatureProtocol] = None Progressbar signature for writer. calculation_service: typing.Optional[typing.Type[abc_math_operations.AbstractCalculationService]] = None Math operations for writer. \"\"\" self . _signature = utils . none_or ( signatures . SimpleSignature (), signature ) self . _sector_cls = utils . none_or ( sectors . Sector , sector_cls ) self . _progressbar_cls = utils . none_or ( progressbars . Progressbar [ abc_sectors . AbstractSector ], progressbar_cls ) self . _calculation_service = utils . none_or ( math_operations . ProgressbarCalculationService , calculation_service )","title":"__init__()"},{"location":"impl/writers/#multibar.impl.writers.ProgressbarWriter.bind_signature","text":"Sets new progressbar signature. PARAMETER DESCRIPTION signature New signature to set. TYPE: abc_signatures . ProgressbarSignatureProtocol RETURNS DESCRIPTION Self Progressbar writer object to allow fluent-style. Source code in multibar\\impl\\writers.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def bind_signature ( self , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : \"\"\"Sets new progressbar signature. Parameters ---------- signature : abc_signatures.ProgressbarSignatureProtocol, / New signature to set. Returns ------- Self Progressbar writer object to allow fluent-style. \"\"\" self . _signature = signature return self","title":"bind_signature()"},{"location":"impl/writers/#multibar.impl.writers.ProgressbarWriter.calculation_cls","text":"RETURNS DESCRIPTION typing . Type [ abc_math_operations . AbstractCalculationService ] Calculation cls. Source code in multibar\\impl\\writers.py 186 187 188 189 190 191 192 193 194 @property def calculation_cls ( self ) -> typing . Type [ abc_math_operations . AbstractCalculationService ]: \"\"\" Returns ------- typing.Type[abc_math_operations.AbstractCalculationService] Calculation cls. \"\"\" return self . _calculation_service","title":"calculation_cls()"},{"location":"impl/writers/#multibar.impl.writers.ProgressbarWriter.from_signature","text":"Alternative constructor from signature. PARAMETER DESCRIPTION signature Signature to init. TYPE: abc_signatures . ProgressbarSignatureProtocol RETURNS DESCRIPTION ProgressbarWriterAware [ sectors . AbstractSector ] Instance of progressbar writer. Source code in multibar\\impl\\writers.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @classmethod def from_signature ( cls , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : \"\"\"Alternative constructor from signature. Parameters ---------- signature : abc_signatures.ProgressbarSignatureProtocol, / Signature to init. Returns ------- ProgressbarWriterAware[sectors.AbstractSector] Instance of progressbar writer. \"\"\" return cls ( sector_cls = None , progressbar_cls = None , signature = signature , calculation_service = None , )","title":"from_signature()"},{"location":"impl/writers/#multibar.impl.writers.ProgressbarWriter.progressbar_cls","text":"RETURNS DESCRIPTION typing . Type [ progressbars . ProgressbarAware [ abc_progressbars . AbstractSector ]] Progressbar cls. Source code in multibar\\impl\\writers.py 176 177 178 179 180 181 182 183 184 @property def progressbar_cls ( self ) -> typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]]: \"\"\" Returns ------- typing.Type[progressbars.ProgressbarAware[abc_progressbars.AbstractSector]] Progressbar cls. \"\"\" return self . _progressbar_cls","title":"progressbar_cls()"},{"location":"impl/writers/#multibar.impl.writers.ProgressbarWriter.sector_cls","text":"RETURNS DESCRIPTION typing . Type [ abc_sectors . AbstractSector ] Progressbar sector cls. Source code in multibar\\impl\\writers.py 166 167 168 169 170 171 172 173 174 @property def sector_cls ( self ) -> typing . Type [ abc_sectors . AbstractSector ]: \"\"\" Returns ------- typing.Type[abc_sectors.AbstractSector] Progressbar sector cls. \"\"\" return self . _sector_cls","title":"sector_cls()"},{"location":"impl/writers/#multibar.impl.writers.ProgressbarWriter.signature","text":"RETURNS DESCRIPTION abc_signatures . ProgressbarSignatureProtocol Progressbar signature. Source code in multibar\\impl\\writers.py 156 157 158 159 160 161 162 163 164 @property def signature ( self ) -> abc_signatures . ProgressbarSignatureProtocol : \"\"\" Returns ------- abc_signatures.ProgressbarSignatureProtocol Progressbar signature. \"\"\" return self . _signature","title":"signature()"},{"location":"impl/writers/#multibar.impl.writers.ProgressbarWriter.write","text":"Writes progress without any hooks or checks. PARAMETER DESCRIPTION start_value Start value (current progress). TYPE: int end_value End value (needed progress). TYPE: int length Length of progressbar. TYPE: int DEFAULT: 20 RETURNS DESCRIPTION abc_progressbars . ProgressbarAware [ sectors . AbstractSector ] Progressbar object. Source code in multibar\\impl\\writers.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @typing . final def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: \"\"\"Writes progress without any hooks or checks. Parameters ---------- start_value : int, / Start value (current progress). end_value : int, / End value (needed progress). length : int, * Length of progressbar. Returns ------- abc_progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar object. \"\"\" sig = self . _signature sector_cls = self . _sector_cls progressbar = self . _progressbar_cls () calculation_service = self . _calculation_service ( start_value , end_value , length ) for sector_index in calculation_service . calculate_filled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_filled , True , sector_index )) for sector_index in calculation_service . calculate_unfilled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_unfilled , False , sector_index )) return progressbar","title":"write()"}]}