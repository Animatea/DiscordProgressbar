{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Library for static progressbars Installation Install with PyPi pip3 install python-multibar Install with GitHub pip3 install -U git+https://github.com/Animatea/python-multibar.git#master What python-multibar do? Info Flexible generating static bars. Generating static bars in CLI. The ability to customize.","title":"Home"},{"location":"#installation","text":"Install with PyPi pip3 install python-multibar Install with GitHub pip3 install -U git+https://github.com/Animatea/python-multibar.git#master","title":"Installation"},{"location":"#what-python-multibar-do","text":"Info Flexible generating static bars. Generating static bars in CLI. The ability to customize.","title":"What python-multibar do?"},{"location":"abc/","text":"class AbstractSectorMixin ( name : str , position : int , empty : bool ) Expand source code class AbstractSectorMixin ( Comparable , Representable , abc . ABC ): __slots__ = ( \"name\" , \"position\" , \"empty\" ) def __init__ ( self , name : str , position : int , empty : bool ) -> None : self . name = name self . position = position self . empty = empty Info That abc mixin used in inheritance for creating your custom Sector objects. Expand example from typing import Any from multibar import ProgressBar from multibar.interfaces import AbstractSectorMixin class CustomSector ( AbstractSectorMixin ): def __init__ ( self , name : str , position : int , some_custom_var : int = 20 , empty : bool = False , ) -> None : super () . __init__ ( name = name , position = position , empty = empty , ) self . custom_var = some_custom_var def __repr__ ( self ) -> str : return self . name def __hash__ ( self ) -> int : return hash ( self . custom_var ) def __eq__ ( self , other : Any ) -> bool : if isinstance ( other , CustomSector ): return other . custom_var == self . custom_var return NotImplemented def double_var ( self ) -> int : return self . custom_var * 2 bar = ProgressBar ( 10 , 20 , sector_cls = CustomSector ) progress = bar . write_progress ( fill = \"+\" , line = \"-\" , some_custom_var = 10 ) assert isinstance ( progress . bar [ 0 ], CustomSector ) assert progress . bar [ 0 ] . double_var () == 20 class AbstractSectorMixin params name (str) - Sector character. position (int) - Sector position in container. empty (bool) - True if sector is empty (line character), default: False. class AbstractSeqBasedContainerMixin () Expand source code class AbstractSeqBasedContainerMixin ( Representable , Sized , abc . ABC , Generic [ T_co ]): @abc . abstractmethod def __getitem__ ( self , item : Union [ int , slice ], ) -> Union [ Iterable [ T_co ], T_co ]: ... def __enter__ ( self ) -> AbstractSeqBasedContainerMixin [ T_co ]: return self @overload def __exit__ ( self , exc_type : None , exc_val : None , exc_tb : None ) -> None : ... @overload def __exit__ ( self , exc_type : Type [ BaseException ], exc_val : BaseException , exc_tb : TracebackType , ) -> None : ... def __exit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc_val : Optional [ BaseException ], exc_tb : Optional [ TracebackType ], ) -> None : self . finalize () def finalize ( self ) -> None : ... @abc . abstractmethod def put ( self , item : T_co ) -> None : ... @property @abc . abstractmethod def view ( self ) -> Iterable [ T_co ]: ... Info That abc mixin used in inheritance for creating your custom Container objects, that stores Sectors. Expand example from __future__ import annotations import logging from typing import Iterable , List , Union , overload from multibar import ProgressBar from multibar.interfaces import AbstractBaseContainerMixin from multibar.internal import Sector logger = logging . getLogger ( __name__ ) class CustomContainer ( AbstractSeqBasedContainerMixin [ Sector ]): def __init__ ( self ) -> None : self . _storage : List [ Sector ] = [] def __repr__ ( self ) -> str : return \"\" . join ( i . name for i in self . _storage ) def __len__ ( self ) -> int : return len ( self . _storage ) @overload def __getitem__ ( self , item : int ) -> Sector : ... @overload def __getitem__ ( self , item : slice ) -> Iterable [ Sector ]: ... def __getitem__ ( self , item : Union [ int , slice ], ) -> Union [ Sector , Iterable [ Sector ]]: return self . _storage [ item ] def finalize ( self ) -> None : logger . debug ( \"Bar container was succesfullly created.\" ) def view ( self ) -> Iterable [ Sector ]: for sector in self . _storage : yield sector def put ( self , item : Sector ) -> None : self . _storage . append ( item ) def some_custom_method ( self ) -> None : while False : _ = ( yield ) bar = ProgressBar ( 10 , 20 , container_cls = CustomContainer ) progress = bar . write_progress ( fill = \"+\" , line = \"-\" ) assert isinstance ( progress . bar , CustomContainer ) assert hasattr ( progress . bar , \"some_custom_method\" )","title":"Abstract"},{"location":"abc/#class-abstractsectormixin-params","text":"name (str) - Sector character. position (int) - Sector position in container. empty (bool) - True if sector is empty (line character), default: False. class AbstractSeqBasedContainerMixin () Expand source code class AbstractSeqBasedContainerMixin ( Representable , Sized , abc . ABC , Generic [ T_co ]): @abc . abstractmethod def __getitem__ ( self , item : Union [ int , slice ], ) -> Union [ Iterable [ T_co ], T_co ]: ... def __enter__ ( self ) -> AbstractSeqBasedContainerMixin [ T_co ]: return self @overload def __exit__ ( self , exc_type : None , exc_val : None , exc_tb : None ) -> None : ... @overload def __exit__ ( self , exc_type : Type [ BaseException ], exc_val : BaseException , exc_tb : TracebackType , ) -> None : ... def __exit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc_val : Optional [ BaseException ], exc_tb : Optional [ TracebackType ], ) -> None : self . finalize () def finalize ( self ) -> None : ... @abc . abstractmethod def put ( self , item : T_co ) -> None : ... @property @abc . abstractmethod def view ( self ) -> Iterable [ T_co ]: ... Info That abc mixin used in inheritance for creating your custom Container objects, that stores Sectors. Expand example from __future__ import annotations import logging from typing import Iterable , List , Union , overload from multibar import ProgressBar from multibar.interfaces import AbstractBaseContainerMixin from multibar.internal import Sector logger = logging . getLogger ( __name__ ) class CustomContainer ( AbstractSeqBasedContainerMixin [ Sector ]): def __init__ ( self ) -> None : self . _storage : List [ Sector ] = [] def __repr__ ( self ) -> str : return \"\" . join ( i . name for i in self . _storage ) def __len__ ( self ) -> int : return len ( self . _storage ) @overload def __getitem__ ( self , item : int ) -> Sector : ... @overload def __getitem__ ( self , item : slice ) -> Iterable [ Sector ]: ... def __getitem__ ( self , item : Union [ int , slice ], ) -> Union [ Sector , Iterable [ Sector ]]: return self . _storage [ item ] def finalize ( self ) -> None : logger . debug ( \"Bar container was succesfullly created.\" ) def view ( self ) -> Iterable [ Sector ]: for sector in self . _storage : yield sector def put ( self , item : Sector ) -> None : self . _storage . append ( item ) def some_custom_method ( self ) -> None : while False : _ = ( yield ) bar = ProgressBar ( 10 , 20 , container_cls = CustomContainer ) progress = bar . write_progress ( fill = \"+\" , line = \"-\" ) assert isinstance ( progress . bar , CustomContainer ) assert hasattr ( progress . bar , \"some_custom_method\" )","title":"class AbstractSectorMixin params"},{"location":"crate/","text":"@dataclass class ProgressContainer ( current : int , total : int ) Expand source code @dataclass ( frozen = True ) class ProgressContainer : current : int total : int @overload def percents ( self , * , allow_float : Literal [ False ]) -> int : ... @overload def percents ( self , * , allow_float : Literal [ True ]) -> float : ... def percents ( self , * , allow_float : bool = False ) -> Union [ int , float ]: initial = ( self . current / self . total ) * 100 if allow_float : return initial return int ( initial ) class ProgressContainer current (int) - Current progress value. total (int) - Needed progress value. def percents ( self , * , allow_float : bool = False , ) -> Union [ int , float ]: def percents Returns percentage of current progress ((current/total) * 100). allow_float (bool) - If True, will return float, otherwise - int. Default: False. @dataclass class ProgressbarContainer ( length : int progress : ProgressContainer bar : AbstractBaseContainerMixin [ _AbcSectorT_co ] = field ( repr = False ) ) Expand source code _AbcSectorT_co = TypeVar ( \"_AbcSectorT_co\" , bound = AbstractSectorMixin , covariant = True ) @dataclass ( frozen = True , order = True ) class ProgressbarContainer ( Sized , Generic [ _AbcSectorT_co ]): length : int progress : ProgressContainer bar : AbstractBaseContainerMixin [ _AbcSectorT_co ] = field ( repr = False ) def __eq__ ( self , other : Any ) -> bool : if isinstance ( other , ProgressbarContainer ): return ( self . progress . current == other . progress . current and self . progress . total == other . progress . total ) return NotImplemented def __len__ ( self ) -> int : return len ( self . bar ) @overload def __getitem__ ( self , item : int , ) -> _AbcSectorT_co : ... @overload def __getitem__ ( self , item : slice , ) -> Iterable [ _AbcSectorT_co ]: ... def __getitem__ ( self , item : Union [ int , slice ], ) -> Union [ _AbcSectorT_co , Iterable [ _AbcSectorT_co ]]: return self . bar [ item ] class ProgressbarContainer length (int) - Length of progress bar. progress (ProgressContainer) - Progress container object. bar (AbstractBaseContainerMixin[_AbcSectorT_co]) - Container that stores progressbar sectors. Default: dataclass.field(repr=False). class SectorContainer () Expand source code @dataclass class SectorContainer ( AbstractSeqBasedContainerMixin [ _AbcSectorT_co ]): def __post_init__ ( self ) -> None : self . _storage : List [ _AbcSectorT_co ] = [] def __repr__ ( self ) -> str : return \"\" . join ( s . name for s in self . _storage ) def __len__ ( self ) -> int : return len ( self . _storage ) @overload def __getitem__ ( self , item : int , ) -> _AbcSectorT_co : ... @overload def __getitem__ ( self , item : slice , ) -> Iterable [ _AbcSectorT_co ]: ... def __getitem__ ( self , item : Union [ int , slice ], ) -> Union [ Iterable [ _AbcSectorT_co ], _AbcSectorT_co ]: return self . _storage [ item ] def put ( self , item : AbstractSectorMixin ) -> None : self . _storage . append ( cast ( _AbcSectorT_co , item )) def finalize ( self ) -> None : pass @property def view ( self ) -> List [ _AbcSectorT_co ]: return self . _storage def put ( self , item : AbstractSectorMixin ) -> None : def put Puts item to storage. item (AbstractSectorMixin) - Any Sector object. def finalize ( self ) -> None : def finalize Method that used in __exit__ . @property def view ( self ) -> List [ _AbcSectorT_co ]: @property view Returns iterator over sectors.","title":"Crate objects"},{"location":"crate/#class-progresscontainer","text":"current (int) - Current progress value. total (int) - Needed progress value. def percents ( self , * , allow_float : bool = False , ) -> Union [ int , float ]:","title":"class ProgressContainer"},{"location":"crate/#def-percents","text":"Returns percentage of current progress ((current/total) * 100). allow_float (bool) - If True, will return float, otherwise - int. Default: False. @dataclass class ProgressbarContainer ( length : int progress : ProgressContainer bar : AbstractBaseContainerMixin [ _AbcSectorT_co ] = field ( repr = False ) ) Expand source code _AbcSectorT_co = TypeVar ( \"_AbcSectorT_co\" , bound = AbstractSectorMixin , covariant = True ) @dataclass ( frozen = True , order = True ) class ProgressbarContainer ( Sized , Generic [ _AbcSectorT_co ]): length : int progress : ProgressContainer bar : AbstractBaseContainerMixin [ _AbcSectorT_co ] = field ( repr = False ) def __eq__ ( self , other : Any ) -> bool : if isinstance ( other , ProgressbarContainer ): return ( self . progress . current == other . progress . current and self . progress . total == other . progress . total ) return NotImplemented def __len__ ( self ) -> int : return len ( self . bar ) @overload def __getitem__ ( self , item : int , ) -> _AbcSectorT_co : ... @overload def __getitem__ ( self , item : slice , ) -> Iterable [ _AbcSectorT_co ]: ... def __getitem__ ( self , item : Union [ int , slice ], ) -> Union [ _AbcSectorT_co , Iterable [ _AbcSectorT_co ]]: return self . bar [ item ]","title":"def percents"},{"location":"crate/#class-progressbarcontainer","text":"length (int) - Length of progress bar. progress (ProgressContainer) - Progress container object. bar (AbstractBaseContainerMixin[_AbcSectorT_co]) - Container that stores progressbar sectors. Default: dataclass.field(repr=False). class SectorContainer () Expand source code @dataclass class SectorContainer ( AbstractSeqBasedContainerMixin [ _AbcSectorT_co ]): def __post_init__ ( self ) -> None : self . _storage : List [ _AbcSectorT_co ] = [] def __repr__ ( self ) -> str : return \"\" . join ( s . name for s in self . _storage ) def __len__ ( self ) -> int : return len ( self . _storage ) @overload def __getitem__ ( self , item : int , ) -> _AbcSectorT_co : ... @overload def __getitem__ ( self , item : slice , ) -> Iterable [ _AbcSectorT_co ]: ... def __getitem__ ( self , item : Union [ int , slice ], ) -> Union [ Iterable [ _AbcSectorT_co ], _AbcSectorT_co ]: return self . _storage [ item ] def put ( self , item : AbstractSectorMixin ) -> None : self . _storage . append ( cast ( _AbcSectorT_co , item )) def finalize ( self ) -> None : pass @property def view ( self ) -> List [ _AbcSectorT_co ]: return self . _storage def put ( self , item : AbstractSectorMixin ) -> None :","title":"class ProgressbarContainer"},{"location":"crate/#def-put","text":"Puts item to storage. item (AbstractSectorMixin) - Any Sector object. def finalize ( self ) -> None :","title":"def put"},{"location":"crate/#def-finalize","text":"Method that used in __exit__ . @property def view ( self ) -> List [ _AbcSectorT_co ]:","title":"def finalize"},{"location":"crate/#property-view","text":"Returns iterator over sectors.","title":"@property view"},{"location":"hooks/","text":"class AbstractCustomerMixin () Expand source code class AbstractCustomerMixin ( abc . ABC ): def __init__ ( self , ctx : ProgressContainer ) -> None : self . ctx = ctx @abc . abstractmethod def fill ( self , ctx : ProgressContainer ) -> Any : ... @abc . abstractmethod def line ( self , ctx : ProgressContainer ) -> Any : ... @abc . abstractmethod def start ( self , ctx : ProgressContainer ) -> Any : ... @abc . abstractmethod def end ( self , ctx : ProgressContainer ) -> Any : ... @abc . abstractmethod def unfilled_start ( self , ctx : ProgressContainer ) -> Any : ... @abc . abstractmethod def unfilled_end ( self , ctx : ProgressContainer ) -> Any : ... Expand example from __future__ import annotations from typing import TYPE_CHECKING , Any from multibar import ProgressBar from multibar.internal import AbstractCustomerMixin if TYPE_CHECKING : from multibar.internal import ProgressContainer bar = ProgressBar ( 8 , 20 ) class Customer ( AbstractCustomerMixin ): def fill ( self , ctx : ProgressContainer ) -> Any : if ctx . percents ( allow_float = False ) < 50 : return \"1\" return \"2\" def line ( self , ctx : ProgressContainer ) -> Any : if ctx . percents ( allow_float = False ) > 50 : return \"3\" return \"4\" def start ( self , ctx : ProgressContainer ) -> Any : return NotImplemented def end ( self , ctx : ProgressContainer ) -> Any : return NotImplemented def unfilled_start ( self , ctx : ProgressContainer ) -> Any : return NotImplemented def unfilled_end ( self , ctx : ProgressContainer ) -> Any : return NotImplemented progress = bar . write_from_customer ( customer = Customer ) assert str ( progress . bar ) == \"11111111444444444444\" # percents < 50 other_bar = ProgressBar ( 15 , 20 ) other_progress = other_bar . write_from_customer ( customer = Customer ) assert str ( other_progress . bar ) == \"22222222222222233333\" # line value changed (percents > 50) Info Hook that defines certain character for progressbar. All methods in this class takes context by second argument. class AbstractCustomerMixin abc methods fill - Fill character that uses for non empty sectors. line - Line character for empty sectors. start - First progressbar character. unfilled_start - Unfilled first progressbar character. end - Last progressbar character. unfilled_end - Unfilled last progressbar character.","title":"Hooks"},{"location":"hooks/#class-abstractcustomermixin-abc-methods","text":"fill - Fill character that uses for non empty sectors. line - Line character for empty sectors. start - First progressbar character. unfilled_start - Unfilled first progressbar character. end - Last progressbar character. unfilled_end - Unfilled last progressbar character.","title":"class AbstractCustomerMixin abc methods"},{"location":"multibar.impl/","text":"@dataclass class ProgressBar ( current : int , total : int , length : int = 20 , sector_cls : Optional [ Type [ _SectorT_co ]] = None , container : Optional [ Type [ _ContainerT_co ]] = None , ) Expand source code @dataclass class ProgressBar ( Generic [ _SectorT_co , _ContainerT_co ]): current : int total : int length : int = 20 sector_cls : Optional [ Type [ _SectorT_co ]] = None container_cls : Optional [ Type [ _ContainerT_co ]] = None def __post_init__ ( self ) -> None : if self . container_cls is None : self . container_cls = cast ( Type [ _ContainerT_co ], SectorContainer , ) self . factory : SphinxSectorFactory [ _SectorT_co ] = SphinxSectorFactory . from_bind ( sector_type = cast ( Type [ _SectorT_co ], Sector if self . sector_cls is None else self . sector_cls ) ) @overload def write_progress ( self , * , fill : str , line : str , ) -> ProgressbarContainer [ _SectorT_co ]: ... @overload def write_progress ( self , * , fill : str , line : str , start : str , unfilled_start : str , end : str , unfilled_end : str , ) -> ProgressbarContainer [ _SectorT_co ]: ... def write_progress ( self , * , fill : str , line : str , start : Optional [ str ] = None , unfilled_start : Optional [ str ] = None , end : Optional [ str ] = None , unfilled_end : Optional [ str ] = None , ) -> ProgressbarContainer [ AbstractSectorMixin ]: progress = ProgressContainer ( self . current , self . total ) percents = progress . percents ( allow_float = False ) assert self . container_cls is not None with self . container_cls () as container : for i in range ( rest := ( round ( percents / ( 100 / self . length )))): container . put ( self . factory . create_product ( fill , i , empty = False )) for i in range ( self . length - rest ): container . put ( self . factory . create_product ( line , i + rest , empty = True )) # Add `unfilled_start` if it is specified and none of the sectors is yet filled. if unfilled_start is not None and percents < FillFlag . FIRST : container [ 0 ] . name = unfilled_start # Otherwise, if `start` is specified, it will be added to the beginning. elif percents >= FillFlag . FIRST and start is not None : container [ 0 ] . name = start # If `unfilled_end` is specified and the last sector is not filled, then the # corresponding character will be added to the end of the progress bar. if unfilled_end is not None and percents < FillFlag . LAST : container [ - 1 ] . name = unfilled_end # Otherwise, if end is specified, the character corresponding to the # given argument will be appended to the end of the progressbar. elif percents >= FillFlag . LAST and end is not None : container [ - 1 ] . name = end return ProgressbarContainer ( bar = container , length = self . length , progress = progress , ) @overload async def async_write_progress ( self , * , fill : str , line : str , ) -> Coroutine [ ProgressbarContainer [ _SectorT_co ], None , None ]: ... @overload async def async_write_progress ( self , * , fill : str , line : str , loop : asyncio . AbstractEventLoop , ) -> Coroutine [ ProgressbarContainer [ _SectorT_co ], None , None ]: ... async def async_write_progress ( self , * , fill : str , line : str , start : Optional [ str ] = None , unfilled_start : Optional [ str ] = None , end : Optional [ str ] = None , unfilled_end : Optional [ str ] = None , loop : Optional [ asyncio . AbstractEventLoop ] = None , ) -> Coroutine [ ProgressbarContainer [ _SectorT_co ], None , None ]: if loop is None : loop = asyncio . get_event_loop () return cast ( Coroutine [ ProgressbarContainer [ _SectorT_co ], None , None ], await loop . run_in_executor ( None , partial ( self . write_progress , fill = fill , line = line , end = end , start = start , unfilled_start = unfilled_start , unfilled_end = unfilled_end , ), ), ) def write_from_customer ( self , * , customer : Type [ AbstractCustomerMixin ], ) -> ProgressbarContainer [ _SectorT_co ]: ctx = ProgressContainer ( self . current , self . total ) kwargs = {} for as_str in AbstractCustomerMixin . __abstractmethods__ : progress_char = getattr ( customer , as_str )( customer , ctx ) if not isinstance ( progress_char , ( NotImplementedType , NoneType )): kwargs [ as_str ] = progress_char return self . write_progress ( ** kwargs ) @overload async def async_write_from_customer ( self , * , customer : Type [ AbstractCustomerMixin ], ) -> Coroutine [ ProgressbarContainer [ AbstractSectorMixin ], None , None ]: ... @overload async def async_write_from_customer ( self , * , customer : Type [ AbstractCustomerMixin ], loop : asyncio . AbstractEventLoop , ) -> Coroutine [ ProgressbarContainer [ AbstractSectorMixin ], None , None ]: ... async def async_write_from_customer ( self , * , customer : Type [ AbstractCustomerMixin ], loop : Optional [ asyncio . AbstractEventLoop ] = None , ) -> Coroutine [ ProgressbarContainer [ AbstractSectorMixin ], None , None ]: if loop is None : loop = asyncio . get_event_loop () return cast ( Coroutine [ ProgressbarContainer [ AbstractSectorMixin ], None , None ], await loop . run_in_executor ( None , partial ( self . write_from_customer , customer = customer , ), ), ) Expand SectorFactory trick from typing import Any from multibar import ProgressBar from multibar.interfaces import AbstractSectorMixin from multibar.internal import Sector bar = ProgressBar ( 10 , 20 ) progress = bar . write_progress ( fill = \"+\" , line = \"-\" ) assert isinstance ( progress . bar [ 0 ], Sector ) class CustomSector ( AbstractSectorMixin ): def __init__ ( self , name : str , position : int , some_custom_var : int , empty : bool = False , ) -> None : super () . __init__ ( name = name , position = position , empty = empty ) self . some_custom_var = some_custom_var def __repr__ ( self ) -> str : return self . name def __hash__ ( self ) -> int : return hash ( self . some_custom_var ) def __eq__ ( self , other : Any ) -> bool : if isinstance ( other , CustomSector ): return other . some_custom_var == self . some_custom_var return NotImplemented def some_stuff ( self ) -> str : return \"yes\" if self . some_custom_var > 10 else \"no\" # Rebinding factory sector cls. bar . factory . rebind ( sector_type = CustomSector ) # Getting first sector of progressbar. other_progress = bar . write_progress ( fill = \"+\" , line = \"-\" , some_custom_var = 10 ) first_sector = other_progress . bar [ 0 ] # Asserting results. assert isinstance ( first_sector , CustomSector ) assert first_sector . some_stuff () == \"no\" class ProgressBar Info The main class with which you can create progressbars and customize their containers. current (int) - Current progress value. total (int) - Needed progress value. length (int) - ProgressBar length, default: 20. sector_cls (Optional[Type[_SectorT_co]]) - Subclass of AbstractSectorMixin, default: None. container_cls (Optional[Type[_ContainerT_co]]) - Subclass of AbstractBaseContainerMixin, default: None. def write_progress ( self , * , fill : str , line : str , start : Optional [ str ] = None , unfilled_start : Optional [ str ] = None , end : Optional [ str ] = None , unfilled_end : Optional [ str ] = None , ) -> ProgressbarContainer [ AbstractSectorMixin ]: def write_progress Info Function that writes progressbar from certain characters. fill (str) - Fill character that uses for non empty sectors. line (str) - Line character for empty sectors. start (Optional[str]) - First progressbar character, default: None. unfilled_start (Optional[str]) - Unfilled first progressbar character, default: None. end (Optional[str]) - Last progressbar character, default: None unfilled_end (Optional[str]) - Unfilled last progressbar character, default: None. async def async_write_progress ( self , * , fill : str , line : str , start : Optional [ str ] = None , unfilled_start : Optional [ str ] = None , end : Optional [ str ] = None , unfilled_end : Optional [ str ] = None , loop : Optional [ asyncio . AbstractEventLoop ] = None , ) -> Coroutine [ ProgressbarContainer [ _SectorT_co ], None , None ]: async async_write_progress Info Function that asynchronously writes progressbar from certain characters. fill (str) - Fill character that uses for non empty sectors. line (str) - Line character for empty sectors. start (Optional[str]) - First progressbar character, default: None. unfilled_start (Optional[str]) - Unfilled first progressbar character, default: None. end (Optional[str]) - Last progressbar character, default: None unfilled_end (Optional[str]) - Unfilled last progressbar character, default: None. loop (Optional[asyncio.AbstractEventLoop]) - Event loop for making awaitable future from sync. def write_from_customer ( self , * , customer : Type [ AbstractCustomerMixin ], ) -> ProgressbarContainer [ _SectorT_co ]: def write_from_customer Info Function that writes progressbar from customer class. customer (Type[AbstractCustomerMixin]) - Subclass of AbstractCustomerMixin. Expand example from __future__ import annotations from typing import TYPE_CHECKING , Any from multibar import ProgressBar from multibar.internal import AbstractCustomerMixin if TYPE_CHECKING : from multibar.internal import ProgressContainer bar = ProgressBar ( 8 , 20 ) class Customer ( AbstractCustomerMixin ): def fill ( self , ctx : ProgressContainer ) -> Any : if ctx . percents ( allow_float = False ) < 50 : return \"1\" return \"2\" def line ( self , ctx : ProgressContainer ) -> Any : if ctx . percents ( allow_float = False ) > 50 : return \"3\" return \"4\" def start ( self , ctx : ProgressContainer ) -> Any : return NotImplemented def end ( self , ctx : ProgressContainer ) -> Any : return NotImplemented def unfilled_start ( self , ctx : ProgressContainer ) -> Any : return NotImplemented def unfilled_end ( self , ctx : ProgressContainer ) -> Any : return NotImplemented progress = bar . write_from_customer ( customer = Customer ) assert str ( progress . bar ) == \"11111111444444444444\" # percents < 50 other_bar = ProgressBar ( 15 , 20 ) other_progress = other_bar . write_from_customer ( customer = Customer ) assert str ( other_progress . bar ) == \"22222222222222233333\" # line value changed (percents > 50) async def async_write_from_customer ( self , * , customer : Type [ AbstractCustomerMixin ], loop : Optional [ asyncio . AbstractEventLoop ] = None , ) -> Coroutine [ ProgressbarContainer [ AbstractSectorMixin ], None , None ]: async async_write_from_customer Info Function that asynchronously writes progressbar from customer class. customer (Type[AbstractCustomerMixin]) - Subclass of AbstractCustomerMixin. loop (Optional[asyncio.AbstractEventLoop]) - Event loop for making awaitable future from sync.","title":"ProgressBar"},{"location":"multibar.impl/#class-progressbar","text":"Info The main class with which you can create progressbars and customize their containers. current (int) - Current progress value. total (int) - Needed progress value. length (int) - ProgressBar length, default: 20. sector_cls (Optional[Type[_SectorT_co]]) - Subclass of AbstractSectorMixin, default: None. container_cls (Optional[Type[_ContainerT_co]]) - Subclass of AbstractBaseContainerMixin, default: None. def write_progress ( self , * , fill : str , line : str , start : Optional [ str ] = None , unfilled_start : Optional [ str ] = None , end : Optional [ str ] = None , unfilled_end : Optional [ str ] = None , ) -> ProgressbarContainer [ AbstractSectorMixin ]:","title":"class ProgressBar"},{"location":"multibar.impl/#def-write_progress","text":"Info Function that writes progressbar from certain characters. fill (str) - Fill character that uses for non empty sectors. line (str) - Line character for empty sectors. start (Optional[str]) - First progressbar character, default: None. unfilled_start (Optional[str]) - Unfilled first progressbar character, default: None. end (Optional[str]) - Last progressbar character, default: None unfilled_end (Optional[str]) - Unfilled last progressbar character, default: None. async def async_write_progress ( self , * , fill : str , line : str , start : Optional [ str ] = None , unfilled_start : Optional [ str ] = None , end : Optional [ str ] = None , unfilled_end : Optional [ str ] = None , loop : Optional [ asyncio . AbstractEventLoop ] = None , ) -> Coroutine [ ProgressbarContainer [ _SectorT_co ], None , None ]:","title":"def write_progress"},{"location":"multibar.impl/#async-async_write_progress","text":"Info Function that asynchronously writes progressbar from certain characters. fill (str) - Fill character that uses for non empty sectors. line (str) - Line character for empty sectors. start (Optional[str]) - First progressbar character, default: None. unfilled_start (Optional[str]) - Unfilled first progressbar character, default: None. end (Optional[str]) - Last progressbar character, default: None unfilled_end (Optional[str]) - Unfilled last progressbar character, default: None. loop (Optional[asyncio.AbstractEventLoop]) - Event loop for making awaitable future from sync. def write_from_customer ( self , * , customer : Type [ AbstractCustomerMixin ], ) -> ProgressbarContainer [ _SectorT_co ]:","title":"async async_write_progress"},{"location":"multibar.impl/#def-write_from_customer","text":"Info Function that writes progressbar from customer class. customer (Type[AbstractCustomerMixin]) - Subclass of AbstractCustomerMixin. Expand example from __future__ import annotations from typing import TYPE_CHECKING , Any from multibar import ProgressBar from multibar.internal import AbstractCustomerMixin if TYPE_CHECKING : from multibar.internal import ProgressContainer bar = ProgressBar ( 8 , 20 ) class Customer ( AbstractCustomerMixin ): def fill ( self , ctx : ProgressContainer ) -> Any : if ctx . percents ( allow_float = False ) < 50 : return \"1\" return \"2\" def line ( self , ctx : ProgressContainer ) -> Any : if ctx . percents ( allow_float = False ) > 50 : return \"3\" return \"4\" def start ( self , ctx : ProgressContainer ) -> Any : return NotImplemented def end ( self , ctx : ProgressContainer ) -> Any : return NotImplemented def unfilled_start ( self , ctx : ProgressContainer ) -> Any : return NotImplemented def unfilled_end ( self , ctx : ProgressContainer ) -> Any : return NotImplemented progress = bar . write_from_customer ( customer = Customer ) assert str ( progress . bar ) == \"11111111444444444444\" # percents < 50 other_bar = ProgressBar ( 15 , 20 ) other_progress = other_bar . write_from_customer ( customer = Customer ) assert str ( other_progress . bar ) == \"22222222222222233333\" # line value changed (percents > 50) async def async_write_from_customer ( self , * , customer : Type [ AbstractCustomerMixin ], loop : Optional [ asyncio . AbstractEventLoop ] = None , ) -> Coroutine [ ProgressbarContainer [ AbstractSectorMixin ], None , None ]:","title":"def write_from_customer"},{"location":"multibar.impl/#async-async_write_from_customer","text":"Info Function that asynchronously writes progressbar from customer class. customer (Type[AbstractCustomerMixin]) - Subclass of AbstractCustomerMixin. loop (Optional[asyncio.AbstractEventLoop]) - Event loop for making awaitable future from sync.","title":"async async_write_from_customer"}]}