{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"docs/","text":"\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u0420\u0443\u0441\u0441\u043a\u0438\u0439","title":"Index"},{"location":"docs/errors/","text":"multibar.errors \u00a4 __all__ = ( 'MultibarError' , 'ContractError' , 'ContractResponseError' , 'UnsignedContractError' , 'TerminatedContractError' ) module-attribute \u00a4 ContractError \u00a4 Bases: MultibarError Base contracts error. Source code in multibar\\errors.py 25 26 27 class ContractError ( MultibarError ): \"\"\"Base contracts error.\"\"\" pass ContractResponseError \u00a4 Bases: ContractError Error that parses contract response. PARAMETER DESCRIPTION check Check. TYPE: ContractCheck Source code in multibar\\errors.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class ContractResponseError ( ContractError ): \"\"\"Error that parses contract response. Parameters ---------- check : ContractCheck Check. \"\"\" __slots__ = ( \"contract_check\" ,) def __init__ ( self , check : contracts . ContractCheck , / ) -> None : self . contract_check = check super () . __init__ ( self . _process_check ()) def _process_check ( self ) -> str : messages = self . contract_check . errors + self . contract_check . warnings return \" & \" . join ( messages ) __slots__ = ( 'contract_check' ) class-attribute \u00a4 contract_check = check instance-attribute \u00a4 __init__ ( check ) \u00a4 Source code in multibar\\errors.py 41 42 43 def __init__ ( self , check : contracts . ContractCheck , / ) -> None : self . contract_check = check super () . __init__ ( self . _process_check ()) MultibarError \u00a4 Bases: Exception Base multibar error. You can use this error to catch any error from Python-Multibar. Source code in multibar\\errors.py 18 19 20 21 22 class MultibarError ( Exception ): \"\"\"Base multibar error. You can use this error to catch any error from Python-Multibar. \"\"\" pass TerminatedContractError \u00a4 Bases: ContractResponseError Raises if contract is broken. Source code in multibar\\errors.py 55 56 57 class TerminatedContractError ( ContractResponseError ): \"\"\"Raises if contract is broken.\"\"\" pass UnsignedContractError \u00a4 Bases: ContractError Raises if contract manager is not subscribed for specify contract. Source code in multibar\\errors.py 50 51 52 class UnsignedContractError ( ContractError ): \"\"\"Raises if contract manager is not subscribed for specify contract.\"\"\" pass","title":"Errors"},{"location":"docs/errors/#multibar.errors","text":"","title":"errors"},{"location":"docs/errors/#multibar.errors.__all__","text":"","title":"__all__"},{"location":"docs/errors/#multibar.errors.ContractError","text":"Bases: MultibarError Base contracts error. Source code in multibar\\errors.py 25 26 27 class ContractError ( MultibarError ): \"\"\"Base contracts error.\"\"\" pass","title":"ContractError"},{"location":"docs/errors/#multibar.errors.ContractResponseError","text":"Bases: ContractError Error that parses contract response. PARAMETER DESCRIPTION check Check. TYPE: ContractCheck Source code in multibar\\errors.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class ContractResponseError ( ContractError ): \"\"\"Error that parses contract response. Parameters ---------- check : ContractCheck Check. \"\"\" __slots__ = ( \"contract_check\" ,) def __init__ ( self , check : contracts . ContractCheck , / ) -> None : self . contract_check = check super () . __init__ ( self . _process_check ()) def _process_check ( self ) -> str : messages = self . contract_check . errors + self . contract_check . warnings return \" & \" . join ( messages )","title":"ContractResponseError"},{"location":"docs/errors/#multibar.errors.ContractResponseError.__slots__","text":"","title":"__slots__"},{"location":"docs/errors/#multibar.errors.ContractResponseError.contract_check","text":"","title":"contract_check"},{"location":"docs/errors/#multibar.errors.ContractResponseError.__init__","text":"Source code in multibar\\errors.py 41 42 43 def __init__ ( self , check : contracts . ContractCheck , / ) -> None : self . contract_check = check super () . __init__ ( self . _process_check ())","title":"__init__()"},{"location":"docs/errors/#multibar.errors.MultibarError","text":"Bases: Exception Base multibar error. You can use this error to catch any error from Python-Multibar. Source code in multibar\\errors.py 18 19 20 21 22 class MultibarError ( Exception ): \"\"\"Base multibar error. You can use this error to catch any error from Python-Multibar. \"\"\" pass","title":"MultibarError"},{"location":"docs/errors/#multibar.errors.TerminatedContractError","text":"Bases: ContractResponseError Raises if contract is broken. Source code in multibar\\errors.py 55 56 57 class TerminatedContractError ( ContractResponseError ): \"\"\"Raises if contract is broken.\"\"\" pass","title":"TerminatedContractError"},{"location":"docs/errors/#multibar.errors.UnsignedContractError","text":"Bases: ContractError Raises if contract manager is not subscribed for specify contract. Source code in multibar\\errors.py 50 51 52 class UnsignedContractError ( ContractError ): \"\"\"Raises if contract manager is not subscribed for specify contract.\"\"\" pass","title":"UnsignedContractError"},{"location":"docs/faq/","text":"\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u0420\u0443\u0441\u0441\u043a\u0438\u0439 Hi \u00a4 fd","title":"Hi"},{"location":"docs/faq/#hi","text":"fd","title":"Hi"},{"location":"docs/faq.ru/","text":"\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 English d","title":"Faq.ru"},{"location":"docs/faq.uk/","text":"\u0420\u0443\u0441\u0441\u043a\u0438\u0439 English","title":"Faq.uk"},{"location":"docs/howto/","text":"\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u0420\u0443\u0441\u0441\u043a\u0438\u0439 How to install... \u00a4 How to use docs... \u00a4 How to .... \u00a4","title":"How to install..."},{"location":"docs/howto/#how-to-install","text":"","title":"How to install..."},{"location":"docs/howto/#how-to-use-docs","text":"","title":"How to use docs..."},{"location":"docs/howto/#how-to","text":"","title":"How to ...."},{"location":"docs/howto.ru/","text":"\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 English","title":"Howto.ru"},{"location":"docs/howto.uk/","text":"\u0420\u0443\u0441\u0441\u043a\u0438\u0439 English","title":"Howto.uk"},{"location":"docs/index.ru/","text":"\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 English \u0414\u043e\u0431\u0440\u043e \u043f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c \u0432 Python-Multibar! \u041f\u0440\u043e\u0435\u043a\u0442: python-multibar \u041b\u0438\u0446\u0435\u043d\u0437\u0438\u044f: Apache 2.0 \u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435: Tool for static progress bars writing. \u041e\u0421: \u041d\u0435\u0437\u0430\u0432\u0438\u0441\u0438\u043c Python: 3.9+ Typing: Typed \u0422\u0435\u043c\u0430: \u0423\u0442\u0438\u043b\u0438\u0442\u044b \u041c\u044b \u043d\u0430 PyPi \u00b7 \u0421\u043e\u043e\u0431\u0449\u0438\u0442\u044c \u043e \u0431\u0430\u0433\u0435 \u00b7 \u041f\u0440\u0435\u0434\u043b\u043e\u0436\u0438\u0442\u044c \u0438\u0434\u0435\u044e TL;DR \u041a\u0430\u043a \u0447\u0438\u0442\u0430\u0442\u044c \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044e \u041e\u0442\u0432\u0435\u0442\u044b \u043d\u0430 \u043f\u043e\u0442\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0435 \u0432\u043e\u043f\u0440\u043e\u0441\u044b \u0421 \u0447\u0435\u0433\u043e \u043d\u0430\u0447\u0430\u0442\u044c \u041c\u0438\u043d\u0438-\u043a\u0430\u0440\u0442\u0430 Python-Multibar classDiagram PInterface < |-- ProgressbarWriter : Implements SAbstraction < |-- Sector : Implements CAbstraction < |-- CalculationService : Implements SignatureSegment < -- Signature : Uses by default Signature --> PSProtocol : Matches SignatureSegment --> SSProtocol : Matches Sector --o ProgressbarWriter : By default CalculationService --o ProgressbarWriter : By default Signature --o ProgressbarWriter : By default PCInterface < |-- ProgressbarClient : Implements HInterface < |-- Hooks : Implements CMInterface < |-- ContractManager : Implements CMInterface --> ContractInterface : Interacts with Hooks --o ProgressbarClient : By default ContractManager --o ProgressbarClient : By default ProgressbarWriter --o ProgressbarClient : By default","title":"Index.ru"},{"location":"docs/index.uk/","text":"\u0420\u0443\u0441\u0441\u043a\u0438\u0439 English \u0423\u043a\u0440\u0430\u0438\u043d\u0441\u043a\u0438\u0439","title":"Index.uk"},{"location":"docs/output/","text":"multibar.output \u00a4 This module implements the prebound method pattern to create a simple api output to the console. COLORS : typing . Final [ dict [ OutputTypes , ColorsType ]] = { ERROR : 'red' , SUCCESS : 'green' , WARNING : 'yellow' } module-attribute \u00a4 ColorsType : typing_extensions . TypeAlias = typing . Literal [ 'red' , 'green' , 'yellow' ] module-attribute \u00a4 ERROR : typing . Final [ ErrorType ] = 'error' module-attribute \u00a4 ErrorType : typing_extensions . TypeAlias = typing . Literal [ 'error' ] module-attribute \u00a4 HEADING_LEVEL_ONE : typing . Final [ typing . Literal [ 1 ]] = 1 module-attribute \u00a4 HEADING_LEVEL_THREE : typing . Final [ typing . Literal [ 3 ]] = 3 module-attribute \u00a4 HEADING_LEVEL_TWO : typing . Final [ typing . Literal [ 2 ]] = 2 module-attribute \u00a4 HEADING_MAP : typing . Final [ dict [ HeadingLevelsType , tuple [ str , bool ]]] = { HEADING_LEVEL_ONE : ( '=' , True ), HEADING_LEVEL_TWO : ( '-' , True ), HEADING_LEVEL_THREE : ( '-' , False )} module-attribute \u00a4 HeadingLevelOneType : typing_extensions . TypeAlias = typing . Literal [ 1 ] module-attribute \u00a4 HeadingLevelThreeType : typing_extensions . TypeAlias = typing . Literal [ 3 ] module-attribute \u00a4 HeadingLevelTwoType : typing_extensions . TypeAlias = typing . Literal [ 2 ] module-attribute \u00a4 HeadingLevelsType : typing_extensions . TypeAlias = typing . Union [ HeadingLevelOneType , HeadingLevelTwoType , HeadingLevelThreeType ] module-attribute \u00a4 OutputTypes : typing_extensions . TypeAlias = typing . Union [ ErrorType , WarningType , SuccessType ] module-attribute \u00a4 SUCCESS : typing . Final [ SuccessType ] = 'success' module-attribute \u00a4 SuccessType : typing_extensions . TypeAlias = typing . Literal [ 'success' ] module-attribute \u00a4 WARNING : typing . Final [ WarningType ] = 'warning' module-attribute \u00a4 WarningType : typing_extensions . TypeAlias = typing . Literal [ 'warning' ] module-attribute \u00a4 __all__ = ( 'PrinterAware' , 'TermcolorPrinter' , 'print' , 'new_line' , 'print_success' , 'print_warning' , 'print_heading' , 'print_error' ) module-attribute \u00a4 new_line = _output . new_line module-attribute \u00a4 print = _output . print module-attribute \u00a4 print_error = _output . print_error module-attribute \u00a4 print_heading = _output . print_heading module-attribute \u00a4 print_success = _output . print_success module-attribute \u00a4 print_warning = _output . print_warning module-attribute \u00a4 Output \u00a4 Class that represents console printer. Source code in multibar\\output.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 class Output : \"\"\"Class that represents console printer.\"\"\" @impure def print ( self , text : str = \"\" , / , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> None : \"\"\"Prints text in console. text : str = \"\", / Text to print. bold : bool = False, * If True, will print bold text in console. color : typing.Optional[str] = None, * If is not None, will make text colored. newline : bool = True, * If True, new line will be added to text. \"\"\" self . printer . print ( text , bold = bold , color = color , newline = newline , ) @impure def new_line ( self ) -> None : \"\"\"Prints new line.\"\"\" self . printer . print () @impure def print_heading ( self , text : str , / , * , level : HeadingLevelsType , style : typing . Optional [ OutputTypes ] = None , indent : bool = True , ) -> None : \"\"\"Prints headings in console. text : str, / Text to header. level : HeadingLevelsType, * Header level. style : typing.Optional[OutputTypes] = None, * If is not None, will change header style. indent : bool = True, * If True, will print new line after text. \"\"\" color = COLORS [ style ] if style else None line_char , show_line_above = HEADING_MAP [ level ] heading_line = line_char * len ( text ) if show_line_above : self . printer . print ( heading_line , bold = True , color = color ) self . printer . print ( text , bold = True , color = color ) self . printer . print ( heading_line , bold = True , color = color ) if indent : self . printer . print () @impure def print_success ( self , text : str , / , * , bold : bool = True ) -> None : \"\"\"Prints text as success. Parameters ---------- text: str, / Text to print. bold: bool = True, * If True, will print text as bold. \"\"\" self . printer . print ( text , color = COLORS [ SUCCESS ], bold = bold ) @impure def print_error ( self , text : str , / , * , bold : bool = True ) -> None : \"\"\"Prints text as error. Parameters ---------- text: str, / Text to print. bold: bool = True, * If True, will print text as bold. \"\"\" self . printer . print ( text , color = COLORS [ ERROR ], bold = bold ) @impure def print_warning ( self , text : str , / ) -> None : \"\"\"Prints text as warning. Parameters ---------- text: str, / Text to print. \"\"\" self . printer . print ( text , color = COLORS [ WARNING ]) def update_printer ( self ) -> None : \"\"\"Updates cache for printer cached_property.\"\"\" utils . cached_property . update_cache_for ( self , \"printer\" ) @utils . cached_property def printer ( self ) -> PrinterAware : \"\"\"Cached property. Returns ------- PrinterAware Printer implementation. \"\"\" if _PRINTER_KEY in settings . settings : return settings . settings [ _PRINTER_KEY ] return _PRINTER_STATE new_line () \u00a4 Prints new line. Source code in multibar\\output.py 158 159 160 161 @impure def new_line ( self ) -> None : \"\"\"Prints new line.\"\"\" self . printer . print () print ( text = '' , / , * , bold = False , color = None , newline = True ) \u00a4 Prints text in console. text : str = \"\", / Text to print. bold : bool = False, * If True, will print bold text in console. color : typing.Optional[str] = None, * If is not None, will make text colored. newline : bool = True, * If True, new line will be added to text. Source code in multibar\\output.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 @impure def print ( self , text : str = \"\" , / , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> None : \"\"\"Prints text in console. text : str = \"\", / Text to print. bold : bool = False, * If True, will print bold text in console. color : typing.Optional[str] = None, * If is not None, will make text colored. newline : bool = True, * If True, new line will be added to text. \"\"\" self . printer . print ( text , bold = bold , color = color , newline = newline , ) print_error ( text , / , * , bold = True ) \u00a4 Prints text as error. PARAMETER DESCRIPTION text Text to print. TYPE: str bold: bool = True, * If True, will print text as bold. Source code in multibar\\output.py 214 215 216 217 218 219 220 221 222 223 224 225 226 @impure def print_error ( self , text : str , / , * , bold : bool = True ) -> None : \"\"\"Prints text as error. Parameters ---------- text: str, / Text to print. bold: bool = True, * If True, will print text as bold. \"\"\" self . printer . print ( text , color = COLORS [ ERROR ], bold = bold ) print_heading ( text , / , * , level , style = None , indent = True ) \u00a4 Prints headings in console. text : str, / Text to header. level : HeadingLevelsType, * Header level. style : typing.Optional[OutputTypes] = None, * If is not None, will change header style. indent : bool = True, * If True, will print new line after text. Source code in multibar\\output.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 @impure def print_heading ( self , text : str , / , * , level : HeadingLevelsType , style : typing . Optional [ OutputTypes ] = None , indent : bool = True , ) -> None : \"\"\"Prints headings in console. text : str, / Text to header. level : HeadingLevelsType, * Header level. style : typing.Optional[OutputTypes] = None, * If is not None, will change header style. indent : bool = True, * If True, will print new line after text. \"\"\" color = COLORS [ style ] if style else None line_char , show_line_above = HEADING_MAP [ level ] heading_line = line_char * len ( text ) if show_line_above : self . printer . print ( heading_line , bold = True , color = color ) self . printer . print ( text , bold = True , color = color ) self . printer . print ( heading_line , bold = True , color = color ) if indent : self . printer . print () print_success ( text , / , * , bold = True ) \u00a4 Prints text as success. PARAMETER DESCRIPTION text Text to print. TYPE: str bold: bool = True, * If True, will print text as bold. Source code in multibar\\output.py 200 201 202 203 204 205 206 207 208 209 210 211 212 @impure def print_success ( self , text : str , / , * , bold : bool = True ) -> None : \"\"\"Prints text as success. Parameters ---------- text: str, / Text to print. bold: bool = True, * If True, will print text as bold. \"\"\" self . printer . print ( text , color = COLORS [ SUCCESS ], bold = bold ) print_warning ( text ) \u00a4 Prints text as warning. PARAMETER DESCRIPTION text Text to print. TYPE: str Source code in multibar\\output.py 228 229 230 231 232 233 234 235 236 237 @impure def print_warning ( self , text : str , / ) -> None : \"\"\"Prints text as warning. Parameters ---------- text: str, / Text to print. \"\"\" self . printer . print ( text , color = COLORS [ WARNING ]) printer () \u00a4 Cached property. RETURNS DESCRIPTION PrinterAware Printer implementation. Source code in multibar\\output.py 243 244 245 246 247 248 249 250 251 252 253 254 @utils . cached_property def printer ( self ) -> PrinterAware : \"\"\"Cached property. Returns ------- PrinterAware Printer implementation. \"\"\" if _PRINTER_KEY in settings . settings : return settings . settings [ _PRINTER_KEY ] return _PRINTER_STATE update_printer () \u00a4 Updates cache for printer cached_property. Source code in multibar\\output.py 239 240 241 def update_printer ( self ) -> None : \"\"\"Updates cache for printer cached_property.\"\"\" utils . cached_property . update_cache_for ( self , \"printer\" ) PrinterAware \u00a4 Bases: abc . ABC Interface for printer implementations. Source code in multibar\\output.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class PrinterAware ( abc . ABC ): \"\"\"Interface for printer implementations.\"\"\" @typing . overload @abc . abstractmethod def print ( self ) -> IO [ None ]: ... @typing . overload @abc . abstractmethod def print ( self , text : str ) -> IO [ None ]: ... @typing . overload @abc . abstractmethod def print ( self , text : str , * , bold : bool , color : typing . Optional [ str ], newline : bool , ) -> IO [ None ]: ... @abc . abstractmethod def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console.\"\"\" ... print ( text = '' , * , bold = False , color = None , newline = True ) abstractmethod \u00a4 Prints text in console. Source code in multibar\\output.py 89 90 91 92 93 94 95 96 97 98 99 @abc . abstractmethod def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console.\"\"\" ... TermcolorPrinter \u00a4 Bases: PrinterAware Source code in multibar\\output.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class TermcolorPrinter ( PrinterAware ): def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: # << inherited docstring from PrinterAware >> termcolor_attrs : list [ str ] = [] if bold : termcolor_attrs . append ( \"bold\" ) if newline : text += \" \\n \" termcolor . cprint ( text , color , attrs = termcolor_attrs ) return IO ( None ) print ( text = '' , * , bold = False , color = None , newline = True ) \u00a4 Source code in multibar\\output.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: # << inherited docstring from PrinterAware >> termcolor_attrs : list [ str ] = [] if bold : termcolor_attrs . append ( \"bold\" ) if newline : text += \" \\n \" termcolor . cprint ( text , color , attrs = termcolor_attrs ) return IO ( None )","title":"Console (English)"},{"location":"docs/output/#multibar.output","text":"This module implements the prebound method pattern to create a simple api output to the console.","title":"output"},{"location":"docs/output/#multibar.output.COLORS","text":"","title":"COLORS"},{"location":"docs/output/#multibar.output.ColorsType","text":"","title":"ColorsType"},{"location":"docs/output/#multibar.output.ERROR","text":"","title":"ERROR"},{"location":"docs/output/#multibar.output.ErrorType","text":"","title":"ErrorType"},{"location":"docs/output/#multibar.output.HEADING_LEVEL_ONE","text":"","title":"HEADING_LEVEL_ONE"},{"location":"docs/output/#multibar.output.HEADING_LEVEL_THREE","text":"","title":"HEADING_LEVEL_THREE"},{"location":"docs/output/#multibar.output.HEADING_LEVEL_TWO","text":"","title":"HEADING_LEVEL_TWO"},{"location":"docs/output/#multibar.output.HEADING_MAP","text":"","title":"HEADING_MAP"},{"location":"docs/output/#multibar.output.HeadingLevelOneType","text":"","title":"HeadingLevelOneType"},{"location":"docs/output/#multibar.output.HeadingLevelThreeType","text":"","title":"HeadingLevelThreeType"},{"location":"docs/output/#multibar.output.HeadingLevelTwoType","text":"","title":"HeadingLevelTwoType"},{"location":"docs/output/#multibar.output.HeadingLevelsType","text":"","title":"HeadingLevelsType"},{"location":"docs/output/#multibar.output.OutputTypes","text":"","title":"OutputTypes"},{"location":"docs/output/#multibar.output.SUCCESS","text":"","title":"SUCCESS"},{"location":"docs/output/#multibar.output.SuccessType","text":"","title":"SuccessType"},{"location":"docs/output/#multibar.output.WARNING","text":"","title":"WARNING"},{"location":"docs/output/#multibar.output.WarningType","text":"","title":"WarningType"},{"location":"docs/output/#multibar.output.__all__","text":"","title":"__all__"},{"location":"docs/output/#multibar.output.new_line","text":"","title":"new_line"},{"location":"docs/output/#multibar.output.print","text":"","title":"print"},{"location":"docs/output/#multibar.output.print_error","text":"","title":"print_error"},{"location":"docs/output/#multibar.output.print_heading","text":"","title":"print_heading"},{"location":"docs/output/#multibar.output.print_success","text":"","title":"print_success"},{"location":"docs/output/#multibar.output.print_warning","text":"","title":"print_warning"},{"location":"docs/output/#multibar.output.Output","text":"Class that represents console printer. Source code in multibar\\output.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 class Output : \"\"\"Class that represents console printer.\"\"\" @impure def print ( self , text : str = \"\" , / , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> None : \"\"\"Prints text in console. text : str = \"\", / Text to print. bold : bool = False, * If True, will print bold text in console. color : typing.Optional[str] = None, * If is not None, will make text colored. newline : bool = True, * If True, new line will be added to text. \"\"\" self . printer . print ( text , bold = bold , color = color , newline = newline , ) @impure def new_line ( self ) -> None : \"\"\"Prints new line.\"\"\" self . printer . print () @impure def print_heading ( self , text : str , / , * , level : HeadingLevelsType , style : typing . Optional [ OutputTypes ] = None , indent : bool = True , ) -> None : \"\"\"Prints headings in console. text : str, / Text to header. level : HeadingLevelsType, * Header level. style : typing.Optional[OutputTypes] = None, * If is not None, will change header style. indent : bool = True, * If True, will print new line after text. \"\"\" color = COLORS [ style ] if style else None line_char , show_line_above = HEADING_MAP [ level ] heading_line = line_char * len ( text ) if show_line_above : self . printer . print ( heading_line , bold = True , color = color ) self . printer . print ( text , bold = True , color = color ) self . printer . print ( heading_line , bold = True , color = color ) if indent : self . printer . print () @impure def print_success ( self , text : str , / , * , bold : bool = True ) -> None : \"\"\"Prints text as success. Parameters ---------- text: str, / Text to print. bold: bool = True, * If True, will print text as bold. \"\"\" self . printer . print ( text , color = COLORS [ SUCCESS ], bold = bold ) @impure def print_error ( self , text : str , / , * , bold : bool = True ) -> None : \"\"\"Prints text as error. Parameters ---------- text: str, / Text to print. bold: bool = True, * If True, will print text as bold. \"\"\" self . printer . print ( text , color = COLORS [ ERROR ], bold = bold ) @impure def print_warning ( self , text : str , / ) -> None : \"\"\"Prints text as warning. Parameters ---------- text: str, / Text to print. \"\"\" self . printer . print ( text , color = COLORS [ WARNING ]) def update_printer ( self ) -> None : \"\"\"Updates cache for printer cached_property.\"\"\" utils . cached_property . update_cache_for ( self , \"printer\" ) @utils . cached_property def printer ( self ) -> PrinterAware : \"\"\"Cached property. Returns ------- PrinterAware Printer implementation. \"\"\" if _PRINTER_KEY in settings . settings : return settings . settings [ _PRINTER_KEY ] return _PRINTER_STATE","title":"Output"},{"location":"docs/output/#multibar.output.Output.new_line","text":"Prints new line. Source code in multibar\\output.py 158 159 160 161 @impure def new_line ( self ) -> None : \"\"\"Prints new line.\"\"\" self . printer . print ()","title":"new_line()"},{"location":"docs/output/#multibar.output.Output.print","text":"Prints text in console. text : str = \"\", / Text to print. bold : bool = False, * If True, will print bold text in console. color : typing.Optional[str] = None, * If is not None, will make text colored. newline : bool = True, * If True, new line will be added to text. Source code in multibar\\output.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 @impure def print ( self , text : str = \"\" , / , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> None : \"\"\"Prints text in console. text : str = \"\", / Text to print. bold : bool = False, * If True, will print bold text in console. color : typing.Optional[str] = None, * If is not None, will make text colored. newline : bool = True, * If True, new line will be added to text. \"\"\" self . printer . print ( text , bold = bold , color = color , newline = newline , )","title":"print()"},{"location":"docs/output/#multibar.output.Output.print_error","text":"Prints text as error. PARAMETER DESCRIPTION text Text to print. TYPE: str bold: bool = True, * If True, will print text as bold. Source code in multibar\\output.py 214 215 216 217 218 219 220 221 222 223 224 225 226 @impure def print_error ( self , text : str , / , * , bold : bool = True ) -> None : \"\"\"Prints text as error. Parameters ---------- text: str, / Text to print. bold: bool = True, * If True, will print text as bold. \"\"\" self . printer . print ( text , color = COLORS [ ERROR ], bold = bold )","title":"print_error()"},{"location":"docs/output/#multibar.output.Output.print_heading","text":"Prints headings in console. text : str, / Text to header. level : HeadingLevelsType, * Header level. style : typing.Optional[OutputTypes] = None, * If is not None, will change header style. indent : bool = True, * If True, will print new line after text. Source code in multibar\\output.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 @impure def print_heading ( self , text : str , / , * , level : HeadingLevelsType , style : typing . Optional [ OutputTypes ] = None , indent : bool = True , ) -> None : \"\"\"Prints headings in console. text : str, / Text to header. level : HeadingLevelsType, * Header level. style : typing.Optional[OutputTypes] = None, * If is not None, will change header style. indent : bool = True, * If True, will print new line after text. \"\"\" color = COLORS [ style ] if style else None line_char , show_line_above = HEADING_MAP [ level ] heading_line = line_char * len ( text ) if show_line_above : self . printer . print ( heading_line , bold = True , color = color ) self . printer . print ( text , bold = True , color = color ) self . printer . print ( heading_line , bold = True , color = color ) if indent : self . printer . print ()","title":"print_heading()"},{"location":"docs/output/#multibar.output.Output.print_success","text":"Prints text as success. PARAMETER DESCRIPTION text Text to print. TYPE: str bold: bool = True, * If True, will print text as bold. Source code in multibar\\output.py 200 201 202 203 204 205 206 207 208 209 210 211 212 @impure def print_success ( self , text : str , / , * , bold : bool = True ) -> None : \"\"\"Prints text as success. Parameters ---------- text: str, / Text to print. bold: bool = True, * If True, will print text as bold. \"\"\" self . printer . print ( text , color = COLORS [ SUCCESS ], bold = bold )","title":"print_success()"},{"location":"docs/output/#multibar.output.Output.print_warning","text":"Prints text as warning. PARAMETER DESCRIPTION text Text to print. TYPE: str Source code in multibar\\output.py 228 229 230 231 232 233 234 235 236 237 @impure def print_warning ( self , text : str , / ) -> None : \"\"\"Prints text as warning. Parameters ---------- text: str, / Text to print. \"\"\" self . printer . print ( text , color = COLORS [ WARNING ])","title":"print_warning()"},{"location":"docs/output/#multibar.output.Output.printer","text":"Cached property. RETURNS DESCRIPTION PrinterAware Printer implementation. Source code in multibar\\output.py 243 244 245 246 247 248 249 250 251 252 253 254 @utils . cached_property def printer ( self ) -> PrinterAware : \"\"\"Cached property. Returns ------- PrinterAware Printer implementation. \"\"\" if _PRINTER_KEY in settings . settings : return settings . settings [ _PRINTER_KEY ] return _PRINTER_STATE","title":"printer()"},{"location":"docs/output/#multibar.output.Output.update_printer","text":"Updates cache for printer cached_property. Source code in multibar\\output.py 239 240 241 def update_printer ( self ) -> None : \"\"\"Updates cache for printer cached_property.\"\"\" utils . cached_property . update_cache_for ( self , \"printer\" )","title":"update_printer()"},{"location":"docs/output/#multibar.output.PrinterAware","text":"Bases: abc . ABC Interface for printer implementations. Source code in multibar\\output.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class PrinterAware ( abc . ABC ): \"\"\"Interface for printer implementations.\"\"\" @typing . overload @abc . abstractmethod def print ( self ) -> IO [ None ]: ... @typing . overload @abc . abstractmethod def print ( self , text : str ) -> IO [ None ]: ... @typing . overload @abc . abstractmethod def print ( self , text : str , * , bold : bool , color : typing . Optional [ str ], newline : bool , ) -> IO [ None ]: ... @abc . abstractmethod def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console.\"\"\" ...","title":"PrinterAware"},{"location":"docs/output/#multibar.output.PrinterAware.print","text":"Prints text in console. Source code in multibar\\output.py 89 90 91 92 93 94 95 96 97 98 99 @abc . abstractmethod def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: \"\"\"Prints text in console.\"\"\" ...","title":"print()"},{"location":"docs/output/#multibar.output.TermcolorPrinter","text":"Bases: PrinterAware Source code in multibar\\output.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class TermcolorPrinter ( PrinterAware ): def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: # << inherited docstring from PrinterAware >> termcolor_attrs : list [ str ] = [] if bold : termcolor_attrs . append ( \"bold\" ) if newline : text += \" \\n \" termcolor . cprint ( text , color , attrs = termcolor_attrs ) return IO ( None )","title":"TermcolorPrinter"},{"location":"docs/output/#multibar.output.TermcolorPrinter.print","text":"Source code in multibar\\output.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def print ( self , text : str = \"\" , * , bold : bool = False , color : typing . Optional [ str ] = None , newline : bool = True , ) -> IO [ None ]: # << inherited docstring from PrinterAware >> termcolor_attrs : list [ str ] = [] if bold : termcolor_attrs . append ( \"bold\" ) if newline : text += \" \\n \" termcolor . cprint ( text , color , attrs = termcolor_attrs ) return IO ( None )","title":"print()"},{"location":"docs/quickstart/","text":"\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u0420\u0443\u0441\u0441\u043a\u0438\u0439 f","title":"Quickstart"},{"location":"docs/quickstart.ru/","text":"\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 English 2","title":"Quickstart.ru"},{"location":"docs/quickstart.uk/","text":"\u0420\u0443\u0441\u0441\u043a\u0438\u0439 English 1","title":"Quickstart.uk"},{"location":"docs/settings/","text":"classDiagram PInterface < |-- ProgressbarWriter : Implements SAbstraction < |-- Sector : Implements CInterface < |-- CalculationService : Implements SignatureSegment < -- Signature : Uses by default Signature --> PSProtocol : Matches SignatureSegment --> SSProtocol : Matches Sector --o ProgressbarWriter : By default CalculationService --o ProgressbarWriter : By default Signature --o ProgressbarWriter : By default PCInterface < |-- ProgressbarClient : Implements HInterface < |-- Hooks : Implements CMInterface < |-- ContractManager : Implements CMInterface --> ContractInterface : Interacts with Hooks --o ProgressbarClient : By default ContractManager --o ProgressbarClient : By default ProgressbarWriter --o ProgressbarClient : By default multibar.settings \u00a4 SelfT = typing . TypeVar ( 'SelfT' , bound = 'Settings' ) module-attribute \u00a4 __all__ = ( 'Settings' , 'settings' ) module-attribute \u00a4 settings = Settings () module-attribute \u00a4 Settings \u00a4 Multibar global settings. Source code in multibar\\settings.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Settings : \"\"\"Multibar global settings.\"\"\" __getattr__ = __getitem__ = _config_get_function def __init__ ( self ) -> None : self . _config : dict [ str , typing . Any ] = {} def __contains__ ( self , item : typing . Any ) -> bool : if not isinstance ( item , collections . abc . Hashable ): return item in self . _config . values () return item in self . _config def __copy__ ( self ) -> Settings : return self . copy () def copy ( self ) -> Settings : new_instance = self . __class__ () new_instance . configure ( ** self . _config ) return new_instance def configure ( self , ** kwargs : typing . Any ) -> None : self . _config . update ( kwargs ) __getattr__ = _config_get_function class-attribute \u00a4 __getitem__ = _config_get_function class-attribute \u00a4 __contains__ ( item ) \u00a4 Source code in multibar\\settings.py 25 26 27 28 def __contains__ ( self , item : typing . Any ) -> bool : if not isinstance ( item , collections . abc . Hashable ): return item in self . _config . values () return item in self . _config __copy__ () \u00a4 Source code in multibar\\settings.py 30 31 def __copy__ ( self ) -> Settings : return self . copy () __init__ () \u00a4 Source code in multibar\\settings.py 22 23 def __init__ ( self ) -> None : self . _config : dict [ str , typing . Any ] = {} configure ( ** kwargs ) \u00a4 Source code in multibar\\settings.py 38 39 def configure ( self , ** kwargs : typing . Any ) -> None : self . _config . update ( kwargs ) copy () \u00a4 Source code in multibar\\settings.py 33 34 35 36 def copy ( self ) -> Settings : new_instance = self . __class__ () new_instance . configure ( ** self . _config ) return new_instance","title":"Settings (English)"},{"location":"docs/settings/#multibar.settings","text":"","title":"settings"},{"location":"docs/settings/#multibar.settings.SelfT","text":"","title":"SelfT"},{"location":"docs/settings/#multibar.settings.__all__","text":"","title":"__all__"},{"location":"docs/settings/#multibar.settings.settings","text":"","title":"settings"},{"location":"docs/settings/#multibar.settings.Settings","text":"Multibar global settings. Source code in multibar\\settings.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Settings : \"\"\"Multibar global settings.\"\"\" __getattr__ = __getitem__ = _config_get_function def __init__ ( self ) -> None : self . _config : dict [ str , typing . Any ] = {} def __contains__ ( self , item : typing . Any ) -> bool : if not isinstance ( item , collections . abc . Hashable ): return item in self . _config . values () return item in self . _config def __copy__ ( self ) -> Settings : return self . copy () def copy ( self ) -> Settings : new_instance = self . __class__ () new_instance . configure ( ** self . _config ) return new_instance def configure ( self , ** kwargs : typing . Any ) -> None : self . _config . update ( kwargs )","title":"Settings"},{"location":"docs/settings/#multibar.settings.Settings.__getattr__","text":"","title":"__getattr__"},{"location":"docs/settings/#multibar.settings.Settings.__getitem__","text":"","title":"__getitem__"},{"location":"docs/settings/#multibar.settings.Settings.__contains__","text":"Source code in multibar\\settings.py 25 26 27 28 def __contains__ ( self , item : typing . Any ) -> bool : if not isinstance ( item , collections . abc . Hashable ): return item in self . _config . values () return item in self . _config","title":"__contains__()"},{"location":"docs/settings/#multibar.settings.Settings.__copy__","text":"Source code in multibar\\settings.py 30 31 def __copy__ ( self ) -> Settings : return self . copy ()","title":"__copy__()"},{"location":"docs/settings/#multibar.settings.Settings.__init__","text":"Source code in multibar\\settings.py 22 23 def __init__ ( self ) -> None : self . _config : dict [ str , typing . Any ] = {}","title":"__init__()"},{"location":"docs/settings/#multibar.settings.Settings.configure","text":"Source code in multibar\\settings.py 38 39 def configure ( self , ** kwargs : typing . Any ) -> None : self . _config . update ( kwargs )","title":"configure()"},{"location":"docs/settings/#multibar.settings.Settings.copy","text":"Source code in multibar\\settings.py 33 34 35 36 def copy ( self ) -> Settings : new_instance = self . __class__ () new_instance . configure ( ** self . _config ) return new_instance","title":"copy()"},{"location":"docs/types/","text":"85% 100% Goals 25% multibar.types \u00a4 __all__ = ( 'ProgressMetadataType' ) module-attribute \u00a4 ProgressMetadataType \u00a4 Bases: typing . TypedDict Source code in multibar\\types.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class ProgressMetadataType ( typing . TypedDict , total = False ): start_value : int \"\"\"Start value (current progress).\"\"\" end_value : int \"\"\"End value (needed progress).\"\"\" length : int \"\"\"Length of progressbar.\"\"\" sig : signatures . ProgressbarSignatureProtocol \"\"\"Progressbar signature.\"\"\" progressbar : typing . Optional [ progressbars . ProgressbarAware [ sectors . AbstractSector ]] \"\"\"Progressbar instance.\"\"\" calculation_service_cls : typing . Type [ calculation_service . AbstractCalculationService ] \"\"\"Math operations cls.\"\"\" calculation_service_cls : typing . Type [ calculation_service . AbstractCalculationService ] class-attribute \u00a4 Math operations cls. end_value : int class-attribute \u00a4 End value (needed progress). length : int class-attribute \u00a4 Length of progressbar. progressbar : typing . Optional [ progressbars . ProgressbarAware [ sectors . AbstractSector ]] class-attribute \u00a4 Progressbar instance. sig : signatures . ProgressbarSignatureProtocol class-attribute \u00a4 Progressbar signature. start_value : int class-attribute \u00a4 Start value (current progress).","title":"Types"},{"location":"docs/types/#multibar.types","text":"","title":"types"},{"location":"docs/types/#multibar.types.__all__","text":"","title":"__all__"},{"location":"docs/types/#multibar.types.ProgressMetadataType","text":"Bases: typing . TypedDict Source code in multibar\\types.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class ProgressMetadataType ( typing . TypedDict , total = False ): start_value : int \"\"\"Start value (current progress).\"\"\" end_value : int \"\"\"End value (needed progress).\"\"\" length : int \"\"\"Length of progressbar.\"\"\" sig : signatures . ProgressbarSignatureProtocol \"\"\"Progressbar signature.\"\"\" progressbar : typing . Optional [ progressbars . ProgressbarAware [ sectors . AbstractSector ]] \"\"\"Progressbar instance.\"\"\" calculation_service_cls : typing . Type [ calculation_service . AbstractCalculationService ] \"\"\"Math operations cls.\"\"\"","title":"ProgressMetadataType"},{"location":"docs/types/#multibar.types.ProgressMetadataType.calculation_service_cls","text":"Math operations cls.","title":"calculation_service_cls"},{"location":"docs/types/#multibar.types.ProgressMetadataType.end_value","text":"End value (needed progress).","title":"end_value"},{"location":"docs/types/#multibar.types.ProgressMetadataType.length","text":"Length of progressbar.","title":"length"},{"location":"docs/types/#multibar.types.ProgressMetadataType.progressbar","text":"Progressbar instance.","title":"progressbar"},{"location":"docs/types/#multibar.types.ProgressMetadataType.sig","text":"Progressbar signature.","title":"sig"},{"location":"docs/types/#multibar.types.ProgressMetadataType.start_value","text":"Start value (current progress).","title":"start_value"},{"location":"docs/utilities/","text":"Tab with a really long title 1 Tab with a really long title 2 Tab with a really long title 3 Lorem ipsum ullamco ea aute do sint cupidatat elit nostrud exercitation dolore culpa aliquip nisi commodo nisi qui magna non laborum proident id voluptate in cupidatat duis. Lorem ipsum ullamco ea aute do sint cupidatat elit nostrud exercitation dolore culpa aliquip nisi commodo nisi qui magna non laborum proident id voluptate in cupidatat duis1. Lorem ipsum ullamco ea aute do sint cupidatat elit nostrud exercitation dolore culpa aliquip nisi commodo nisi qui magna non laborum proident id voluptate in cupidatat duis2. Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 multibar.utils \u00a4 __all__ = ( 'none_or' , 'cached_property' ) module-attribute \u00a4 cached_property \u00a4 Source code in multibar\\utils.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class cached_property : def __init__ ( self , func : typing . Callable [ ... , typing . Any ], / ) -> None : self . func = func def __get__ ( self , instance : object , owner : typing . Optional [ typing . Type [ typing . Any ]] = None , ) -> typing . Any : result = instance . __dict__ [ self . func . __name__ ] = self . func ( instance ) return result @staticmethod def update_cache_for ( state : object , prop_name : str , / ) -> None : del state . __dict__ [ prop_name ] func = func instance-attribute \u00a4 __get__ ( instance , owner = None ) \u00a4 Source code in multibar\\utils.py 31 32 33 34 35 36 37 def __get__ ( self , instance : object , owner : typing . Optional [ typing . Type [ typing . Any ]] = None , ) -> typing . Any : result = instance . __dict__ [ self . func . __name__ ] = self . func ( instance ) return result __init__ ( func ) \u00a4 Source code in multibar\\utils.py 28 29 def __init__ ( self , func : typing . Callable [ ... , typing . Any ], / ) -> None : self . func = func update_cache_for ( state , prop_name ) staticmethod \u00a4 Source code in multibar\\utils.py 39 40 41 @staticmethod def update_cache_for ( state : object , prop_name : str , / ) -> None : del state . __dict__ [ prop_name ] none_or ( alternative , actual ) \u00a4 Source code in multibar\\utils.py 19 20 21 22 23 24 def none_or ( alternative : _AlternativeT , actual : typing . Union [ _ActualT , typing . Literal [ None ]], / ) -> typing . Union [ _AlternativeT , _ActualT ]: if actual is None : return alternative return actual Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"Utilities"},{"location":"docs/utilities/#multibar.utils","text":"","title":"utils"},{"location":"docs/utilities/#multibar.utils.__all__","text":"","title":"__all__"},{"location":"docs/utilities/#multibar.utils.cached_property","text":"Source code in multibar\\utils.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class cached_property : def __init__ ( self , func : typing . Callable [ ... , typing . Any ], / ) -> None : self . func = func def __get__ ( self , instance : object , owner : typing . Optional [ typing . Type [ typing . Any ]] = None , ) -> typing . Any : result = instance . __dict__ [ self . func . __name__ ] = self . func ( instance ) return result @staticmethod def update_cache_for ( state : object , prop_name : str , / ) -> None : del state . __dict__ [ prop_name ]","title":"cached_property"},{"location":"docs/utilities/#multibar.utils.cached_property.func","text":"","title":"func"},{"location":"docs/utilities/#multibar.utils.cached_property.__get__","text":"Source code in multibar\\utils.py 31 32 33 34 35 36 37 def __get__ ( self , instance : object , owner : typing . Optional [ typing . Type [ typing . Any ]] = None , ) -> typing . Any : result = instance . __dict__ [ self . func . __name__ ] = self . func ( instance ) return result","title":"__get__()"},{"location":"docs/utilities/#multibar.utils.cached_property.__init__","text":"Source code in multibar\\utils.py 28 29 def __init__ ( self , func : typing . Callable [ ... , typing . Any ], / ) -> None : self . func = func","title":"__init__()"},{"location":"docs/utilities/#multibar.utils.cached_property.update_cache_for","text":"Source code in multibar\\utils.py 39 40 41 @staticmethod def update_cache_for ( state : object , prop_name : str , / ) -> None : del state . __dict__ [ prop_name ]","title":"update_cache_for()"},{"location":"docs/utilities/#multibar.utils.none_or","text":"Source code in multibar\\utils.py 19 20 21 22 23 24 def none_or ( alternative : _AlternativeT , actual : typing . Union [ _ActualT , typing . Literal [ None ]], / ) -> typing . Union [ _AlternativeT , _ActualT ]: if actual is None : return alternative return actual Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"none_or()"},{"location":"docs/api/clients/","text":"multibar.api.clients \u00a4 __all__ = ( 'ProgressbarClientAware' ) module-attribute \u00a4 ProgressbarClientAware \u00a4 Bases: abc . ABC Interface for implementing a progress client that adds new features. Source code in multibar\\api\\clients.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class ProgressbarClientAware ( abc . ABC ): \"\"\"Interface for implementing a progress client that adds new features.\"\"\" __slots__ = () @abc . abstractmethod @typing . overload def get_progress ( self , start_value : int , end_value : int , / , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @abc . abstractmethod @typing . overload def get_progress ( self , start_value : int , end_value : int , / , * , length : int , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @abc . abstractmethod def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. Parameters ---------- start_value : int, / Start value (current progress) for progressbar math operations. end_value : int, / End value (needed progress) for progressbar math operations. length : int = 20, * Length of progressbar for progressbar math operations. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar instance. \"\"\" ... @abc . abstractmethod def set_hooks ( self , hooks : hooks_ . HooksAware ) -> ProgressbarClientAware : \"\"\"Sets hooks to the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to set. \"\"\" ... @abc . abstractmethod def update_hooks ( self , hooks : hooks_ . HooksAware ) -> ProgressbarClientAware : \"\"\"Updates hooks for the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to update. \"\"\" ... @property @abc . abstractmethod def hooks ( self ) -> hooks_ . HooksAware : \"\"\" Returns ------- hooks_.HooksAware Client hooks. \"\"\" ... @property @abc . abstractmethod def contract_manager ( self ) -> contracts . ContractManagerAware : \"\"\" Returns ------- contracts.ContractManagerAware Client contract manager for checks. \"\"\" ... @property @abc . abstractmethod def writer ( self ) -> writers . ProgressbarWriterAware : \"\"\" Returns ------- writers.ProgressbarWriterAware[sectors.AbstractSector] Progressbar writer for progress generating. \"\"\" ... __slots__ = () class-attribute \u00a4 contract_manager () property abstractmethod \u00a4 RETURNS DESCRIPTION contracts . ContractManagerAware Client contract manager for checks. Source code in multibar\\api\\clients.py 104 105 106 107 108 109 110 111 112 113 @property @abc . abstractmethod def contract_manager ( self ) -> contracts . ContractManagerAware : \"\"\" Returns ------- contracts.ContractManagerAware Client contract manager for checks. \"\"\" ... get_progress ( start_value , end_value , / , * , length = 20 ) abstractmethod \u00a4 Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. PARAMETER DESCRIPTION start_value Start value (current progress) for progressbar math operations. TYPE: int end_value : int, / End value (needed progress) for progressbar math operations. length : int = 20, * Length of progressbar for progressbar math operations. RETURNS DESCRIPTION progressbars . ProgressbarAware [ sectors . AbstractSector ] Progressbar instance. Source code in multibar\\api\\clients.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @abc . abstractmethod def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. Parameters ---------- start_value : int, / Start value (current progress) for progressbar math operations. end_value : int, / End value (needed progress) for progressbar math operations. length : int = 20, * Length of progressbar for progressbar math operations. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar instance. \"\"\" ... hooks () property abstractmethod \u00a4 RETURNS DESCRIPTION hooks_ . HooksAware Client hooks. Source code in multibar\\api\\clients.py 93 94 95 96 97 98 99 100 101 102 @property @abc . abstractmethod def hooks ( self ) -> hooks_ . HooksAware : \"\"\" Returns ------- hooks_.HooksAware Client hooks. \"\"\" ... set_hooks ( hooks ) abstractmethod \u00a4 Sets hooks to the client. PARAMETER DESCRIPTION hooks Any hooks to set. TYPE: hooks_ . HooksAware Source code in multibar\\api\\clients.py 71 72 73 74 75 76 77 78 79 80 @abc . abstractmethod def set_hooks ( self , hooks : hooks_ . HooksAware ) -> ProgressbarClientAware : \"\"\"Sets hooks to the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to set. \"\"\" ... update_hooks ( hooks ) abstractmethod \u00a4 Updates hooks for the client. PARAMETER DESCRIPTION hooks Any hooks to update. TYPE: hooks_ . HooksAware Source code in multibar\\api\\clients.py 82 83 84 85 86 87 88 89 90 91 @abc . abstractmethod def update_hooks ( self , hooks : hooks_ . HooksAware ) -> ProgressbarClientAware : \"\"\"Updates hooks for the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to update. \"\"\" ... writer () property abstractmethod \u00a4 RETURNS DESCRIPTION writers . ProgressbarWriterAware [ sectors . AbstractSector ] Progressbar writer for progress generating. Source code in multibar\\api\\clients.py 115 116 117 118 119 120 121 122 123 124 @property @abc . abstractmethod def writer ( self ) -> writers . ProgressbarWriterAware : \"\"\" Returns ------- writers.ProgressbarWriterAware[sectors.AbstractSector] Progressbar writer for progress generating. \"\"\" ...","title":"Clients"},{"location":"docs/api/clients/#multibar.api.clients","text":"","title":"clients"},{"location":"docs/api/clients/#multibar.api.clients.__all__","text":"","title":"__all__"},{"location":"docs/api/clients/#multibar.api.clients.ProgressbarClientAware","text":"Bases: abc . ABC Interface for implementing a progress client that adds new features. Source code in multibar\\api\\clients.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class ProgressbarClientAware ( abc . ABC ): \"\"\"Interface for implementing a progress client that adds new features.\"\"\" __slots__ = () @abc . abstractmethod @typing . overload def get_progress ( self , start_value : int , end_value : int , / , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @abc . abstractmethod @typing . overload def get_progress ( self , start_value : int , end_value : int , / , * , length : int , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @abc . abstractmethod def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. Parameters ---------- start_value : int, / Start value (current progress) for progressbar math operations. end_value : int, / End value (needed progress) for progressbar math operations. length : int = 20, * Length of progressbar for progressbar math operations. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar instance. \"\"\" ... @abc . abstractmethod def set_hooks ( self , hooks : hooks_ . HooksAware ) -> ProgressbarClientAware : \"\"\"Sets hooks to the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to set. \"\"\" ... @abc . abstractmethod def update_hooks ( self , hooks : hooks_ . HooksAware ) -> ProgressbarClientAware : \"\"\"Updates hooks for the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to update. \"\"\" ... @property @abc . abstractmethod def hooks ( self ) -> hooks_ . HooksAware : \"\"\" Returns ------- hooks_.HooksAware Client hooks. \"\"\" ... @property @abc . abstractmethod def contract_manager ( self ) -> contracts . ContractManagerAware : \"\"\" Returns ------- contracts.ContractManagerAware Client contract manager for checks. \"\"\" ... @property @abc . abstractmethod def writer ( self ) -> writers . ProgressbarWriterAware : \"\"\" Returns ------- writers.ProgressbarWriterAware[sectors.AbstractSector] Progressbar writer for progress generating. \"\"\" ...","title":"ProgressbarClientAware"},{"location":"docs/api/clients/#multibar.api.clients.ProgressbarClientAware.__slots__","text":"","title":"__slots__"},{"location":"docs/api/clients/#multibar.api.clients.ProgressbarClientAware.contract_manager","text":"RETURNS DESCRIPTION contracts . ContractManagerAware Client contract manager for checks. Source code in multibar\\api\\clients.py 104 105 106 107 108 109 110 111 112 113 @property @abc . abstractmethod def contract_manager ( self ) -> contracts . ContractManagerAware : \"\"\" Returns ------- contracts.ContractManagerAware Client contract manager for checks. \"\"\" ...","title":"contract_manager()"},{"location":"docs/api/clients/#multibar.api.clients.ProgressbarClientAware.get_progress","text":"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. PARAMETER DESCRIPTION start_value Start value (current progress) for progressbar math operations. TYPE: int end_value : int, / End value (needed progress) for progressbar math operations. length : int = 20, * Length of progressbar for progressbar math operations. RETURNS DESCRIPTION progressbars . ProgressbarAware [ sectors . AbstractSector ] Progressbar instance. Source code in multibar\\api\\clients.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @abc . abstractmethod def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Generates a progressbar, can be a wrapper for ProgressWriterAware.write() to implement hooks and various kinds of checks. Parameters ---------- start_value : int, / Start value (current progress) for progressbar math operations. end_value : int, / End value (needed progress) for progressbar math operations. length : int = 20, * Length of progressbar for progressbar math operations. Returns ------- progressbars.ProgressbarAware[sectors.AbstractSector] Progressbar instance. \"\"\" ...","title":"get_progress()"},{"location":"docs/api/clients/#multibar.api.clients.ProgressbarClientAware.hooks","text":"RETURNS DESCRIPTION hooks_ . HooksAware Client hooks. Source code in multibar\\api\\clients.py 93 94 95 96 97 98 99 100 101 102 @property @abc . abstractmethod def hooks ( self ) -> hooks_ . HooksAware : \"\"\" Returns ------- hooks_.HooksAware Client hooks. \"\"\" ...","title":"hooks()"},{"location":"docs/api/clients/#multibar.api.clients.ProgressbarClientAware.set_hooks","text":"Sets hooks to the client. PARAMETER DESCRIPTION hooks Any hooks to set. TYPE: hooks_ . HooksAware Source code in multibar\\api\\clients.py 71 72 73 74 75 76 77 78 79 80 @abc . abstractmethod def set_hooks ( self , hooks : hooks_ . HooksAware ) -> ProgressbarClientAware : \"\"\"Sets hooks to the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to set. \"\"\" ...","title":"set_hooks()"},{"location":"docs/api/clients/#multibar.api.clients.ProgressbarClientAware.update_hooks","text":"Updates hooks for the client. PARAMETER DESCRIPTION hooks Any hooks to update. TYPE: hooks_ . HooksAware Source code in multibar\\api\\clients.py 82 83 84 85 86 87 88 89 90 91 @abc . abstractmethod def update_hooks ( self , hooks : hooks_ . HooksAware ) -> ProgressbarClientAware : \"\"\"Updates hooks for the client. Parameters ---------- hooks : hooks_.HooksAware Any hooks to update. \"\"\" ...","title":"update_hooks()"},{"location":"docs/api/clients/#multibar.api.clients.ProgressbarClientAware.writer","text":"RETURNS DESCRIPTION writers . ProgressbarWriterAware [ sectors . AbstractSector ] Progressbar writer for progress generating. Source code in multibar\\api\\clients.py 115 116 117 118 119 120 121 122 123 124 @property @abc . abstractmethod def writer ( self ) -> writers . ProgressbarWriterAware : \"\"\" Returns ------- writers.ProgressbarWriterAware[sectors.AbstractSector] Progressbar writer for progress generating. \"\"\" ...","title":"writer()"},{"location":"docs/api/contracts/","text":"multibar.api.contracts \u00a4 __all__ = ( 'ContractAware' , 'ContractCheck' , 'ContractManagerAware' ) module-attribute \u00a4 ContractAware \u00a4 Bases: abc . ABC Interface for contract implementations. Source code in multibar\\api\\contracts.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class ContractAware ( abc . ABC ): \"\"\"Interface for contract implementations.\"\"\" __slots__ = () @abc . abstractmethod def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> ContractCheck : \"\"\"Checks contract for errors and warnings. Parameters ---------- *args : typing.Any Arguments to check. **kwargs : typing.Any Keyword arguments to check. Returns ------- ContractCheck Contract response. \"\"\" ... @impure @abc . abstractmethod def render_terminated_contract ( self , check : ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : \"\"\"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- check : ContractCheck Contract response. raise_errors : bool If True, will raise errors when contract is broken. \"\"\" ... __slots__ = () class-attribute \u00a4 check ( * args , ** kwargs ) abstractmethod \u00a4 Checks contract for errors and warnings. PARAMETER DESCRIPTION *args Arguments to check. TYPE: typing . Any DEFAULT: () **kwargs : typing.Any Keyword arguments to check. RETURNS DESCRIPTION ContractCheck Contract response. Source code in multibar\\api\\contracts.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 @abc . abstractmethod def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> ContractCheck : \"\"\"Checks contract for errors and warnings. Parameters ---------- *args : typing.Any Arguments to check. **kwargs : typing.Any Keyword arguments to check. Returns ------- ContractCheck Contract response. \"\"\" ... render_terminated_contract ( check , / , * , raise_errors ) abstractmethod \u00a4 Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. PARAMETER DESCRIPTION check Contract response. TYPE: ContractCheck raise_errors : bool If True, will raise errors when contract is broken. Source code in multibar\\api\\contracts.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 @impure @abc . abstractmethod def render_terminated_contract ( self , check : ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : \"\"\"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- check : ContractCheck Contract response. raise_errors : bool If True, will raise errors when contract is broken. \"\"\" ... ContractCheck dataclass \u00a4 Response for contracts. Source code in multibar\\api\\contracts.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @dataclasses . dataclass class ContractCheck : \"\"\"Response for contracts.\"\"\" kept : bool \"\"\"True if the contract is not broken (contains no errors or warnings).\"\"\" metadata : typing . MutableMapping [ typing . Any , typing . Any ] = dataclasses . field ( default_factory = dict ) \"\"\"Contract metadata to check.\"\"\" warnings : list [ str ] = dataclasses . field ( default_factory = list ) \"\"\"Contract warnings.\"\"\" errors : list [ str ] = dataclasses . field ( default_factory = list ) \"\"\"Contract errors.\"\"\" @classmethod def done ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , ) -> ContractCheck : \"\"\"If contract kept. Alternative constructor. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. \"\"\" return cls ( kept = True , metadata = utils . none_or ({}, metadata )) @classmethod @typing . no_type_check def terminated ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , warnings : typing . Optional [ list [ str ]] = None , errors : typing . Optional [ list [ str ]] = None , ) -> ContractCheck : \"\"\"If contract is broken. Alternative constructor. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. warnings : typing.Optional[list[str]] = None Warnings to return. errors : typing.Optional[list[str]] = None Errors to return. \"\"\" return cls ( kept = False , metadata = utils . none_or ({}, metadata ), warnings = utils . none_or ([], warnings ), errors = utils . none_or ([], errors ), ) errors : list [ str ] = dataclasses . field ( default_factory = list ) class-attribute \u00a4 Contract errors. kept : bool class-attribute \u00a4 True if the contract is not broken (contains no errors or warnings). metadata : typing . MutableMapping [ typing . Any , typing . Any ] = dataclasses . field ( default_factory = dict ) class-attribute \u00a4 Contract metadata to check. warnings : list [ str ] = dataclasses . field ( default_factory = list ) class-attribute \u00a4 Contract warnings. done ( metadata = None ) classmethod \u00a4 If contract kept. Alternative constructor. PARAMETER DESCRIPTION metadata Contract metadata to return. TYPE: typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] DEFAULT: None Source code in multibar\\api\\contracts.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @classmethod def done ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , ) -> ContractCheck : \"\"\"If contract kept. Alternative constructor. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. \"\"\" return cls ( kept = True , metadata = utils . none_or ({}, metadata )) terminated ( metadata = None , warnings = None , errors = None ) classmethod \u00a4 If contract is broken. Alternative constructor. PARAMETER DESCRIPTION metadata Contract metadata to return. TYPE: typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] DEFAULT: None warnings : typing.Optional[list[str]] = None Warnings to return. errors : typing.Optional[list[str]] = None Errors to return. Source code in multibar\\api\\contracts.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @classmethod @typing . no_type_check def terminated ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , warnings : typing . Optional [ list [ str ]] = None , errors : typing . Optional [ list [ str ]] = None , ) -> ContractCheck : \"\"\"If contract is broken. Alternative constructor. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. warnings : typing.Optional[list[str]] = None Warnings to return. errors : typing.Optional[list[str]] = None Errors to return. \"\"\" return cls ( kept = False , metadata = utils . none_or ({}, metadata ), warnings = utils . none_or ([], warnings ), errors = utils . none_or ([], errors ), ) ContractManagerAware \u00a4 Bases: abc . ABC Interface for contract manager implementations. Source code in multibar\\api\\contracts.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 class ContractManagerAware ( abc . ABC ): \"\"\"Interface for contract manager implementations.\"\"\" __slots__ = () @abc . abstractmethod def check_contract ( self , contract : ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : \"\"\"Checks contract for any errors or warnings. Parameters ---------- contract : ContractAware, / Contract to check. *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. \"\"\" ... @abc . abstractmethod def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Checks all contracts. *args: typing.Any Arguments to contracts check. **kwargs: typing.Any Keyword arguments to contracts check. \"\"\" ... @abc . abstractmethod def subscribe ( self , contract : ContractAware , / ) -> None : \"\"\"Subscribes for contract. Parameters ---------- contract : ContractAware, / Contract to subscribe. \"\"\" ... @abc . abstractmethod def terminate ( self , contract : ContractAware , / ) -> None : \"\"\"Terminates any contract. Parameters ---------- contract : ContractAware, / Contract to terminate. \"\"\" ... @abc . abstractmethod def terminate_all ( self ) -> None : \"\"\"Terminates all contracts.\"\"\" ... @abc . abstractmethod def set_raise_errors ( self , value : bool , / ) -> None : \"\"\"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- value : bool, / Raise errors boolean value. \"\"\" ... @property @abc . abstractmethod def contracts ( self ) -> collections . abc . Sequence [ ContractAware ]: \"\"\" Returns ------- collections.abc.Sequence[ContractAware] Sequence of the contracts. \"\"\" ... @property @abc . abstractmethod def raise_errors ( self ) -> bool : \"\"\" Returns ------- bool Raise errors boolean value. \"\"\" ... __slots__ = () class-attribute \u00a4 check_contract ( contract , / , * args , ** kwargs ) abstractmethod \u00a4 Checks contract for any errors or warnings. PARAMETER DESCRIPTION contract Contract to check. TYPE: ContractAware *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. Source code in multibar\\api\\contracts.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @abc . abstractmethod def check_contract ( self , contract : ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : \"\"\"Checks contract for any errors or warnings. Parameters ---------- contract : ContractAware, / Contract to check. *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. \"\"\" ... check_contracts ( * args , ** kwargs ) abstractmethod \u00a4 Checks all contracts. *args: typing.Any Arguments to contracts check. **kwargs: typing.Any Keyword arguments to contracts check. Source code in multibar\\api\\contracts.py 156 157 158 159 160 161 162 163 164 165 166 @abc . abstractmethod def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Checks all contracts. *args: typing.Any Arguments to contracts check. **kwargs: typing.Any Keyword arguments to contracts check. \"\"\" ... contracts () property abstractmethod \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ ContractAware ] Sequence of the contracts. Source code in multibar\\api\\contracts.py 208 209 210 211 212 213 214 215 216 217 @property @abc . abstractmethod def contracts ( self ) -> collections . abc . Sequence [ ContractAware ]: \"\"\" Returns ------- collections.abc.Sequence[ContractAware] Sequence of the contracts. \"\"\" ... raise_errors () property abstractmethod \u00a4 RETURNS DESCRIPTION bool Raise errors boolean value. Source code in multibar\\api\\contracts.py 219 220 221 222 223 224 225 226 227 228 @property @abc . abstractmethod def raise_errors ( self ) -> bool : \"\"\" Returns ------- bool Raise errors boolean value. \"\"\" ... set_raise_errors ( value ) abstractmethod \u00a4 Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. PARAMETER DESCRIPTION value Raise errors boolean value. TYPE: bool Source code in multibar\\api\\contracts.py 195 196 197 198 199 200 201 202 203 204 205 206 @abc . abstractmethod def set_raise_errors ( self , value : bool , / ) -> None : \"\"\"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- value : bool, / Raise errors boolean value. \"\"\" ... subscribe ( contract ) abstractmethod \u00a4 Subscribes for contract. PARAMETER DESCRIPTION contract Contract to subscribe. TYPE: ContractAware Source code in multibar\\api\\contracts.py 168 169 170 171 172 173 174 175 176 177 @abc . abstractmethod def subscribe ( self , contract : ContractAware , / ) -> None : \"\"\"Subscribes for contract. Parameters ---------- contract : ContractAware, / Contract to subscribe. \"\"\" ... terminate ( contract ) abstractmethod \u00a4 Terminates any contract. PARAMETER DESCRIPTION contract Contract to terminate. TYPE: ContractAware Source code in multibar\\api\\contracts.py 179 180 181 182 183 184 185 186 187 188 @abc . abstractmethod def terminate ( self , contract : ContractAware , / ) -> None : \"\"\"Terminates any contract. Parameters ---------- contract : ContractAware, / Contract to terminate. \"\"\" ... terminate_all () abstractmethod \u00a4 Terminates all contracts. Source code in multibar\\api\\contracts.py 190 191 192 193 @abc . abstractmethod def terminate_all ( self ) -> None : \"\"\"Terminates all contracts.\"\"\" ...","title":"Contracts"},{"location":"docs/api/contracts/#multibar.api.contracts","text":"","title":"contracts"},{"location":"docs/api/contracts/#multibar.api.contracts.__all__","text":"","title":"__all__"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractAware","text":"Bases: abc . ABC Interface for contract implementations. Source code in multibar\\api\\contracts.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class ContractAware ( abc . ABC ): \"\"\"Interface for contract implementations.\"\"\" __slots__ = () @abc . abstractmethod def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> ContractCheck : \"\"\"Checks contract for errors and warnings. Parameters ---------- *args : typing.Any Arguments to check. **kwargs : typing.Any Keyword arguments to check. Returns ------- ContractCheck Contract response. \"\"\" ... @impure @abc . abstractmethod def render_terminated_contract ( self , check : ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : \"\"\"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- check : ContractCheck Contract response. raise_errors : bool If True, will raise errors when contract is broken. \"\"\" ...","title":"ContractAware"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractAware.__slots__","text":"","title":"__slots__"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractAware.check","text":"Checks contract for errors and warnings. PARAMETER DESCRIPTION *args Arguments to check. TYPE: typing . Any DEFAULT: () **kwargs : typing.Any Keyword arguments to check. RETURNS DESCRIPTION ContractCheck Contract response. Source code in multibar\\api\\contracts.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 @abc . abstractmethod def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> ContractCheck : \"\"\"Checks contract for errors and warnings. Parameters ---------- *args : typing.Any Arguments to check. **kwargs : typing.Any Keyword arguments to check. Returns ------- ContractCheck Contract response. \"\"\" ...","title":"check()"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractAware.render_terminated_contract","text":"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. PARAMETER DESCRIPTION check Contract response. TYPE: ContractCheck raise_errors : bool If True, will raise errors when contract is broken. Source code in multibar\\api\\contracts.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 @impure @abc . abstractmethod def render_terminated_contract ( self , check : ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : \"\"\"Renders broken contract. May contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- check : ContractCheck Contract response. raise_errors : bool If True, will raise errors when contract is broken. \"\"\" ...","title":"render_terminated_contract()"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractCheck","text":"Response for contracts. Source code in multibar\\api\\contracts.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @dataclasses . dataclass class ContractCheck : \"\"\"Response for contracts.\"\"\" kept : bool \"\"\"True if the contract is not broken (contains no errors or warnings).\"\"\" metadata : typing . MutableMapping [ typing . Any , typing . Any ] = dataclasses . field ( default_factory = dict ) \"\"\"Contract metadata to check.\"\"\" warnings : list [ str ] = dataclasses . field ( default_factory = list ) \"\"\"Contract warnings.\"\"\" errors : list [ str ] = dataclasses . field ( default_factory = list ) \"\"\"Contract errors.\"\"\" @classmethod def done ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , ) -> ContractCheck : \"\"\"If contract kept. Alternative constructor. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. \"\"\" return cls ( kept = True , metadata = utils . none_or ({}, metadata )) @classmethod @typing . no_type_check def terminated ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , warnings : typing . Optional [ list [ str ]] = None , errors : typing . Optional [ list [ str ]] = None , ) -> ContractCheck : \"\"\"If contract is broken. Alternative constructor. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. warnings : typing.Optional[list[str]] = None Warnings to return. errors : typing.Optional[list[str]] = None Errors to return. \"\"\" return cls ( kept = False , metadata = utils . none_or ({}, metadata ), warnings = utils . none_or ([], warnings ), errors = utils . none_or ([], errors ), )","title":"ContractCheck"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractCheck.errors","text":"Contract errors.","title":"errors"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractCheck.kept","text":"True if the contract is not broken (contains no errors or warnings).","title":"kept"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractCheck.metadata","text":"Contract metadata to check.","title":"metadata"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractCheck.warnings","text":"Contract warnings.","title":"warnings"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractCheck.done","text":"If contract kept. Alternative constructor. PARAMETER DESCRIPTION metadata Contract metadata to return. TYPE: typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] DEFAULT: None Source code in multibar\\api\\contracts.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @classmethod def done ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , ) -> ContractCheck : \"\"\"If contract kept. Alternative constructor. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. \"\"\" return cls ( kept = True , metadata = utils . none_or ({}, metadata ))","title":"done()"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractCheck.terminated","text":"If contract is broken. Alternative constructor. PARAMETER DESCRIPTION metadata Contract metadata to return. TYPE: typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] DEFAULT: None warnings : typing.Optional[list[str]] = None Warnings to return. errors : typing.Optional[list[str]] = None Errors to return. Source code in multibar\\api\\contracts.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @classmethod @typing . no_type_check def terminated ( cls , metadata : typing . Optional [ typing . MutableMapping [ typing . Any , typing . Any ]] = None , warnings : typing . Optional [ list [ str ]] = None , errors : typing . Optional [ list [ str ]] = None , ) -> ContractCheck : \"\"\"If contract is broken. Alternative constructor. Parameters ---------- metadata : typing.Optional[typing.MutableMapping[typing.Any, typing.Any]] = None Contract metadata to return. warnings : typing.Optional[list[str]] = None Warnings to return. errors : typing.Optional[list[str]] = None Errors to return. \"\"\" return cls ( kept = False , metadata = utils . none_or ({}, metadata ), warnings = utils . none_or ([], warnings ), errors = utils . none_or ([], errors ), )","title":"terminated()"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractManagerAware","text":"Bases: abc . ABC Interface for contract manager implementations. Source code in multibar\\api\\contracts.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 class ContractManagerAware ( abc . ABC ): \"\"\"Interface for contract manager implementations.\"\"\" __slots__ = () @abc . abstractmethod def check_contract ( self , contract : ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : \"\"\"Checks contract for any errors or warnings. Parameters ---------- contract : ContractAware, / Contract to check. *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. \"\"\" ... @abc . abstractmethod def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Checks all contracts. *args: typing.Any Arguments to contracts check. **kwargs: typing.Any Keyword arguments to contracts check. \"\"\" ... @abc . abstractmethod def subscribe ( self , contract : ContractAware , / ) -> None : \"\"\"Subscribes for contract. Parameters ---------- contract : ContractAware, / Contract to subscribe. \"\"\" ... @abc . abstractmethod def terminate ( self , contract : ContractAware , / ) -> None : \"\"\"Terminates any contract. Parameters ---------- contract : ContractAware, / Contract to terminate. \"\"\" ... @abc . abstractmethod def terminate_all ( self ) -> None : \"\"\"Terminates all contracts.\"\"\" ... @abc . abstractmethod def set_raise_errors ( self , value : bool , / ) -> None : \"\"\"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- value : bool, / Raise errors boolean value. \"\"\" ... @property @abc . abstractmethod def contracts ( self ) -> collections . abc . Sequence [ ContractAware ]: \"\"\" Returns ------- collections.abc.Sequence[ContractAware] Sequence of the contracts. \"\"\" ... @property @abc . abstractmethod def raise_errors ( self ) -> bool : \"\"\" Returns ------- bool Raise errors boolean value. \"\"\" ...","title":"ContractManagerAware"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractManagerAware.__slots__","text":"","title":"__slots__"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractManagerAware.check_contract","text":"Checks contract for any errors or warnings. PARAMETER DESCRIPTION contract Contract to check. TYPE: ContractAware *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. Source code in multibar\\api\\contracts.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @abc . abstractmethod def check_contract ( self , contract : ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : \"\"\"Checks contract for any errors or warnings. Parameters ---------- contract : ContractAware, / Contract to check. *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. \"\"\" ...","title":"check_contract()"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractManagerAware.check_contracts","text":"Checks all contracts. *args: typing.Any Arguments to contracts check. **kwargs: typing.Any Keyword arguments to contracts check. Source code in multibar\\api\\contracts.py 156 157 158 159 160 161 162 163 164 165 166 @abc . abstractmethod def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Checks all contracts. *args: typing.Any Arguments to contracts check. **kwargs: typing.Any Keyword arguments to contracts check. \"\"\" ...","title":"check_contracts()"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractManagerAware.contracts","text":"RETURNS DESCRIPTION collections . abc . Sequence [ ContractAware ] Sequence of the contracts. Source code in multibar\\api\\contracts.py 208 209 210 211 212 213 214 215 216 217 @property @abc . abstractmethod def contracts ( self ) -> collections . abc . Sequence [ ContractAware ]: \"\"\" Returns ------- collections.abc.Sequence[ContractAware] Sequence of the contracts. \"\"\" ...","title":"contracts()"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractManagerAware.raise_errors","text":"RETURNS DESCRIPTION bool Raise errors boolean value. Source code in multibar\\api\\contracts.py 219 220 221 222 223 224 225 226 227 228 @property @abc . abstractmethod def raise_errors ( self ) -> bool : \"\"\" Returns ------- bool Raise errors boolean value. \"\"\" ...","title":"raise_errors()"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractManagerAware.set_raise_errors","text":"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. PARAMETER DESCRIPTION value Raise errors boolean value. TYPE: bool Source code in multibar\\api\\contracts.py 195 196 197 198 199 200 201 202 203 204 205 206 @abc . abstractmethod def set_raise_errors ( self , value : bool , / ) -> None : \"\"\"Render broken contract may contain IO operations if raise_errors is False. Otherwise, it returns nothing, but throws an error. Parameters ---------- value : bool, / Raise errors boolean value. \"\"\" ...","title":"set_raise_errors()"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractManagerAware.subscribe","text":"Subscribes for contract. PARAMETER DESCRIPTION contract Contract to subscribe. TYPE: ContractAware Source code in multibar\\api\\contracts.py 168 169 170 171 172 173 174 175 176 177 @abc . abstractmethod def subscribe ( self , contract : ContractAware , / ) -> None : \"\"\"Subscribes for contract. Parameters ---------- contract : ContractAware, / Contract to subscribe. \"\"\" ...","title":"subscribe()"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractManagerAware.terminate","text":"Terminates any contract. PARAMETER DESCRIPTION contract Contract to terminate. TYPE: ContractAware Source code in multibar\\api\\contracts.py 179 180 181 182 183 184 185 186 187 188 @abc . abstractmethod def terminate ( self , contract : ContractAware , / ) -> None : \"\"\"Terminates any contract. Parameters ---------- contract : ContractAware, / Contract to terminate. \"\"\" ...","title":"terminate()"},{"location":"docs/api/contracts/#multibar.api.contracts.ContractManagerAware.terminate_all","text":"Terminates all contracts. Source code in multibar\\api\\contracts.py 190 191 192 193 @abc . abstractmethod def terminate_all ( self ) -> None : \"\"\"Terminates all contracts.\"\"\" ...","title":"terminate_all()"},{"location":"docs/api/hooks/","text":"multibar.api.hooks \u00a4 HookSignatureType : typing_extensions . TypeAlias = typing . Callable [ Ellipsis , typing . Optional [ bool ]] module-attribute \u00a4 __all__ = ( 'HookSignatureType' , 'HooksAware' ) module-attribute \u00a4 HooksAware \u00a4 Bases: abc . ABC Interface to progress hooks implementation. Source code in multibar\\api\\hooks.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 class HooksAware ( abc . ABC ): \"\"\"Interface to progress hooks implementation.\"\"\" __slots__ = () @abc . abstractmethod def __len__ ( self ) -> int : \"\"\"Returns length of all hooks. Used for bool() and len() operations.\"\"\" ... @abc . abstractmethod def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> HooksAware : \"\"\"Adds hooks to the client. Parameters ---------- client : clients.ProgressbarClientAware, / Client to add. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def update ( self , other : HooksAware , / ) -> HooksAware : \"\"\"Updates self hooks from other hooks object. Parameters ---------- other : HooksAware, / Other hooks object to update. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def add_pre_execution ( self , callback : HookSignatureType , / ) -> HooksAware : \"\"\"Adds pre-execution callback. Parameters ---------- callback : HookSignatureType, / Pre-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def add_post_execution ( self , callback : HookSignatureType , / ) -> HooksAware : \"\"\"Adds post-execution callback. Parameters ---------- callback : HookSignatureType, / Post-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def add_on_error ( self , callback : HookSignatureType , / ) -> HooksAware : \"\"\"Adds on-error callback. Parameters ---------- callback : HookSignatureType, / On-error callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all post-execution callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. \"\"\" ... @abc . abstractmethod def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all pre-execution callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. \"\"\" ... @abc . abstractmethod def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all on-error callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. \"\"\" ... @property @abc . abstractmethod def pre_execution_hooks ( self ) -> collections . abc . Sequence [ HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of pre-execution hooks. \"\"\" ... @property @abc . abstractmethod def post_execution_hooks ( self ) -> collections . abc . Sequence [ HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of post-execution hooks. \"\"\" ... @property @abc . abstractmethod def on_error_hooks ( self ) -> collections . abc . Sequence [ HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of on-error hooks. \"\"\" ... __slots__ = () class-attribute \u00a4 __len__ () abstractmethod \u00a4 Returns length of all hooks. Used for bool() and len() operations. Source code in multibar\\api\\hooks.py 25 26 27 28 @abc . abstractmethod def __len__ ( self ) -> int : \"\"\"Returns length of all hooks. Used for bool() and len() operations.\"\"\" ... add_on_error ( callback ) abstractmethod \u00a4 Adds on-error callback. PARAMETER DESCRIPTION callback On-error callback. TYPE: HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @abc . abstractmethod def add_on_error ( self , callback : HookSignatureType , / ) -> HooksAware : \"\"\"Adds on-error callback. Parameters ---------- callback : HookSignatureType, / On-error callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... add_post_execution ( callback ) abstractmethod \u00a4 Adds post-execution callback. PARAMETER DESCRIPTION callback Post-execution callback. TYPE: HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @abc . abstractmethod def add_post_execution ( self , callback : HookSignatureType , / ) -> HooksAware : \"\"\"Adds post-execution callback. Parameters ---------- callback : HookSignatureType, / Post-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... add_pre_execution ( callback ) abstractmethod \u00a4 Adds pre-execution callback. PARAMETER DESCRIPTION callback Pre-execution callback. TYPE: HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @abc . abstractmethod def add_pre_execution ( self , callback : HookSignatureType , / ) -> HooksAware : \"\"\"Adds pre-execution callback. Parameters ---------- callback : HookSignatureType, / Pre-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... add_to_client ( client ) abstractmethod \u00a4 Adds hooks to the client. PARAMETER DESCRIPTION client Client to add. TYPE: clients . ProgressbarClientAware RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @abc . abstractmethod def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> HooksAware : \"\"\"Adds hooks to the client. Parameters ---------- client : clients.ProgressbarClientAware, / Client to add. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... on_error_hooks () property abstractmethod \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ HookSignatureType ] Sequence of on-error hooks. Source code in multibar\\api\\hooks.py 168 169 170 171 172 173 174 175 176 177 @property @abc . abstractmethod def on_error_hooks ( self ) -> collections . abc . Sequence [ HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of on-error hooks. \"\"\" ... post_execution_hooks () property abstractmethod \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ HookSignatureType ] Sequence of post-execution hooks. Source code in multibar\\api\\hooks.py 157 158 159 160 161 162 163 164 165 166 @property @abc . abstractmethod def post_execution_hooks ( self ) -> collections . abc . Sequence [ HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of post-execution hooks. \"\"\" ... pre_execution_hooks () property abstractmethod \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ HookSignatureType ] Sequence of pre-execution hooks. Source code in multibar\\api\\hooks.py 146 147 148 149 150 151 152 153 154 155 @property @abc . abstractmethod def pre_execution_hooks ( self ) -> collections . abc . Sequence [ HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of pre-execution hooks. \"\"\" ... trigger_on_error ( * args , ** kwargs ) abstractmethod \u00a4 Triggers all on-error callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Source code in multibar\\api\\hooks.py 134 135 136 137 138 139 140 141 142 143 144 @abc . abstractmethod def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all on-error callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. \"\"\" ... trigger_post_execution ( * args , ** kwargs ) abstractmethod \u00a4 Triggers all post-execution callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Source code in multibar\\api\\hooks.py 110 111 112 113 114 115 116 117 118 119 120 @abc . abstractmethod def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all post-execution callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. \"\"\" ... trigger_pre_execution ( * args , ** kwargs ) abstractmethod \u00a4 Triggers all pre-execution callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Source code in multibar\\api\\hooks.py 122 123 124 125 126 127 128 129 130 131 132 @abc . abstractmethod def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all pre-execution callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. \"\"\" ... update ( other ) abstractmethod \u00a4 Updates self hooks from other hooks object. PARAMETER DESCRIPTION other Other hooks object to update. TYPE: HooksAware RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @abc . abstractmethod def update ( self , other : HooksAware , / ) -> HooksAware : \"\"\"Updates self hooks from other hooks object. Parameters ---------- other : HooksAware, / Other hooks object to update. Returns ------- Self The hook object to allow fluent-style. \"\"\" ...","title":"Hooks"},{"location":"docs/api/hooks/#multibar.api.hooks","text":"","title":"hooks"},{"location":"docs/api/hooks/#multibar.api.hooks.HookSignatureType","text":"","title":"HookSignatureType"},{"location":"docs/api/hooks/#multibar.api.hooks.__all__","text":"","title":"__all__"},{"location":"docs/api/hooks/#multibar.api.hooks.HooksAware","text":"Bases: abc . ABC Interface to progress hooks implementation. Source code in multibar\\api\\hooks.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 class HooksAware ( abc . ABC ): \"\"\"Interface to progress hooks implementation.\"\"\" __slots__ = () @abc . abstractmethod def __len__ ( self ) -> int : \"\"\"Returns length of all hooks. Used for bool() and len() operations.\"\"\" ... @abc . abstractmethod def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> HooksAware : \"\"\"Adds hooks to the client. Parameters ---------- client : clients.ProgressbarClientAware, / Client to add. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def update ( self , other : HooksAware , / ) -> HooksAware : \"\"\"Updates self hooks from other hooks object. Parameters ---------- other : HooksAware, / Other hooks object to update. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def add_pre_execution ( self , callback : HookSignatureType , / ) -> HooksAware : \"\"\"Adds pre-execution callback. Parameters ---------- callback : HookSignatureType, / Pre-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def add_post_execution ( self , callback : HookSignatureType , / ) -> HooksAware : \"\"\"Adds post-execution callback. Parameters ---------- callback : HookSignatureType, / Post-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def add_on_error ( self , callback : HookSignatureType , / ) -> HooksAware : \"\"\"Adds on-error callback. Parameters ---------- callback : HookSignatureType, / On-error callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ... @abc . abstractmethod def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all post-execution callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. \"\"\" ... @abc . abstractmethod def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all pre-execution callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. \"\"\" ... @abc . abstractmethod def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all on-error callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. \"\"\" ... @property @abc . abstractmethod def pre_execution_hooks ( self ) -> collections . abc . Sequence [ HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of pre-execution hooks. \"\"\" ... @property @abc . abstractmethod def post_execution_hooks ( self ) -> collections . abc . Sequence [ HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of post-execution hooks. \"\"\" ... @property @abc . abstractmethod def on_error_hooks ( self ) -> collections . abc . Sequence [ HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of on-error hooks. \"\"\" ...","title":"HooksAware"},{"location":"docs/api/hooks/#multibar.api.hooks.HooksAware.__slots__","text":"","title":"__slots__"},{"location":"docs/api/hooks/#multibar.api.hooks.HooksAware.__len__","text":"Returns length of all hooks. Used for bool() and len() operations. Source code in multibar\\api\\hooks.py 25 26 27 28 @abc . abstractmethod def __len__ ( self ) -> int : \"\"\"Returns length of all hooks. Used for bool() and len() operations.\"\"\" ...","title":"__len__()"},{"location":"docs/api/hooks/#multibar.api.hooks.HooksAware.add_on_error","text":"Adds on-error callback. PARAMETER DESCRIPTION callback On-error callback. TYPE: HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @abc . abstractmethod def add_on_error ( self , callback : HookSignatureType , / ) -> HooksAware : \"\"\"Adds on-error callback. Parameters ---------- callback : HookSignatureType, / On-error callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ...","title":"add_on_error()"},{"location":"docs/api/hooks/#multibar.api.hooks.HooksAware.add_post_execution","text":"Adds post-execution callback. PARAMETER DESCRIPTION callback Post-execution callback. TYPE: HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @abc . abstractmethod def add_post_execution ( self , callback : HookSignatureType , / ) -> HooksAware : \"\"\"Adds post-execution callback. Parameters ---------- callback : HookSignatureType, / Post-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ...","title":"add_post_execution()"},{"location":"docs/api/hooks/#multibar.api.hooks.HooksAware.add_pre_execution","text":"Adds pre-execution callback. PARAMETER DESCRIPTION callback Pre-execution callback. TYPE: HookSignatureType RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @abc . abstractmethod def add_pre_execution ( self , callback : HookSignatureType , / ) -> HooksAware : \"\"\"Adds pre-execution callback. Parameters ---------- callback : HookSignatureType, / Pre-execution callback. Returns ------- Self The hook object to allow fluent-style. \"\"\" ...","title":"add_pre_execution()"},{"location":"docs/api/hooks/#multibar.api.hooks.HooksAware.add_to_client","text":"Adds hooks to the client. PARAMETER DESCRIPTION client Client to add. TYPE: clients . ProgressbarClientAware RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @abc . abstractmethod def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> HooksAware : \"\"\"Adds hooks to the client. Parameters ---------- client : clients.ProgressbarClientAware, / Client to add. Returns ------- Self The hook object to allow fluent-style. \"\"\" ...","title":"add_to_client()"},{"location":"docs/api/hooks/#multibar.api.hooks.HooksAware.on_error_hooks","text":"RETURNS DESCRIPTION collections . abc . Sequence [ HookSignatureType ] Sequence of on-error hooks. Source code in multibar\\api\\hooks.py 168 169 170 171 172 173 174 175 176 177 @property @abc . abstractmethod def on_error_hooks ( self ) -> collections . abc . Sequence [ HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of on-error hooks. \"\"\" ...","title":"on_error_hooks()"},{"location":"docs/api/hooks/#multibar.api.hooks.HooksAware.post_execution_hooks","text":"RETURNS DESCRIPTION collections . abc . Sequence [ HookSignatureType ] Sequence of post-execution hooks. Source code in multibar\\api\\hooks.py 157 158 159 160 161 162 163 164 165 166 @property @abc . abstractmethod def post_execution_hooks ( self ) -> collections . abc . Sequence [ HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of post-execution hooks. \"\"\" ...","title":"post_execution_hooks()"},{"location":"docs/api/hooks/#multibar.api.hooks.HooksAware.pre_execution_hooks","text":"RETURNS DESCRIPTION collections . abc . Sequence [ HookSignatureType ] Sequence of pre-execution hooks. Source code in multibar\\api\\hooks.py 146 147 148 149 150 151 152 153 154 155 @property @abc . abstractmethod def pre_execution_hooks ( self ) -> collections . abc . Sequence [ HookSignatureType ]: \"\"\" Returns ------- collections.abc.Sequence[HookSignatureType] Sequence of pre-execution hooks. \"\"\" ...","title":"pre_execution_hooks()"},{"location":"docs/api/hooks/#multibar.api.hooks.HooksAware.trigger_on_error","text":"Triggers all on-error callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Source code in multibar\\api\\hooks.py 134 135 136 137 138 139 140 141 142 143 144 @abc . abstractmethod def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all on-error callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. \"\"\" ...","title":"trigger_on_error()"},{"location":"docs/api/hooks/#multibar.api.hooks.HooksAware.trigger_post_execution","text":"Triggers all post-execution callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Source code in multibar\\api\\hooks.py 110 111 112 113 114 115 116 117 118 119 120 @abc . abstractmethod def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all post-execution callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. \"\"\" ...","title":"trigger_post_execution()"},{"location":"docs/api/hooks/#multibar.api.hooks.HooksAware.trigger_pre_execution","text":"Triggers all pre-execution callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. Source code in multibar\\api\\hooks.py 122 123 124 125 126 127 128 129 130 131 132 @abc . abstractmethod def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers all pre-execution callbacks. *args : typing.Any Arguments to trigger. **kwargs : typing.Any Keyword arguments to trigger. \"\"\" ...","title":"trigger_pre_execution()"},{"location":"docs/api/hooks/#multibar.api.hooks.HooksAware.update","text":"Updates self hooks from other hooks object. PARAMETER DESCRIPTION other Other hooks object to update. TYPE: HooksAware RETURNS DESCRIPTION Self The hook object to allow fluent-style. Source code in multibar\\api\\hooks.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @abc . abstractmethod def update ( self , other : HooksAware , / ) -> HooksAware : \"\"\"Updates self hooks from other hooks object. Parameters ---------- other : HooksAware, / Other hooks object to update. Returns ------- Self The hook object to allow fluent-style. \"\"\" ...","title":"update()"},{"location":"docs/api/math_operations/","text":"multibar.api.calculation_service \u00a4 __all__ = ( 'AbstractCalculationService' ) module-attribute \u00a4 AbstractCalculationService \u00a4 Bases: abc . ABC An abstraction that represents a service for mathematical operations on the progress bar. Currently, implemented in: - multibar.impl.calculation_service.ProgressbarCalculationService Source code in multibar\\api\\calculation_service.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 class AbstractCalculationService ( abc . ABC ): \"\"\"An abstraction that represents a service for mathematical operations on the progress bar. Currently, implemented in: - multibar.impl.calculation_service.ProgressbarCalculationService \"\"\" __slots__ = ( \"_start_value\" , \"_end_value\" , \"_length\" ) def __init__ ( self , start_value : typing . Union [ int , float ], end_value : typing . Union [ int , float ], length : int , ) -> None : \"\"\"Slotted abstraction, that bounded to the arguments. Parameters ---------- start_value : typing.Union[int, float] Start value (current progress) for progressbar math operations. end_value : typing.Union[int, float] End value (needed progress) for progressbar math operations. length : int Length of progressbar for progressbar math operations. \"\"\" self . _start_value = start_value self . _end_value = end_value self . _length = length @abc . abstractmethod def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar filled sector indexes. \"\"\" ... @abc . abstractmethod def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar unfilled sector indexes. \"\"\" ... @property @abc . abstractmethod def progress_percents ( self ) -> float : \"\"\"Returns current progress percentage. Returns ------- float Float progress percentage. \"\"\" ... @staticmethod @abc . abstractmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : \"\"\"Alternative staticmethod to get progress percentage. Parameters ----------- start : typing.Union[int, float] Start value (current progress) for progressbar math operations. end : typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" ... @property def start_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] Start value (current progress) for progressbar math operations. \"\"\" return self . _start_value @property def end_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" return self . _end_value @property def length_value ( self ) -> int : \"\"\" Returns ------- int Length of progressbar for progressbar math operations. \"\"\" return self . _length __slots__ = ( '_start_value' , '_end_value' , '_length' ) class-attribute \u00a4 __init__ ( start_value , end_value , length ) \u00a4 Slotted abstraction, that bounded to the arguments. PARAMETER DESCRIPTION start_value Start value (current progress) for progressbar math operations. TYPE: typing . Union [ int , float ] end_value : typing.Union[int, float] End value (needed progress) for progressbar math operations. length : int Length of progressbar for progressbar math operations. Source code in multibar\\api\\calculation_service.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , start_value : typing . Union [ int , float ], end_value : typing . Union [ int , float ], length : int , ) -> None : \"\"\"Slotted abstraction, that bounded to the arguments. Parameters ---------- start_value : typing.Union[int, float] Start value (current progress) for progressbar math operations. end_value : typing.Union[int, float] End value (needed progress) for progressbar math operations. length : int Length of progressbar for progressbar math operations. \"\"\" self . _start_value = start_value self . _end_value = end_value self . _length = length calculate_filled_indexes () abstractmethod \u00a4 Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. RETURNS DESCRIPTION collections . abc . Iterator [ int ] Iterator over progressbar filled sector indexes. Source code in multibar\\api\\calculation_service.py 41 42 43 44 45 46 47 48 49 50 51 52 @abc . abstractmethod def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar filled sector indexes. \"\"\" ... calculate_unfilled_indexes () abstractmethod \u00a4 Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. RETURNS DESCRIPTION collections . abc . Iterator [ int ] Iterator over progressbar unfilled sector indexes. Source code in multibar\\api\\calculation_service.py 54 55 56 57 58 59 60 61 62 63 64 65 @abc . abstractmethod def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar unfilled sector indexes. \"\"\" ... end_value () property \u00a4 RETURNS DESCRIPTION typing . Union [ int , float ] End value (needed progress) for progressbar math operations. Source code in multibar\\api\\calculation_service.py 104 105 106 107 108 109 110 111 112 @property def end_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" return self . _end_value get_progress_percentage ( start , end ) abstractmethod staticmethod \u00a4 Alternative staticmethod to get progress percentage. PARAMETER DESCRIPTION start Start value (current progress) for progressbar math operations. TYPE: typing . Union [ int , float ] end : typing.Union[int, float] End value (needed progress) for progressbar math operations. Source code in multibar\\api\\calculation_service.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @staticmethod @abc . abstractmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : \"\"\"Alternative staticmethod to get progress percentage. Parameters ----------- start : typing.Union[int, float] Start value (current progress) for progressbar math operations. end : typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" ... length_value () property \u00a4 RETURNS DESCRIPTION int Length of progressbar for progressbar math operations. Source code in multibar\\api\\calculation_service.py 114 115 116 117 118 119 120 121 122 @property def length_value ( self ) -> int : \"\"\" Returns ------- int Length of progressbar for progressbar math operations. \"\"\" return self . _length progress_percents () property abstractmethod \u00a4 Returns current progress percentage. RETURNS DESCRIPTION float Float progress percentage. Source code in multibar\\api\\calculation_service.py 67 68 69 70 71 72 73 74 75 76 77 @property @abc . abstractmethod def progress_percents ( self ) -> float : \"\"\"Returns current progress percentage. Returns ------- float Float progress percentage. \"\"\" ... start_value () property \u00a4 RETURNS DESCRIPTION typing . Union [ int , float ] Start value (current progress) for progressbar math operations. Source code in multibar\\api\\calculation_service.py 94 95 96 97 98 99 100 101 102 @property def start_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] Start value (current progress) for progressbar math operations. \"\"\" return self . _start_value","title":"Math operations"},{"location":"docs/api/math_operations/#multibar.api.calculation_service","text":"","title":"calculation_service"},{"location":"docs/api/math_operations/#multibar.api.calculation_service.__all__","text":"","title":"__all__"},{"location":"docs/api/math_operations/#multibar.api.calculation_service.AbstractCalculationService","text":"Bases: abc . ABC An abstraction that represents a service for mathematical operations on the progress bar. Currently, implemented in: - multibar.impl.calculation_service.ProgressbarCalculationService Source code in multibar\\api\\calculation_service.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 class AbstractCalculationService ( abc . ABC ): \"\"\"An abstraction that represents a service for mathematical operations on the progress bar. Currently, implemented in: - multibar.impl.calculation_service.ProgressbarCalculationService \"\"\" __slots__ = ( \"_start_value\" , \"_end_value\" , \"_length\" ) def __init__ ( self , start_value : typing . Union [ int , float ], end_value : typing . Union [ int , float ], length : int , ) -> None : \"\"\"Slotted abstraction, that bounded to the arguments. Parameters ---------- start_value : typing.Union[int, float] Start value (current progress) for progressbar math operations. end_value : typing.Union[int, float] End value (needed progress) for progressbar math operations. length : int Length of progressbar for progressbar math operations. \"\"\" self . _start_value = start_value self . _end_value = end_value self . _length = length @abc . abstractmethod def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar filled sector indexes. \"\"\" ... @abc . abstractmethod def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar unfilled sector indexes. \"\"\" ... @property @abc . abstractmethod def progress_percents ( self ) -> float : \"\"\"Returns current progress percentage. Returns ------- float Float progress percentage. \"\"\" ... @staticmethod @abc . abstractmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : \"\"\"Alternative staticmethod to get progress percentage. Parameters ----------- start : typing.Union[int, float] Start value (current progress) for progressbar math operations. end : typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" ... @property def start_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] Start value (current progress) for progressbar math operations. \"\"\" return self . _start_value @property def end_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" return self . _end_value @property def length_value ( self ) -> int : \"\"\" Returns ------- int Length of progressbar for progressbar math operations. \"\"\" return self . _length","title":"AbstractCalculationService"},{"location":"docs/api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.__slots__","text":"","title":"__slots__"},{"location":"docs/api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.__init__","text":"Slotted abstraction, that bounded to the arguments. PARAMETER DESCRIPTION start_value Start value (current progress) for progressbar math operations. TYPE: typing . Union [ int , float ] end_value : typing.Union[int, float] End value (needed progress) for progressbar math operations. length : int Length of progressbar for progressbar math operations. Source code in multibar\\api\\calculation_service.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , start_value : typing . Union [ int , float ], end_value : typing . Union [ int , float ], length : int , ) -> None : \"\"\"Slotted abstraction, that bounded to the arguments. Parameters ---------- start_value : typing.Union[int, float] Start value (current progress) for progressbar math operations. end_value : typing.Union[int, float] End value (needed progress) for progressbar math operations. length : int Length of progressbar for progressbar math operations. \"\"\" self . _start_value = start_value self . _end_value = end_value self . _length = length","title":"__init__()"},{"location":"docs/api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.calculate_filled_indexes","text":"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. RETURNS DESCRIPTION collections . abc . Iterator [ int ] Iterator over progressbar filled sector indexes. Source code in multibar\\api\\calculation_service.py 41 42 43 44 45 46 47 48 49 50 51 52 @abc . abstractmethod def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar filled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar filled sector indexes. \"\"\" ...","title":"calculate_filled_indexes()"},{"location":"docs/api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.calculate_unfilled_indexes","text":"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. RETURNS DESCRIPTION collections . abc . Iterator [ int ] Iterator over progressbar unfilled sector indexes. Source code in multibar\\api\\calculation_service.py 54 55 56 57 58 59 60 61 62 63 64 65 @abc . abstractmethod def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: \"\"\"Returns iterator over progressbar unfilled sector indexes. This method is implemented for a more comfortable calculation of the position of the sector in the progress bar. Returns ------- collections.abc.Iterator[int] Iterator over progressbar unfilled sector indexes. \"\"\" ...","title":"calculate_unfilled_indexes()"},{"location":"docs/api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.end_value","text":"RETURNS DESCRIPTION typing . Union [ int , float ] End value (needed progress) for progressbar math operations. Source code in multibar\\api\\calculation_service.py 104 105 106 107 108 109 110 111 112 @property def end_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" return self . _end_value","title":"end_value()"},{"location":"docs/api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.get_progress_percentage","text":"Alternative staticmethod to get progress percentage. PARAMETER DESCRIPTION start Start value (current progress) for progressbar math operations. TYPE: typing . Union [ int , float ] end : typing.Union[int, float] End value (needed progress) for progressbar math operations. Source code in multibar\\api\\calculation_service.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @staticmethod @abc . abstractmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : \"\"\"Alternative staticmethod to get progress percentage. Parameters ----------- start : typing.Union[int, float] Start value (current progress) for progressbar math operations. end : typing.Union[int, float] End value (needed progress) for progressbar math operations. \"\"\" ...","title":"get_progress_percentage()"},{"location":"docs/api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.length_value","text":"RETURNS DESCRIPTION int Length of progressbar for progressbar math operations. Source code in multibar\\api\\calculation_service.py 114 115 116 117 118 119 120 121 122 @property def length_value ( self ) -> int : \"\"\" Returns ------- int Length of progressbar for progressbar math operations. \"\"\" return self . _length","title":"length_value()"},{"location":"docs/api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.progress_percents","text":"Returns current progress percentage. RETURNS DESCRIPTION float Float progress percentage. Source code in multibar\\api\\calculation_service.py 67 68 69 70 71 72 73 74 75 76 77 @property @abc . abstractmethod def progress_percents ( self ) -> float : \"\"\"Returns current progress percentage. Returns ------- float Float progress percentage. \"\"\" ...","title":"progress_percents()"},{"location":"docs/api/math_operations/#multibar.api.calculation_service.AbstractCalculationService.start_value","text":"RETURNS DESCRIPTION typing . Union [ int , float ] Start value (current progress) for progressbar math operations. Source code in multibar\\api\\calculation_service.py 94 95 96 97 98 99 100 101 102 @property def start_value ( self ) -> typing . Union [ int , float ]: \"\"\" Returns ------- typing.Union[int, float] Start value (current progress) for progressbar math operations. \"\"\" return self . _start_value","title":"start_value()"},{"location":"docs/api/progressbars/","text":"multibar.api.progressbars \u00a4 SectorT = typing . TypeVar ( 'SectorT' , bound = sectors . AbstractSector ) module-attribute \u00a4 __all__ = ( 'ProgressbarAware' ) module-attribute \u00a4 ProgressbarAware \u00a4 Bases: abc . ABC , typing . Generic [ SectorT ] Interface for progressbar implementations. Source code in multibar\\api\\progressbars.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 class ProgressbarAware ( abc . ABC , typing . Generic [ SectorT ]): \"\"\"Interface for progressbar implementations.\"\"\" __slots__ = () @typing . overload @abc . abstractmethod def __getitem__ ( self , item : slice ) -> collections . abc . Sequence [ SectorT ]: ... @typing . overload @abc . abstractmethod def __getitem__ ( self , item : int ) -> SectorT : ... @abc . abstractmethod def __getitem__ ( self , item : typing . Any ) -> typing . Any : \"\"\"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice.\"\"\" ... @abc . abstractmethod def __len__ ( self ) -> int : \"\"\"Returns sectors count.\"\"\" ... @classmethod @abc . abstractmethod def set_new_sectors ( cls : typing . Type [ _InstanceKind ], new_value : collections . abc . Iterable [ _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Sets new sectors in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: >>> progressbar = progresswriter.write(value, value) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors(...) # Extended sectors with .extend_method() >>> new_progressbar = progressbar.set_new_sectors(sectors) # Sectors have .extend_method() >>> new_progressbar.sectors[0].extend_method() # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Parameters ---------- new_value : collections.abc.Iterable[_NewValueType], / Iterable over new sector objects. For example of behavior see `info` block. Returns ------- Kind1[_InstanceKind, _NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" ... @abc . abstractmethod def map ( self : _InstanceKind , callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Applies callback for every sector in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: progressbar = progressbarwriter.write(value, value) >>> class ExtendedImpl(AbstractSector): # Your extended implementation >>> def __init__(self, sector_obj: AbstractSector) -> None: ... super().__init__(sector_obj.name, sector_obj.is_filled, sector_obj.position) ... self._origin = sector_obj ... >>> def extended_method(self) -> None: ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar.map(lambda s: ExtendedImpl(s)) >>> new_progressbar.sectors[0].extended_method() # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. \"\"\" ... @abc . abstractmethod def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : \"\"\"Pass each sector to a given consumer. Parameters ---------- consumer : typing.Callable[[SectorT], typing.Any], / Function to apply for progressbar sectors. \"\"\" ... @abc . abstractmethod def add_sector ( self : _InstanceKind , sector : sectors . AbstractSector , / ) -> _InstanceKind : \"\"\"Adds sector to progressbar. Parameters ---------- sector : SectorT, / Sector to add. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ... @abc . abstractmethod def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> ProgressbarAware [ SectorT ]: \"\"\"Replaces sector display name. Parameters ---------- sector_pos : int, / To find sector by index to change. new_display_name : str, / New display name value. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ... @property @abc . abstractmethod def length ( self ) -> int : \"\"\" Returns ------- int Length of the progressbar. \"\"\" ... @property @abc . abstractmethod def sectors ( self ) -> collections . abc . MutableSequence [ SectorT ]: \"\"\" Returns ------- collections.abc.Sequence[SectorT] Sequence of sectors. \"\"\" ... __slots__ = () class-attribute \u00a4 __getitem__ ( item ) abstractmethod \u00a4 Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice. Source code in multibar\\api\\progressbars.py 40 41 42 43 44 @abc . abstractmethod def __getitem__ ( self , item : typing . Any ) -> typing . Any : \"\"\"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice.\"\"\" ... __len__ () abstractmethod \u00a4 Returns sectors count. Source code in multibar\\api\\progressbars.py 46 47 48 49 @abc . abstractmethod def __len__ ( self ) -> int : \"\"\"Returns sectors count.\"\"\" ... add_sector ( sector ) abstractmethod \u00a4 Adds sector to progressbar. PARAMETER DESCRIPTION sector Sector to add. TYPE: SectorT RETURNS DESCRIPTION Self The progressbar object to allow fluent-style. Source code in multibar\\api\\progressbars.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 @abc . abstractmethod def add_sector ( self : _InstanceKind , sector : sectors . AbstractSector , / ) -> _InstanceKind : \"\"\"Adds sector to progressbar. Parameters ---------- sector : SectorT, / Sector to add. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ... for_each ( consumer ) abstractmethod \u00a4 Pass each sector to a given consumer. PARAMETER DESCRIPTION consumer Function to apply for progressbar sectors. TYPE: typing . Callable [[ SectorT ], typing . Any ] Source code in multibar\\api\\progressbars.py 140 141 142 143 144 145 146 147 148 149 @abc . abstractmethod def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : \"\"\"Pass each sector to a given consumer. Parameters ---------- consumer : typing.Callable[[SectorT], typing.Any], / Function to apply for progressbar sectors. \"\"\" ... length () property abstractmethod \u00a4 RETURNS DESCRIPTION int Length of the progressbar. Source code in multibar\\api\\progressbars.py 188 189 190 191 192 193 194 195 196 197 @property @abc . abstractmethod def length ( self ) -> int : \"\"\" Returns ------- int Length of the progressbar. \"\"\" ... map ( callback ) abstractmethod \u00a4 Applies callback for every sector in progressbar. Info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. Abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: progressbar = progressbarwriter.write(value, value) class ExtendedImpl(AbstractSector): # Your extended implementation def init (self, sector_obj: AbstractSector) -> None: ... super(). init (sector_obj.name, sector_obj.is_filled, sector_obj.position) ... self._origin = sector_obj ... def extended_method(self) -> None: ... ... ... ... # Other abstraction api implementation. ... new_progressbar = progressbar.map(lambda s: ExtendedImpl(s)) new_progressbar.sectors[0].extended_method() # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Source code in multibar\\api\\progressbars.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 @abc . abstractmethod def map ( self : _InstanceKind , callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Applies callback for every sector in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: progressbar = progressbarwriter.write(value, value) >>> class ExtendedImpl(AbstractSector): # Your extended implementation >>> def __init__(self, sector_obj: AbstractSector) -> None: ... super().__init__(sector_obj.name, sector_obj.is_filled, sector_obj.position) ... self._origin = sector_obj ... >>> def extended_method(self) -> None: ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar.map(lambda s: ExtendedImpl(s)) >>> new_progressbar.sectors[0].extended_method() # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. \"\"\" ... replace_display_name_for ( sector_pos , new_display_name ) abstractmethod \u00a4 Replaces sector display name. PARAMETER DESCRIPTION sector_pos To find sector by index to change. TYPE: int new_display_name : str, / New display name value. RETURNS DESCRIPTION Self The progressbar object to allow fluent-style. Source code in multibar\\api\\progressbars.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 @abc . abstractmethod def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> ProgressbarAware [ SectorT ]: \"\"\"Replaces sector display name. Parameters ---------- sector_pos : int, / To find sector by index to change. new_display_name : str, / New display name value. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ... sectors () property abstractmethod \u00a4 RETURNS DESCRIPTION collections . abc . Sequence [ SectorT ] Sequence of sectors. Source code in multibar\\api\\progressbars.py 199 200 201 202 203 204 205 206 207 208 @property @abc . abstractmethod def sectors ( self ) -> collections . abc . MutableSequence [ SectorT ]: \"\"\" Returns ------- collections.abc.Sequence[SectorT] Sequence of sectors. \"\"\" ... set_new_sectors ( new_value ) classmethod abstractmethod \u00a4 Sets new sectors in progressbar. Info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. Abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: progressbar = progresswriter.write(value, value) # Sectors doesn't have .extend_method() sectors = IterableOverYourExtendedSectors(...) # Extended sectors with .extend_method() new_progressbar = progressbar.set_new_sectors(sectors) # Sectors have .extend_method() new_progressbar.sectors[0].extend_method() # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. PARAMETER DESCRIPTION new_value Iterable over new sector objects. For example of behavior see info block. TYPE: collections . abc . Iterable [ _NewValueType ] RETURNS DESCRIPTION Kind1 [ _InstanceKind , _NewValueType ] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. Source code in multibar\\api\\progressbars.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @classmethod @abc . abstractmethod def set_new_sectors ( cls : typing . Type [ _InstanceKind ], new_value : collections . abc . Iterable [ _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Sets new sectors in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: >>> progressbar = progresswriter.write(value, value) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors(...) # Extended sectors with .extend_method() >>> new_progressbar = progressbar.set_new_sectors(sectors) # Sectors have .extend_method() >>> new_progressbar.sectors[0].extend_method() # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Parameters ---------- new_value : collections.abc.Iterable[_NewValueType], / Iterable over new sector objects. For example of behavior see `info` block. Returns ------- Kind1[_InstanceKind, _NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" ... SupportsGetitem \u00a4 Bases: typing . Protocol Source code in multibar\\api\\progressbars.py 15 16 17 class SupportsGetitem ( typing . Protocol ): def __getitem__ ( self , item : typing . Any ) -> typing . Any : ... __getitem__ ( item ) \u00a4 Source code in multibar\\api\\progressbars.py 16 17 def __getitem__ ( self , item : typing . Any ) -> typing . Any : ...","title":"Progressbars"},{"location":"docs/api/progressbars/#multibar.api.progressbars","text":"","title":"progressbars"},{"location":"docs/api/progressbars/#multibar.api.progressbars.SectorT","text":"","title":"SectorT"},{"location":"docs/api/progressbars/#multibar.api.progressbars.__all__","text":"","title":"__all__"},{"location":"docs/api/progressbars/#multibar.api.progressbars.ProgressbarAware","text":"Bases: abc . ABC , typing . Generic [ SectorT ] Interface for progressbar implementations. Source code in multibar\\api\\progressbars.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 class ProgressbarAware ( abc . ABC , typing . Generic [ SectorT ]): \"\"\"Interface for progressbar implementations.\"\"\" __slots__ = () @typing . overload @abc . abstractmethod def __getitem__ ( self , item : slice ) -> collections . abc . Sequence [ SectorT ]: ... @typing . overload @abc . abstractmethod def __getitem__ ( self , item : int ) -> SectorT : ... @abc . abstractmethod def __getitem__ ( self , item : typing . Any ) -> typing . Any : \"\"\"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice.\"\"\" ... @abc . abstractmethod def __len__ ( self ) -> int : \"\"\"Returns sectors count.\"\"\" ... @classmethod @abc . abstractmethod def set_new_sectors ( cls : typing . Type [ _InstanceKind ], new_value : collections . abc . Iterable [ _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Sets new sectors in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: >>> progressbar = progresswriter.write(value, value) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors(...) # Extended sectors with .extend_method() >>> new_progressbar = progressbar.set_new_sectors(sectors) # Sectors have .extend_method() >>> new_progressbar.sectors[0].extend_method() # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Parameters ---------- new_value : collections.abc.Iterable[_NewValueType], / Iterable over new sector objects. For example of behavior see `info` block. Returns ------- Kind1[_InstanceKind, _NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" ... @abc . abstractmethod def map ( self : _InstanceKind , callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Applies callback for every sector in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: progressbar = progressbarwriter.write(value, value) >>> class ExtendedImpl(AbstractSector): # Your extended implementation >>> def __init__(self, sector_obj: AbstractSector) -> None: ... super().__init__(sector_obj.name, sector_obj.is_filled, sector_obj.position) ... self._origin = sector_obj ... >>> def extended_method(self) -> None: ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar.map(lambda s: ExtendedImpl(s)) >>> new_progressbar.sectors[0].extended_method() # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. \"\"\" ... @abc . abstractmethod def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : \"\"\"Pass each sector to a given consumer. Parameters ---------- consumer : typing.Callable[[SectorT], typing.Any], / Function to apply for progressbar sectors. \"\"\" ... @abc . abstractmethod def add_sector ( self : _InstanceKind , sector : sectors . AbstractSector , / ) -> _InstanceKind : \"\"\"Adds sector to progressbar. Parameters ---------- sector : SectorT, / Sector to add. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ... @abc . abstractmethod def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> ProgressbarAware [ SectorT ]: \"\"\"Replaces sector display name. Parameters ---------- sector_pos : int, / To find sector by index to change. new_display_name : str, / New display name value. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ... @property @abc . abstractmethod def length ( self ) -> int : \"\"\" Returns ------- int Length of the progressbar. \"\"\" ... @property @abc . abstractmethod def sectors ( self ) -> collections . abc . MutableSequence [ SectorT ]: \"\"\" Returns ------- collections.abc.Sequence[SectorT] Sequence of sectors. \"\"\" ...","title":"ProgressbarAware"},{"location":"docs/api/progressbars/#multibar.api.progressbars.ProgressbarAware.__slots__","text":"","title":"__slots__"},{"location":"docs/api/progressbars/#multibar.api.progressbars.ProgressbarAware.__getitem__","text":"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice. Source code in multibar\\api\\progressbars.py 40 41 42 43 44 @abc . abstractmethod def __getitem__ ( self , item : typing . Any ) -> typing . Any : \"\"\"Returns sector object if item is instance of int, or sequence of sectors if item is instance of slice.\"\"\" ...","title":"__getitem__()"},{"location":"docs/api/progressbars/#multibar.api.progressbars.ProgressbarAware.__len__","text":"Returns sectors count. Source code in multibar\\api\\progressbars.py 46 47 48 49 @abc . abstractmethod def __len__ ( self ) -> int : \"\"\"Returns sectors count.\"\"\" ...","title":"__len__()"},{"location":"docs/api/progressbars/#multibar.api.progressbars.ProgressbarAware.add_sector","text":"Adds sector to progressbar. PARAMETER DESCRIPTION sector Sector to add. TYPE: SectorT RETURNS DESCRIPTION Self The progressbar object to allow fluent-style. Source code in multibar\\api\\progressbars.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 @abc . abstractmethod def add_sector ( self : _InstanceKind , sector : sectors . AbstractSector , / ) -> _InstanceKind : \"\"\"Adds sector to progressbar. Parameters ---------- sector : SectorT, / Sector to add. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ...","title":"add_sector()"},{"location":"docs/api/progressbars/#multibar.api.progressbars.ProgressbarAware.for_each","text":"Pass each sector to a given consumer. PARAMETER DESCRIPTION consumer Function to apply for progressbar sectors. TYPE: typing . Callable [[ SectorT ], typing . Any ] Source code in multibar\\api\\progressbars.py 140 141 142 143 144 145 146 147 148 149 @abc . abstractmethod def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : \"\"\"Pass each sector to a given consumer. Parameters ---------- consumer : typing.Callable[[SectorT], typing.Any], / Function to apply for progressbar sectors. \"\"\" ...","title":"for_each()"},{"location":"docs/api/progressbars/#multibar.api.progressbars.ProgressbarAware.length","text":"RETURNS DESCRIPTION int Length of the progressbar. Source code in multibar\\api\\progressbars.py 188 189 190 191 192 193 194 195 196 197 @property @abc . abstractmethod def length ( self ) -> int : \"\"\" Returns ------- int Length of the progressbar. \"\"\" ...","title":"length()"},{"location":"docs/api/progressbars/#multibar.api.progressbars.ProgressbarAware.map","text":"Applies callback for every sector in progressbar. Info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. Abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: progressbar = progressbarwriter.write(value, value) class ExtendedImpl(AbstractSector): # Your extended implementation def init (self, sector_obj: AbstractSector) -> None: ... super(). init (sector_obj.name, sector_obj.is_filled, sector_obj.position) ... self._origin = sector_obj ... def extended_method(self) -> None: ... ... ... ... # Other abstraction api implementation. ... new_progressbar = progressbar.map(lambda s: ExtendedImpl(s)) new_progressbar.sectors[0].extended_method() # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Source code in multibar\\api\\progressbars.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 @abc . abstractmethod def map ( self : _InstanceKind , callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Applies callback for every sector in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: progressbar = progressbarwriter.write(value, value) >>> class ExtendedImpl(AbstractSector): # Your extended implementation >>> def __init__(self, sector_obj: AbstractSector) -> None: ... super().__init__(sector_obj.name, sector_obj.is_filled, sector_obj.position) ... self._origin = sector_obj ... >>> def extended_method(self) -> None: ... ... ... ... # Other abstraction api implementation. ... >>> new_progressbar = progressbar.map(lambda s: ExtendedImpl(s)) >>> new_progressbar.sectors[0].extended_method() # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. \"\"\" ...","title":"map()"},{"location":"docs/api/progressbars/#multibar.api.progressbars.ProgressbarAware.replace_display_name_for","text":"Replaces sector display name. PARAMETER DESCRIPTION sector_pos To find sector by index to change. TYPE: int new_display_name : str, / New display name value. RETURNS DESCRIPTION Self The progressbar object to allow fluent-style. Source code in multibar\\api\\progressbars.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 @abc . abstractmethod def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> ProgressbarAware [ SectorT ]: \"\"\"Replaces sector display name. Parameters ---------- sector_pos : int, / To find sector by index to change. new_display_name : str, / New display name value. Returns ------- Self The progressbar object to allow fluent-style. \"\"\" ...","title":"replace_display_name_for()"},{"location":"docs/api/progressbars/#multibar.api.progressbars.ProgressbarAware.sectors","text":"RETURNS DESCRIPTION collections . abc . Sequence [ SectorT ] Sequence of sectors. Source code in multibar\\api\\progressbars.py 199 200 201 202 203 204 205 206 207 208 @property @abc . abstractmethod def sectors ( self ) -> collections . abc . MutableSequence [ SectorT ]: \"\"\" Returns ------- collections.abc.Sequence[SectorT] Sequence of sectors. \"\"\" ...","title":"sectors()"},{"location":"docs/api/progressbars/#multibar.api.progressbars.ProgressbarAware.set_new_sectors","text":"Sets new sectors in progressbar. Info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. Abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: progressbar = progresswriter.write(value, value) # Sectors doesn't have .extend_method() sectors = IterableOverYourExtendedSectors(...) # Extended sectors with .extend_method() new_progressbar = progressbar.set_new_sectors(sectors) # Sectors have .extend_method() new_progressbar.sectors[0].extend_method() # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. PARAMETER DESCRIPTION new_value Iterable over new sector objects. For example of behavior see info block. TYPE: collections . abc . Iterable [ _NewValueType ] RETURNS DESCRIPTION Kind1 [ _InstanceKind , _NewValueType ] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. Source code in multibar\\api\\progressbars.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @classmethod @abc . abstractmethod def set_new_sectors ( cls : typing . Type [ _InstanceKind ], new_value : collections . abc . Iterable [ _NewValueType ], / , ) -> Kind1 [ _InstanceKind , _NewValueType ]: \"\"\"Sets new sectors in progressbar. !!! info Returns new progressbar object. It is a type-hint safe operation for mypy. That allows you to pass extended implementations of interfaces or abscractions, given the support of the underlying api. !!! abstract You can skip this block, if you don't use type-hints. We use HKT in this case so that you can add new methods to sectors, but at the same time they would support the abstract class api. An example of behavior in pseudocode: >>> progressbar = progresswriter.write(value, value) # Sectors doesn't have .extend_method() >>> sectors = IterableOverYourExtendedSectors(...) # Extended sectors with .extend_method() >>> new_progressbar = progressbar.set_new_sectors(sectors) # Sectors have .extend_method() >>> new_progressbar.sectors[0].extend_method() # Mypy happy. It is worth clarifying that this implementation has not yet been finalized and may be changed in future versions (and even without HKT at all). You can leave your opinion about this in the issues of the project. Parameters ---------- new_value : collections.abc.Iterable[_NewValueType], / Iterable over new sector objects. For example of behavior see `info` block. Returns ------- Kind1[_InstanceKind, _NewValueType] New instace of progressbar with your sector objects. But it would differ from the usual implementation in that mypy does not throw an error in this case. \"\"\" ...","title":"set_new_sectors()"},{"location":"docs/api/progressbars/#multibar.api.progressbars.SupportsGetitem","text":"Bases: typing . Protocol Source code in multibar\\api\\progressbars.py 15 16 17 class SupportsGetitem ( typing . Protocol ): def __getitem__ ( self , item : typing . Any ) -> typing . Any : ...","title":"SupportsGetitem"},{"location":"docs/api/progressbars/#multibar.api.progressbars.SupportsGetitem.__getitem__","text":"Source code in multibar\\api\\progressbars.py 16 17 def __getitem__ ( self , item : typing . Any ) -> typing . Any : ...","title":"__getitem__()"},{"location":"docs/api/sectors/","text":"multibar.api.sectors \u00a4 SelfT = typing . TypeVar ( 'SelfT' , bound = 'AbstractSector' ) module-attribute \u00a4 __all__ = ( 'AbstractSector' ) module-attribute \u00a4 AbstractSector \u00a4 Bases: abc . ABC Abstraction for sector implementations. Source code in multibar\\api\\sectors.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class AbstractSector ( abc . ABC ): \"\"\"Abstraction for sector implementations.\"\"\" __slots__ = ( \"_name\" , \"_is_filled\" , \"_position\" ) def __init__ ( self , name : str , is_filled : bool , position : int ) -> None : \"\"\"Slotted abstraction, that bounded to the arguments. Parameters ---------- name : str Sector display name. is_filled : bool Sector filled value. position : int Sector position in the progressbar. \"\"\" self . _name = name self . _is_filled = is_filled self . _position = position @abc . abstractmethod def add_to_progressbar ( self : SelfT , progressbar : progressbars . ProgressbarAware [ SelfT ], / ) -> SelfT : \"\"\"Adds sector self to progressbar. Parameters ---------- progressbar : progressbars.ProgressbarAware[SelfT], / Progressbar to add self for. Returns ------- Self The sector object to allow fluent-style. \"\"\" ... @abc . abstractmethod def change_name ( self , new_display_name : str , / ) -> AbstractSector : \"\"\"Changes sector display name. Parameters ---------- new_display_name : str, / New display name to set. Returns ------- Self The sector object to allow fluent-style. \"\"\" ... @property @abc . abstractmethod def name ( self ) -> str : \"\"\" Returns ------- str Sector display name. \"\"\" ... @property @abc . abstractmethod def is_filled ( self ) -> bool : \"\"\" Returns ------- str Sector filled value. \"\"\" ... @property @abc . abstractmethod def position ( self ) -> int : \"\"\" Returns ------- str Sector position in the progressbar. \"\"\" ... __slots__ = ( '_name' , '_is_filled' , '_position' ) class-attribute \u00a4 __init__ ( name , is_filled , position ) \u00a4 Slotted abstraction, that bounded to the arguments. PARAMETER DESCRIPTION name Sector display name. TYPE: str is_filled : bool Sector filled value. position : int Sector position in the progressbar. Source code in multibar\\api\\sectors.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def __init__ ( self , name : str , is_filled : bool , position : int ) -> None : \"\"\"Slotted abstraction, that bounded to the arguments. Parameters ---------- name : str Sector display name. is_filled : bool Sector filled value. position : int Sector position in the progressbar. \"\"\" self . _name = name self . _is_filled = is_filled self . _position = position add_to_progressbar ( progressbar ) abstractmethod \u00a4 Adds sector self to progressbar. PARAMETER DESCRIPTION progressbar Progressbar to add self for. TYPE: progressbars . ProgressbarAware [ SelfT ] RETURNS DESCRIPTION Self The sector object to allow fluent-style. Source code in multibar\\api\\sectors.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @abc . abstractmethod def add_to_progressbar ( self : SelfT , progressbar : progressbars . ProgressbarAware [ SelfT ], / ) -> SelfT : \"\"\"Adds sector self to progressbar. Parameters ---------- progressbar : progressbars.ProgressbarAware[SelfT], / Progressbar to add self for. Returns ------- Self The sector object to allow fluent-style. \"\"\" ... change_name ( new_display_name ) abstractmethod \u00a4 Changes sector display name. PARAMETER DESCRIPTION new_display_name New display name to set. TYPE: str RETURNS DESCRIPTION Self The sector object to allow fluent-style. Source code in multibar\\api\\sectors.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @abc . abstractmethod def change_name ( self , new_display_name : str , / ) -> AbstractSector : \"\"\"Changes sector display name. Parameters ---------- new_display_name : str, / New display name to set. Returns ------- Self The sector object to allow fluent-style. \"\"\" ... is_filled () property abstractmethod \u00a4 RETURNS DESCRIPTION str Sector filled value. Source code in multibar\\api\\sectors.py 80 81 82 83 84 85 86 87 88 89 @property @abc . abstractmethod def is_filled ( self ) -> bool : \"\"\" Returns ------- str Sector filled value. \"\"\" ... name () property abstractmethod \u00a4 RETURNS DESCRIPTION str Sector display name. Source code in multibar\\api\\sectors.py 69 70 71 72 73 74 75 76 77 78 @property @abc . abstractmethod def name ( self ) -> str : \"\"\" Returns ------- str Sector display name. \"\"\" ... position () property abstractmethod \u00a4 RETURNS DESCRIPTION str Sector position in the progressbar. Source code in multibar\\api\\sectors.py 91 92 93 94 95 96 97 98 99 100 @property @abc . abstractmethod def position ( self ) -> int : \"\"\" Returns ------- str Sector position in the progressbar. \"\"\" ...","title":"Sectors"},{"location":"docs/api/sectors/#multibar.api.sectors","text":"","title":"sectors"},{"location":"docs/api/sectors/#multibar.api.sectors.SelfT","text":"","title":"SelfT"},{"location":"docs/api/sectors/#multibar.api.sectors.__all__","text":"","title":"__all__"},{"location":"docs/api/sectors/#multibar.api.sectors.AbstractSector","text":"Bases: abc . ABC Abstraction for sector implementations. Source code in multibar\\api\\sectors.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class AbstractSector ( abc . ABC ): \"\"\"Abstraction for sector implementations.\"\"\" __slots__ = ( \"_name\" , \"_is_filled\" , \"_position\" ) def __init__ ( self , name : str , is_filled : bool , position : int ) -> None : \"\"\"Slotted abstraction, that bounded to the arguments. Parameters ---------- name : str Sector display name. is_filled : bool Sector filled value. position : int Sector position in the progressbar. \"\"\" self . _name = name self . _is_filled = is_filled self . _position = position @abc . abstractmethod def add_to_progressbar ( self : SelfT , progressbar : progressbars . ProgressbarAware [ SelfT ], / ) -> SelfT : \"\"\"Adds sector self to progressbar. Parameters ---------- progressbar : progressbars.ProgressbarAware[SelfT], / Progressbar to add self for. Returns ------- Self The sector object to allow fluent-style. \"\"\" ... @abc . abstractmethod def change_name ( self , new_display_name : str , / ) -> AbstractSector : \"\"\"Changes sector display name. Parameters ---------- new_display_name : str, / New display name to set. Returns ------- Self The sector object to allow fluent-style. \"\"\" ... @property @abc . abstractmethod def name ( self ) -> str : \"\"\" Returns ------- str Sector display name. \"\"\" ... @property @abc . abstractmethod def is_filled ( self ) -> bool : \"\"\" Returns ------- str Sector filled value. \"\"\" ... @property @abc . abstractmethod def position ( self ) -> int : \"\"\" Returns ------- str Sector position in the progressbar. \"\"\" ...","title":"AbstractSector"},{"location":"docs/api/sectors/#multibar.api.sectors.AbstractSector.__slots__","text":"","title":"__slots__"},{"location":"docs/api/sectors/#multibar.api.sectors.AbstractSector.__init__","text":"Slotted abstraction, that bounded to the arguments. PARAMETER DESCRIPTION name Sector display name. TYPE: str is_filled : bool Sector filled value. position : int Sector position in the progressbar. Source code in multibar\\api\\sectors.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def __init__ ( self , name : str , is_filled : bool , position : int ) -> None : \"\"\"Slotted abstraction, that bounded to the arguments. Parameters ---------- name : str Sector display name. is_filled : bool Sector filled value. position : int Sector position in the progressbar. \"\"\" self . _name = name self . _is_filled = is_filled self . _position = position","title":"__init__()"},{"location":"docs/api/sectors/#multibar.api.sectors.AbstractSector.add_to_progressbar","text":"Adds sector self to progressbar. PARAMETER DESCRIPTION progressbar Progressbar to add self for. TYPE: progressbars . ProgressbarAware [ SelfT ] RETURNS DESCRIPTION Self The sector object to allow fluent-style. Source code in multibar\\api\\sectors.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @abc . abstractmethod def add_to_progressbar ( self : SelfT , progressbar : progressbars . ProgressbarAware [ SelfT ], / ) -> SelfT : \"\"\"Adds sector self to progressbar. Parameters ---------- progressbar : progressbars.ProgressbarAware[SelfT], / Progressbar to add self for. Returns ------- Self The sector object to allow fluent-style. \"\"\" ...","title":"add_to_progressbar()"},{"location":"docs/api/sectors/#multibar.api.sectors.AbstractSector.change_name","text":"Changes sector display name. PARAMETER DESCRIPTION new_display_name New display name to set. TYPE: str RETURNS DESCRIPTION Self The sector object to allow fluent-style. Source code in multibar\\api\\sectors.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @abc . abstractmethod def change_name ( self , new_display_name : str , / ) -> AbstractSector : \"\"\"Changes sector display name. Parameters ---------- new_display_name : str, / New display name to set. Returns ------- Self The sector object to allow fluent-style. \"\"\" ...","title":"change_name()"},{"location":"docs/api/sectors/#multibar.api.sectors.AbstractSector.is_filled","text":"RETURNS DESCRIPTION str Sector filled value. Source code in multibar\\api\\sectors.py 80 81 82 83 84 85 86 87 88 89 @property @abc . abstractmethod def is_filled ( self ) -> bool : \"\"\" Returns ------- str Sector filled value. \"\"\" ...","title":"is_filled()"},{"location":"docs/api/sectors/#multibar.api.sectors.AbstractSector.name","text":"RETURNS DESCRIPTION str Sector display name. Source code in multibar\\api\\sectors.py 69 70 71 72 73 74 75 76 77 78 @property @abc . abstractmethod def name ( self ) -> str : \"\"\" Returns ------- str Sector display name. \"\"\" ...","title":"name()"},{"location":"docs/api/sectors/#multibar.api.sectors.AbstractSector.position","text":"RETURNS DESCRIPTION str Sector position in the progressbar. Source code in multibar\\api\\sectors.py 91 92 93 94 95 96 97 98 99 100 @property @abc . abstractmethod def position ( self ) -> int : \"\"\" Returns ------- str Sector position in the progressbar. \"\"\" ...","title":"position()"},{"location":"docs/api/signatures/","text":"multibar.api.signatures \u00a4 __all__ = ( 'SignatureSegmentProtocol' , 'ProgressbarSignatureProtocol' ) module-attribute \u00a4 ProgressbarSignatureProtocol \u00a4 Bases: typing . Protocol Signature protocol. Examples: >>> import dataclasses >>> from unittest.mock import Mock # mock for signature segment ... >>> @dataclasses . dataclass ... class Signature : ... start : SignatureSegmentProtocol = dataclasses . field ( default = Mock ()) ... middle : SignatureSegmentProtocol = dataclasses . field ( default = Mock ()) ... end : SignatureSegmentProtocol = dataclasses . field ( default = Mock ()) ... >>> def function_that_checks_signature ( ... signature : ProgressbarSignatureProtocol , / ... ) -> bool : ... return isinstance ( signature , ProgressbarSignatureProtocol ) ... >>> function_that_checks_signature ( Signature ()) # Mypy happy :) True Source code in multibar\\api\\signatures.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 @typing . runtime_checkable class ProgressbarSignatureProtocol ( typing . Protocol ): \"\"\"Signature protocol. Examples -------- >>> import dataclasses >>> from unittest.mock import Mock # mock for signature segment ... >>> @dataclasses.dataclass ... class Signature: ... start: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... middle: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... end: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... >>> def function_that_checks_signature( ... signature: ProgressbarSignatureProtocol, / ... ) -> bool: ... return isinstance(signature, ProgressbarSignatureProtocol) ... >>> function_that_checks_signature(Signature()) # Mypy happy :) True \"\"\" @property def start ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar start char. \"\"\" raise NotImplementedError @property def end ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar end char. \"\"\" raise NotImplementedError @property def middle ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar middle char (between start and and). \"\"\" raise NotImplementedError end () property \u00a4 RETURNS DESCRIPTION SignatureSegmentProtocol Progressbar end char. Source code in multibar\\api\\signatures.py 89 90 91 92 93 94 95 96 97 @property def end ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar end char. \"\"\" raise NotImplementedError middle () property \u00a4 RETURNS DESCRIPTION SignatureSegmentProtocol Progressbar middle char (between start and and). Source code in multibar\\api\\signatures.py 99 100 101 102 103 104 105 106 107 @property def middle ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar middle char (between start and and). \"\"\" raise NotImplementedError start () property \u00a4 RETURNS DESCRIPTION SignatureSegmentProtocol Progressbar start char. Source code in multibar\\api\\signatures.py 79 80 81 82 83 84 85 86 87 @property def start ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar start char. \"\"\" raise NotImplementedError SignatureSegmentProtocol \u00a4 Bases: typing . Protocol Signature segment protocol (protocol for one char, that has two states). Examples: >>> import dataclasses ... >>> @dataclasses . dataclass ... class SignatureSegment : ... on_filled : str = dataclasses . field ( default = \"+\" ) ... on_unfilled : str = dataclasses . field ( default = \"-\" ) ... >>> isinstance ( SignatureSegment (), SignatureSegmentProtocol ) True >>> def function_that_accepts_signature_segment ( ... segment : SignatureSegmentProtocol , / ... ) -> tuple [ str , str ]: ... return segment . on_filled , segment . on_unfilled ... >>> function_that_accepts_signature_segment ( SignatureSegment ()) # Mypy happy :) ('+', '-') Source code in multibar\\api\\signatures.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @typing . runtime_checkable class SignatureSegmentProtocol ( typing . Protocol ): \"\"\"Signature segment protocol (protocol for one char, that has two states). Examples -------- >>> import dataclasses ... >>> @dataclasses.dataclass ... class SignatureSegment: ... on_filled: str = dataclasses.field(default=\"+\") ... on_unfilled: str = dataclasses.field(default=\"-\") ... >>> isinstance(SignatureSegment(), SignatureSegmentProtocol) True >>> def function_that_accepts_signature_segment( ... segment: SignatureSegmentProtocol, / ... ) -> tuple[str, str]: ... return segment.on_filled, segment.on_unfilled ... >>> function_that_accepts_signature_segment(SignatureSegment()) # Mypy happy :) ('+', '-') \"\"\" @property def on_filled ( self ) -> str : \"\"\" Returns ------- str On filled state. \"\"\" raise NotImplementedError @property def on_unfilled ( self ) -> str : \"\"\" Returns ------- str On unfilled state. \"\"\" raise NotImplementedError on_filled () property \u00a4 RETURNS DESCRIPTION str On filled state. Source code in multibar\\api\\signatures.py 34 35 36 37 38 39 40 41 42 @property def on_filled ( self ) -> str : \"\"\" Returns ------- str On filled state. \"\"\" raise NotImplementedError on_unfilled () property \u00a4 RETURNS DESCRIPTION str On unfilled state. Source code in multibar\\api\\signatures.py 44 45 46 47 48 49 50 51 52 @property def on_unfilled ( self ) -> str : \"\"\" Returns ------- str On unfilled state. \"\"\" raise NotImplementedError","title":"Signatures"},{"location":"docs/api/signatures/#multibar.api.signatures","text":"","title":"signatures"},{"location":"docs/api/signatures/#multibar.api.signatures.__all__","text":"","title":"__all__"},{"location":"docs/api/signatures/#multibar.api.signatures.ProgressbarSignatureProtocol","text":"Bases: typing . Protocol Signature protocol. Examples: >>> import dataclasses >>> from unittest.mock import Mock # mock for signature segment ... >>> @dataclasses . dataclass ... class Signature : ... start : SignatureSegmentProtocol = dataclasses . field ( default = Mock ()) ... middle : SignatureSegmentProtocol = dataclasses . field ( default = Mock ()) ... end : SignatureSegmentProtocol = dataclasses . field ( default = Mock ()) ... >>> def function_that_checks_signature ( ... signature : ProgressbarSignatureProtocol , / ... ) -> bool : ... return isinstance ( signature , ProgressbarSignatureProtocol ) ... >>> function_that_checks_signature ( Signature ()) # Mypy happy :) True Source code in multibar\\api\\signatures.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 @typing . runtime_checkable class ProgressbarSignatureProtocol ( typing . Protocol ): \"\"\"Signature protocol. Examples -------- >>> import dataclasses >>> from unittest.mock import Mock # mock for signature segment ... >>> @dataclasses.dataclass ... class Signature: ... start: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... middle: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... end: SignatureSegmentProtocol = dataclasses.field(default=Mock()) ... >>> def function_that_checks_signature( ... signature: ProgressbarSignatureProtocol, / ... ) -> bool: ... return isinstance(signature, ProgressbarSignatureProtocol) ... >>> function_that_checks_signature(Signature()) # Mypy happy :) True \"\"\" @property def start ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar start char. \"\"\" raise NotImplementedError @property def end ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar end char. \"\"\" raise NotImplementedError @property def middle ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar middle char (between start and and). \"\"\" raise NotImplementedError","title":"ProgressbarSignatureProtocol"},{"location":"docs/api/signatures/#multibar.api.signatures.ProgressbarSignatureProtocol.end","text":"RETURNS DESCRIPTION SignatureSegmentProtocol Progressbar end char. Source code in multibar\\api\\signatures.py 89 90 91 92 93 94 95 96 97 @property def end ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar end char. \"\"\" raise NotImplementedError","title":"end()"},{"location":"docs/api/signatures/#multibar.api.signatures.ProgressbarSignatureProtocol.middle","text":"RETURNS DESCRIPTION SignatureSegmentProtocol Progressbar middle char (between start and and). Source code in multibar\\api\\signatures.py 99 100 101 102 103 104 105 106 107 @property def middle ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar middle char (between start and and). \"\"\" raise NotImplementedError","title":"middle()"},{"location":"docs/api/signatures/#multibar.api.signatures.ProgressbarSignatureProtocol.start","text":"RETURNS DESCRIPTION SignatureSegmentProtocol Progressbar start char. Source code in multibar\\api\\signatures.py 79 80 81 82 83 84 85 86 87 @property def start ( self ) -> SignatureSegmentProtocol : \"\"\" Returns ------- SignatureSegmentProtocol Progressbar start char. \"\"\" raise NotImplementedError","title":"start()"},{"location":"docs/api/signatures/#multibar.api.signatures.SignatureSegmentProtocol","text":"Bases: typing . Protocol Signature segment protocol (protocol for one char, that has two states). Examples: >>> import dataclasses ... >>> @dataclasses . dataclass ... class SignatureSegment : ... on_filled : str = dataclasses . field ( default = \"+\" ) ... on_unfilled : str = dataclasses . field ( default = \"-\" ) ... >>> isinstance ( SignatureSegment (), SignatureSegmentProtocol ) True >>> def function_that_accepts_signature_segment ( ... segment : SignatureSegmentProtocol , / ... ) -> tuple [ str , str ]: ... return segment . on_filled , segment . on_unfilled ... >>> function_that_accepts_signature_segment ( SignatureSegment ()) # Mypy happy :) ('+', '-') Source code in multibar\\api\\signatures.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @typing . runtime_checkable class SignatureSegmentProtocol ( typing . Protocol ): \"\"\"Signature segment protocol (protocol for one char, that has two states). Examples -------- >>> import dataclasses ... >>> @dataclasses.dataclass ... class SignatureSegment: ... on_filled: str = dataclasses.field(default=\"+\") ... on_unfilled: str = dataclasses.field(default=\"-\") ... >>> isinstance(SignatureSegment(), SignatureSegmentProtocol) True >>> def function_that_accepts_signature_segment( ... segment: SignatureSegmentProtocol, / ... ) -> tuple[str, str]: ... return segment.on_filled, segment.on_unfilled ... >>> function_that_accepts_signature_segment(SignatureSegment()) # Mypy happy :) ('+', '-') \"\"\" @property def on_filled ( self ) -> str : \"\"\" Returns ------- str On filled state. \"\"\" raise NotImplementedError @property def on_unfilled ( self ) -> str : \"\"\" Returns ------- str On unfilled state. \"\"\" raise NotImplementedError","title":"SignatureSegmentProtocol"},{"location":"docs/api/signatures/#multibar.api.signatures.SignatureSegmentProtocol.on_filled","text":"RETURNS DESCRIPTION str On filled state. Source code in multibar\\api\\signatures.py 34 35 36 37 38 39 40 41 42 @property def on_filled ( self ) -> str : \"\"\" Returns ------- str On filled state. \"\"\" raise NotImplementedError","title":"on_filled()"},{"location":"docs/api/signatures/#multibar.api.signatures.SignatureSegmentProtocol.on_unfilled","text":"RETURNS DESCRIPTION str On unfilled state. Source code in multibar\\api\\signatures.py 44 45 46 47 48 49 50 51 52 @property def on_unfilled ( self ) -> str : \"\"\" Returns ------- str On unfilled state. \"\"\" raise NotImplementedError","title":"on_unfilled()"},{"location":"docs/api/writers/","text":"multibar.api.writers \u00a4 __all__ = ( 'ProgressbarWriterAware' ) module-attribute \u00a4 ProgressbarWriterAware \u00a4 Bases: abc . ABC Interface for progressbar writer implementations. Source code in multibar\\api\\writers.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 class ProgressbarWriterAware ( abc . ABC ): \"\"\"Interface for progressbar writer implementations.\"\"\" __slots__ = () @classmethod @abc . abstractmethod def from_signature ( cls , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Alternative constructor from signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / Signature to init. Returns ------- ProgressbarWriterAware[sectors.AbstractSector] Instance of progressbar writer. \"\"\" ... @typing . overload @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @typing . overload @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , * , length : int , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Writes progress without any hooks or checks. Parameters ---------- start_value : int, / Start value (current progress). end_value : int, / End value (needed progress). length : int, * Length of progressbar. \"\"\" ... @abc . abstractmethod def bind_signature ( self , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Sets new progressbar signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / New signature to set. Returns ------- Self Progressbar writer object to allow fluent-style. \"\"\" ... @property @abc . abstractmethod def signature ( self ) -> signatures . ProgressbarSignatureProtocol : \"\"\" Returns ------- signatures.ProgressbarSignatureProtocol Progressbar signature. \"\"\" ... @property @abc . abstractmethod def sector_cls ( self ) -> typing . Type [ sectors . AbstractSector ]: \"\"\" Returns ------- typing.Type[sectors.AbstractSector] Progressbar sector cls. \"\"\" ... @property @abc . abstractmethod def progressbar_cls ( self ) -> typing . Type [ progressbars . ProgressbarAware [ sectors . AbstractSector ]]: \"\"\" Returns ------- typing.Type[progressbars.ProgressbarAware[sectors.AbstractSector]] Progressbar cls. \"\"\" ... @property @abc . abstractmethod def calculation_cls ( self ) -> typing . Type [ math_operations . AbstractCalculationService ]: \"\"\" Returns ------- typing.Type[math_operations.AbstractCalculationService] Calculation cls. \"\"\" ... __slots__ = () class-attribute \u00a4 bind_signature ( signature ) abstractmethod \u00a4 Sets new progressbar signature. PARAMETER DESCRIPTION signature New signature to set. TYPE: signatures . ProgressbarSignatureProtocol RETURNS DESCRIPTION Self Progressbar writer object to allow fluent-style. Source code in multibar\\api\\writers.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 @abc . abstractmethod def bind_signature ( self , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Sets new progressbar signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / New signature to set. Returns ------- Self Progressbar writer object to allow fluent-style. \"\"\" ... calculation_cls () property abstractmethod \u00a4 RETURNS DESCRIPTION typing . Type [ math_operations . AbstractCalculationService ] Calculation cls. Source code in multibar\\api\\writers.py 129 130 131 132 133 134 135 136 137 138 @property @abc . abstractmethod def calculation_cls ( self ) -> typing . Type [ math_operations . AbstractCalculationService ]: \"\"\" Returns ------- typing.Type[math_operations.AbstractCalculationService] Calculation cls. \"\"\" ... from_signature ( signature ) classmethod abstractmethod \u00a4 Alternative constructor from signature. PARAMETER DESCRIPTION signature Signature to init. TYPE: signatures . ProgressbarSignatureProtocol RETURNS DESCRIPTION ProgressbarWriterAware [ sectors . AbstractSector ] Instance of progressbar writer. Source code in multibar\\api\\writers.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @classmethod @abc . abstractmethod def from_signature ( cls , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Alternative constructor from signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / Signature to init. Returns ------- ProgressbarWriterAware[sectors.AbstractSector] Instance of progressbar writer. \"\"\" ... progressbar_cls () property abstractmethod \u00a4 RETURNS DESCRIPTION typing . Type [ progressbars . ProgressbarAware [ sectors . AbstractSector ]] Progressbar cls. Source code in multibar\\api\\writers.py 118 119 120 121 122 123 124 125 126 127 @property @abc . abstractmethod def progressbar_cls ( self ) -> typing . Type [ progressbars . ProgressbarAware [ sectors . AbstractSector ]]: \"\"\" Returns ------- typing.Type[progressbars.ProgressbarAware[sectors.AbstractSector]] Progressbar cls. \"\"\" ... sector_cls () property abstractmethod \u00a4 RETURNS DESCRIPTION typing . Type [ sectors . AbstractSector ] Progressbar sector cls. Source code in multibar\\api\\writers.py 107 108 109 110 111 112 113 114 115 116 @property @abc . abstractmethod def sector_cls ( self ) -> typing . Type [ sectors . AbstractSector ]: \"\"\" Returns ------- typing.Type[sectors.AbstractSector] Progressbar sector cls. \"\"\" ... signature () property abstractmethod \u00a4 RETURNS DESCRIPTION signatures . ProgressbarSignatureProtocol Progressbar signature. Source code in multibar\\api\\writers.py 96 97 98 99 100 101 102 103 104 105 @property @abc . abstractmethod def signature ( self ) -> signatures . ProgressbarSignatureProtocol : \"\"\" Returns ------- signatures.ProgressbarSignatureProtocol Progressbar signature. \"\"\" ... write ( start_value , end_value , / , * , length = 20 ) abstractmethod \u00a4 Writes progress without any hooks or checks. PARAMETER DESCRIPTION start_value Start value (current progress). TYPE: int end_value : int, / End value (needed progress). length : int, * Length of progressbar. Source code in multibar\\api\\writers.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Writes progress without any hooks or checks. Parameters ---------- start_value : int, / Start value (current progress). end_value : int, / End value (needed progress). length : int, * Length of progressbar. \"\"\" ...","title":"Writers"},{"location":"docs/api/writers/#multibar.api.writers","text":"","title":"writers"},{"location":"docs/api/writers/#multibar.api.writers.__all__","text":"","title":"__all__"},{"location":"docs/api/writers/#multibar.api.writers.ProgressbarWriterAware","text":"Bases: abc . ABC Interface for progressbar writer implementations. Source code in multibar\\api\\writers.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 class ProgressbarWriterAware ( abc . ABC ): \"\"\"Interface for progressbar writer implementations.\"\"\" __slots__ = () @classmethod @abc . abstractmethod def from_signature ( cls , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Alternative constructor from signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / Signature to init. Returns ------- ProgressbarWriterAware[sectors.AbstractSector] Instance of progressbar writer. \"\"\" ... @typing . overload @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @typing . overload @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , * , length : int , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: ... @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Writes progress without any hooks or checks. Parameters ---------- start_value : int, / Start value (current progress). end_value : int, / End value (needed progress). length : int, * Length of progressbar. \"\"\" ... @abc . abstractmethod def bind_signature ( self , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Sets new progressbar signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / New signature to set. Returns ------- Self Progressbar writer object to allow fluent-style. \"\"\" ... @property @abc . abstractmethod def signature ( self ) -> signatures . ProgressbarSignatureProtocol : \"\"\" Returns ------- signatures.ProgressbarSignatureProtocol Progressbar signature. \"\"\" ... @property @abc . abstractmethod def sector_cls ( self ) -> typing . Type [ sectors . AbstractSector ]: \"\"\" Returns ------- typing.Type[sectors.AbstractSector] Progressbar sector cls. \"\"\" ... @property @abc . abstractmethod def progressbar_cls ( self ) -> typing . Type [ progressbars . ProgressbarAware [ sectors . AbstractSector ]]: \"\"\" Returns ------- typing.Type[progressbars.ProgressbarAware[sectors.AbstractSector]] Progressbar cls. \"\"\" ... @property @abc . abstractmethod def calculation_cls ( self ) -> typing . Type [ math_operations . AbstractCalculationService ]: \"\"\" Returns ------- typing.Type[math_operations.AbstractCalculationService] Calculation cls. \"\"\" ...","title":"ProgressbarWriterAware"},{"location":"docs/api/writers/#multibar.api.writers.ProgressbarWriterAware.__slots__","text":"","title":"__slots__"},{"location":"docs/api/writers/#multibar.api.writers.ProgressbarWriterAware.bind_signature","text":"Sets new progressbar signature. PARAMETER DESCRIPTION signature New signature to set. TYPE: signatures . ProgressbarSignatureProtocol RETURNS DESCRIPTION Self Progressbar writer object to allow fluent-style. Source code in multibar\\api\\writers.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 @abc . abstractmethod def bind_signature ( self , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Sets new progressbar signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / New signature to set. Returns ------- Self Progressbar writer object to allow fluent-style. \"\"\" ...","title":"bind_signature()"},{"location":"docs/api/writers/#multibar.api.writers.ProgressbarWriterAware.calculation_cls","text":"RETURNS DESCRIPTION typing . Type [ math_operations . AbstractCalculationService ] Calculation cls. Source code in multibar\\api\\writers.py 129 130 131 132 133 134 135 136 137 138 @property @abc . abstractmethod def calculation_cls ( self ) -> typing . Type [ math_operations . AbstractCalculationService ]: \"\"\" Returns ------- typing.Type[math_operations.AbstractCalculationService] Calculation cls. \"\"\" ...","title":"calculation_cls()"},{"location":"docs/api/writers/#multibar.api.writers.ProgressbarWriterAware.from_signature","text":"Alternative constructor from signature. PARAMETER DESCRIPTION signature Signature to init. TYPE: signatures . ProgressbarSignatureProtocol RETURNS DESCRIPTION ProgressbarWriterAware [ sectors . AbstractSector ] Instance of progressbar writer. Source code in multibar\\api\\writers.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @classmethod @abc . abstractmethod def from_signature ( cls , signature : signatures . ProgressbarSignatureProtocol , / ) -> ProgressbarWriterAware : \"\"\"Alternative constructor from signature. Parameters ---------- signature : signatures.ProgressbarSignatureProtocol, / Signature to init. Returns ------- ProgressbarWriterAware[sectors.AbstractSector] Instance of progressbar writer. \"\"\" ...","title":"from_signature()"},{"location":"docs/api/writers/#multibar.api.writers.ProgressbarWriterAware.progressbar_cls","text":"RETURNS DESCRIPTION typing . Type [ progressbars . ProgressbarAware [ sectors . AbstractSector ]] Progressbar cls. Source code in multibar\\api\\writers.py 118 119 120 121 122 123 124 125 126 127 @property @abc . abstractmethod def progressbar_cls ( self ) -> typing . Type [ progressbars . ProgressbarAware [ sectors . AbstractSector ]]: \"\"\" Returns ------- typing.Type[progressbars.ProgressbarAware[sectors.AbstractSector]] Progressbar cls. \"\"\" ...","title":"progressbar_cls()"},{"location":"docs/api/writers/#multibar.api.writers.ProgressbarWriterAware.sector_cls","text":"RETURNS DESCRIPTION typing . Type [ sectors . AbstractSector ] Progressbar sector cls. Source code in multibar\\api\\writers.py 107 108 109 110 111 112 113 114 115 116 @property @abc . abstractmethod def sector_cls ( self ) -> typing . Type [ sectors . AbstractSector ]: \"\"\" Returns ------- typing.Type[sectors.AbstractSector] Progressbar sector cls. \"\"\" ...","title":"sector_cls()"},{"location":"docs/api/writers/#multibar.api.writers.ProgressbarWriterAware.signature","text":"RETURNS DESCRIPTION signatures . ProgressbarSignatureProtocol Progressbar signature. Source code in multibar\\api\\writers.py 96 97 98 99 100 101 102 103 104 105 @property @abc . abstractmethod def signature ( self ) -> signatures . ProgressbarSignatureProtocol : \"\"\" Returns ------- signatures.ProgressbarSignatureProtocol Progressbar signature. \"\"\" ...","title":"signature()"},{"location":"docs/api/writers/#multibar.api.writers.ProgressbarWriterAware.write","text":"Writes progress without any hooks or checks. PARAMETER DESCRIPTION start_value Start value (current progress). TYPE: int end_value : int, / End value (needed progress). length : int, * Length of progressbar. Source code in multibar\\api\\writers.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 @abc . abstractmethod def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> progressbars . ProgressbarAware [ sectors . AbstractSector ]: \"\"\"Writes progress without any hooks or checks. Parameters ---------- start_value : int, / Start value (current progress). end_value : int, / End value (needed progress). length : int, * Length of progressbar. \"\"\" ...","title":"write()"},{"location":"docs/impl/clients/","text":"multibar.impl.clients \u00a4 __all__ = ( 'ProgressbarClient' ) module-attribute \u00a4 ProgressbarClient \u00a4 Bases: abc_clients . ProgressbarClientAware Source code in multibar\\impl\\clients.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class ProgressbarClient ( abc_clients . ProgressbarClientAware ): __slots__ = ( \"_hooks\" , \"_writer\" , \"_contract_manager\" ) def __init__ ( self , * , hooks : typing . Optional [ abc_hooks . HooksAware ] = None , progress_writer : typing . Optional [ abc_writers . ProgressbarWriterAware ] = None , contract_manager : typing . Optional [ abc_contracts . ContractManagerAware ] = None , ) -> None : \"\"\" Parameters ---------- hooks : typing.Optional[HooksAware] = None Progressbar client hooks. hooks : HooksAware, optional, default=None Progressbar client hooks. progress_writer : typing.Optional[ProgressbarWriterAware[AbstractSector]] = None Writer for progressbar generation. contract_manager : typing.Optional[ContractManagerAware] = None Contract manager for any progress checks. \"\"\" self . _hooks = utils . none_or ( hooks_ . Hooks (), hooks ) self . _writer = utils . none_or ( writers . ProgressbarWriter (), progress_writer ) if contract_manager is None : contract_manager = contracts . ContractManager () contract_manager . subscribe ( contracts . WRITE_PROGRESS_CONTRACT ) self . _contract_manager : abc_contracts . ContractManagerAware = contract_manager def _validate_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers on-error hooks if broken contract raise error. !!! warning It will not handle broken contract, if contract.raise_errors equals to False. Parameters ---------- *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. \"\"\" try : self . _contract_manager . check_contracts ( * args , ** kwargs ) except Exception as exc : self . _hooks . trigger_on_error ( * args , exc , ** kwargs ) def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> writer = self . _writer call_metadata : progress_types . ProgressMetadataType = { \"calculation_service_cls\" : writer . calculation_cls , \"progressbar\" : None , \"start_value\" : start_value , \"end_value\" : end_value , \"length\" : length , \"sig\" : writer . signature , } self . _validate_contracts ( self . _writer , metadata = call_metadata ) self . _hooks . trigger_pre_execution ( self , metadata = call_metadata ) progressbar = self . _writer . write ( start_value , end_value , length = length ) call_metadata [ \"progressbar\" ] = progressbar self . _hooks . trigger_post_execution ( self , metadata = call_metadata ) return progressbar def set_hooks ( self , hooks : abc_hooks . HooksAware , ) -> ProgressbarClient : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> self . _hooks = hooks return self def update_hooks ( self , hooks : abc_hooks . HooksAware , ) -> ProgressbarClient : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> self . _hooks . update ( hooks ) return self @property def hooks ( self ) -> abc_hooks . HooksAware : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> return self . _hooks @property def contract_manager ( self ) -> abc_contracts . ContractManagerAware : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> return self . _contract_manager @property def writer ( self ) -> abc_writers . ProgressbarWriterAware : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> return self . _writer __slots__ = ( '_hooks' , '_writer' , '_contract_manager' ) class-attribute \u00a4 __init__ ( * , hooks = None , progress_writer = None , contract_manager = None ) \u00a4 PARAMETER DESCRIPTION hooks Progressbar client hooks. TYPE: typing . Optional [ HooksAware ] DEFAULT: None hooks Progressbar client hooks. TYPE: HooksAware , optional , default DEFAULT: None progress_writer Writer for progressbar generation. TYPE: typing . Optional [ ProgressbarWriterAware [ AbstractSector ]] DEFAULT: None contract_manager Contract manager for any progress checks. TYPE: typing . Optional [ ContractManagerAware ] DEFAULT: None Source code in multibar\\impl\\clients.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def __init__ ( self , * , hooks : typing . Optional [ abc_hooks . HooksAware ] = None , progress_writer : typing . Optional [ abc_writers . ProgressbarWriterAware ] = None , contract_manager : typing . Optional [ abc_contracts . ContractManagerAware ] = None , ) -> None : \"\"\" Parameters ---------- hooks : typing.Optional[HooksAware] = None Progressbar client hooks. hooks : HooksAware, optional, default=None Progressbar client hooks. progress_writer : typing.Optional[ProgressbarWriterAware[AbstractSector]] = None Writer for progressbar generation. contract_manager : typing.Optional[ContractManagerAware] = None Contract manager for any progress checks. \"\"\" self . _hooks = utils . none_or ( hooks_ . Hooks (), hooks ) self . _writer = utils . none_or ( writers . ProgressbarWriter (), progress_writer ) if contract_manager is None : contract_manager = contracts . ContractManager () contract_manager . subscribe ( contracts . WRITE_PROGRESS_CONTRACT ) self . _contract_manager : abc_contracts . ContractManagerAware = contract_manager contract_manager () property \u00a4 Source code in multibar\\impl\\clients.py 121 122 123 124 @property def contract_manager ( self ) -> abc_contracts . ContractManagerAware : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> return self . _contract_manager get_progress ( start_value , end_value , / , * , length = 20 ) \u00a4 Source code in multibar\\impl\\clients.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> writer = self . _writer call_metadata : progress_types . ProgressMetadataType = { \"calculation_service_cls\" : writer . calculation_cls , \"progressbar\" : None , \"start_value\" : start_value , \"end_value\" : end_value , \"length\" : length , \"sig\" : writer . signature , } self . _validate_contracts ( self . _writer , metadata = call_metadata ) self . _hooks . trigger_pre_execution ( self , metadata = call_metadata ) progressbar = self . _writer . write ( start_value , end_value , length = length ) call_metadata [ \"progressbar\" ] = progressbar self . _hooks . trigger_post_execution ( self , metadata = call_metadata ) return progressbar hooks () property \u00a4 Source code in multibar\\impl\\clients.py 116 117 118 119 @property def hooks ( self ) -> abc_hooks . HooksAware : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> return self . _hooks set_hooks ( hooks ) \u00a4 Source code in multibar\\impl\\clients.py 100 101 102 103 104 105 106 def set_hooks ( self , hooks : abc_hooks . HooksAware , ) -> ProgressbarClient : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> self . _hooks = hooks return self update_hooks ( hooks ) \u00a4 Source code in multibar\\impl\\clients.py 108 109 110 111 112 113 114 def update_hooks ( self , hooks : abc_hooks . HooksAware , ) -> ProgressbarClient : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> self . _hooks . update ( hooks ) return self writer () property \u00a4 Source code in multibar\\impl\\clients.py 126 127 128 129 @property def writer ( self ) -> abc_writers . ProgressbarWriterAware : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> return self . _writer","title":"Clients"},{"location":"docs/impl/clients/#multibar.impl.clients","text":"","title":"clients"},{"location":"docs/impl/clients/#multibar.impl.clients.__all__","text":"","title":"__all__"},{"location":"docs/impl/clients/#multibar.impl.clients.ProgressbarClient","text":"Bases: abc_clients . ProgressbarClientAware Source code in multibar\\impl\\clients.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class ProgressbarClient ( abc_clients . ProgressbarClientAware ): __slots__ = ( \"_hooks\" , \"_writer\" , \"_contract_manager\" ) def __init__ ( self , * , hooks : typing . Optional [ abc_hooks . HooksAware ] = None , progress_writer : typing . Optional [ abc_writers . ProgressbarWriterAware ] = None , contract_manager : typing . Optional [ abc_contracts . ContractManagerAware ] = None , ) -> None : \"\"\" Parameters ---------- hooks : typing.Optional[HooksAware] = None Progressbar client hooks. hooks : HooksAware, optional, default=None Progressbar client hooks. progress_writer : typing.Optional[ProgressbarWriterAware[AbstractSector]] = None Writer for progressbar generation. contract_manager : typing.Optional[ContractManagerAware] = None Contract manager for any progress checks. \"\"\" self . _hooks = utils . none_or ( hooks_ . Hooks (), hooks ) self . _writer = utils . none_or ( writers . ProgressbarWriter (), progress_writer ) if contract_manager is None : contract_manager = contracts . ContractManager () contract_manager . subscribe ( contracts . WRITE_PROGRESS_CONTRACT ) self . _contract_manager : abc_contracts . ContractManagerAware = contract_manager def _validate_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Triggers on-error hooks if broken contract raise error. !!! warning It will not handle broken contract, if contract.raise_errors equals to False. Parameters ---------- *args: typing.Any Arguments to contract check. **kwargs: typing.Any Keyword arguments to contract check. \"\"\" try : self . _contract_manager . check_contracts ( * args , ** kwargs ) except Exception as exc : self . _hooks . trigger_on_error ( * args , exc , ** kwargs ) def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> writer = self . _writer call_metadata : progress_types . ProgressMetadataType = { \"calculation_service_cls\" : writer . calculation_cls , \"progressbar\" : None , \"start_value\" : start_value , \"end_value\" : end_value , \"length\" : length , \"sig\" : writer . signature , } self . _validate_contracts ( self . _writer , metadata = call_metadata ) self . _hooks . trigger_pre_execution ( self , metadata = call_metadata ) progressbar = self . _writer . write ( start_value , end_value , length = length ) call_metadata [ \"progressbar\" ] = progressbar self . _hooks . trigger_post_execution ( self , metadata = call_metadata ) return progressbar def set_hooks ( self , hooks : abc_hooks . HooksAware , ) -> ProgressbarClient : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> self . _hooks = hooks return self def update_hooks ( self , hooks : abc_hooks . HooksAware , ) -> ProgressbarClient : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> self . _hooks . update ( hooks ) return self @property def hooks ( self ) -> abc_hooks . HooksAware : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> return self . _hooks @property def contract_manager ( self ) -> abc_contracts . ContractManagerAware : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> return self . _contract_manager @property def writer ( self ) -> abc_writers . ProgressbarWriterAware : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> return self . _writer","title":"ProgressbarClient"},{"location":"docs/impl/clients/#multibar.impl.clients.ProgressbarClient.__slots__","text":"","title":"__slots__"},{"location":"docs/impl/clients/#multibar.impl.clients.ProgressbarClient.__init__","text":"PARAMETER DESCRIPTION hooks Progressbar client hooks. TYPE: typing . Optional [ HooksAware ] DEFAULT: None hooks Progressbar client hooks. TYPE: HooksAware , optional , default DEFAULT: None progress_writer Writer for progressbar generation. TYPE: typing . Optional [ ProgressbarWriterAware [ AbstractSector ]] DEFAULT: None contract_manager Contract manager for any progress checks. TYPE: typing . Optional [ ContractManagerAware ] DEFAULT: None Source code in multibar\\impl\\clients.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def __init__ ( self , * , hooks : typing . Optional [ abc_hooks . HooksAware ] = None , progress_writer : typing . Optional [ abc_writers . ProgressbarWriterAware ] = None , contract_manager : typing . Optional [ abc_contracts . ContractManagerAware ] = None , ) -> None : \"\"\" Parameters ---------- hooks : typing.Optional[HooksAware] = None Progressbar client hooks. hooks : HooksAware, optional, default=None Progressbar client hooks. progress_writer : typing.Optional[ProgressbarWriterAware[AbstractSector]] = None Writer for progressbar generation. contract_manager : typing.Optional[ContractManagerAware] = None Contract manager for any progress checks. \"\"\" self . _hooks = utils . none_or ( hooks_ . Hooks (), hooks ) self . _writer = utils . none_or ( writers . ProgressbarWriter (), progress_writer ) if contract_manager is None : contract_manager = contracts . ContractManager () contract_manager . subscribe ( contracts . WRITE_PROGRESS_CONTRACT ) self . _contract_manager : abc_contracts . ContractManagerAware = contract_manager","title":"__init__()"},{"location":"docs/impl/clients/#multibar.impl.clients.ProgressbarClient.contract_manager","text":"Source code in multibar\\impl\\clients.py 121 122 123 124 @property def contract_manager ( self ) -> abc_contracts . ContractManagerAware : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> return self . _contract_manager","title":"contract_manager()"},{"location":"docs/impl/clients/#multibar.impl.clients.ProgressbarClient.get_progress","text":"Source code in multibar\\impl\\clients.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def get_progress ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> writer = self . _writer call_metadata : progress_types . ProgressMetadataType = { \"calculation_service_cls\" : writer . calculation_cls , \"progressbar\" : None , \"start_value\" : start_value , \"end_value\" : end_value , \"length\" : length , \"sig\" : writer . signature , } self . _validate_contracts ( self . _writer , metadata = call_metadata ) self . _hooks . trigger_pre_execution ( self , metadata = call_metadata ) progressbar = self . _writer . write ( start_value , end_value , length = length ) call_metadata [ \"progressbar\" ] = progressbar self . _hooks . trigger_post_execution ( self , metadata = call_metadata ) return progressbar","title":"get_progress()"},{"location":"docs/impl/clients/#multibar.impl.clients.ProgressbarClient.hooks","text":"Source code in multibar\\impl\\clients.py 116 117 118 119 @property def hooks ( self ) -> abc_hooks . HooksAware : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> return self . _hooks","title":"hooks()"},{"location":"docs/impl/clients/#multibar.impl.clients.ProgressbarClient.set_hooks","text":"Source code in multibar\\impl\\clients.py 100 101 102 103 104 105 106 def set_hooks ( self , hooks : abc_hooks . HooksAware , ) -> ProgressbarClient : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> self . _hooks = hooks return self","title":"set_hooks()"},{"location":"docs/impl/clients/#multibar.impl.clients.ProgressbarClient.update_hooks","text":"Source code in multibar\\impl\\clients.py 108 109 110 111 112 113 114 def update_hooks ( self , hooks : abc_hooks . HooksAware , ) -> ProgressbarClient : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> self . _hooks . update ( hooks ) return self","title":"update_hooks()"},{"location":"docs/impl/clients/#multibar.impl.clients.ProgressbarClient.writer","text":"Source code in multibar\\impl\\clients.py 126 127 128 129 @property def writer ( self ) -> abc_writers . ProgressbarWriterAware : # << inherited docstring for multibar.api.clients.ProgressbarClientAware >> return self . _writer","title":"writer()"},{"location":"docs/impl/contracts/","text":"multibar.impl.contracts \u00a4 WRITE_PROGRESS_CONTRACT = WriteProgressContract () module-attribute \u00a4 __all__ = ( 'ContractManager' , 'WriteProgressContract' , 'WRITE_PROGRESS_CONTRACT' ) module-attribute \u00a4 ContractManager \u00a4 Bases: contracts . ContractManagerAware Source code in multibar\\impl\\contracts.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class ContractManager ( contracts . ContractManagerAware ): __slots__ = ( \"_contracts\" , \"_raise_errors\" ) def __init__ ( self , * , raise_errors : bool = True ) -> None : self . _contracts : list [ contracts . ContractAware ] = [] self . _raise_errors = raise_errors def _agreed_with_manager ( self , contract : contracts . ContractAware , / ) -> bool : return contract in self . _contracts def set_raise_errors ( self , value : bool , / ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _raise_errors = value def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> for contract in self . _contracts : self . check_contract ( contract , * args , ** kwargs ) def check_contract ( self , contract : contracts . ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> if not self . _agreed_with_manager ( contract ): raise errors . UnsignedContractError ( f \"Contract { type ( contract ) . __name__ } is unsigned.\" ) contract_check = contract . check ( * args , ** kwargs ) if not contract_check . kept : contract . render_terminated_contract ( contract_check , raise_errors = self . _raise_errors , ) def subscribe ( self , contract : contracts . ContractAware , / ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _contracts . append ( contract ) def terminate ( self , contract : contracts . ContractAware , / ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _contracts . remove ( contract ) def terminate_all ( self ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _contracts . clear () @property def contracts ( self ) -> list [ contracts . ContractAware ]: # << inherited docstring for multibar.api.contracts.ContractManagerAware >> return self . _contracts @property def raise_errors ( self ) -> bool : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> return self . _raise_errors __slots__ = ( '_contracts' , '_raise_errors' ) class-attribute \u00a4 __init__ ( * , raise_errors = True ) \u00a4 Source code in multibar\\impl\\contracts.py 20 21 22 def __init__ ( self , * , raise_errors : bool = True ) -> None : self . _contracts : list [ contracts . ContractAware ] = [] self . _raise_errors = raise_errors check_contract ( contract , / , * args , ** kwargs ) \u00a4 Source code in multibar\\impl\\contracts.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def check_contract ( self , contract : contracts . ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> if not self . _agreed_with_manager ( contract ): raise errors . UnsignedContractError ( f \"Contract { type ( contract ) . __name__ } is unsigned.\" ) contract_check = contract . check ( * args , ** kwargs ) if not contract_check . kept : contract . render_terminated_contract ( contract_check , raise_errors = self . _raise_errors , ) check_contracts ( * args , ** kwargs ) \u00a4 Source code in multibar\\impl\\contracts.py 31 32 33 34 def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> for contract in self . _contracts : self . check_contract ( contract , * args , ** kwargs ) contracts () property \u00a4 Source code in multibar\\impl\\contracts.py 66 67 68 69 @property def contracts ( self ) -> list [ contracts . ContractAware ]: # << inherited docstring for multibar.api.contracts.ContractManagerAware >> return self . _contracts raise_errors () property \u00a4 Source code in multibar\\impl\\contracts.py 71 72 73 74 @property def raise_errors ( self ) -> bool : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> return self . _raise_errors set_raise_errors ( value ) \u00a4 Source code in multibar\\impl\\contracts.py 27 28 29 def set_raise_errors ( self , value : bool , / ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _raise_errors = value subscribe ( contract ) \u00a4 Source code in multibar\\impl\\contracts.py 54 55 56 def subscribe ( self , contract : contracts . ContractAware , / ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _contracts . append ( contract ) terminate ( contract ) \u00a4 Source code in multibar\\impl\\contracts.py 58 59 60 def terminate ( self , contract : contracts . ContractAware , / ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _contracts . remove ( contract ) terminate_all () \u00a4 Source code in multibar\\impl\\contracts.py 62 63 64 def terminate_all ( self ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _contracts . clear () WriteProgressContract \u00a4 Bases: contracts . ContractAware Source code in multibar\\impl\\contracts.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 class WriteProgressContract ( contracts . ContractAware ): def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> contracts . ContractCheck : # << inherited docstring for multibar.api.contracts.ContractAware >> call_metadata = meta = typing . cast ( typing . MutableMapping [ typing . Any , typing . Any ], kwargs . pop ( \"metadata\" , {}) ) if not call_metadata : return contracts . ContractCheck . terminated ( errors = [ \"Needs metadata argument.\" ], metadata = call_metadata , ) start , end , length = meta [ \"start_value\" ], meta [ \"end_value\" ], meta [ \"length\" ] if start > end : return contracts . ContractCheck . terminated ( errors = [ \"Start value cannot be more than end value.\" ], metadata = call_metadata , ) if length <= 0 : return contracts . ContractCheck . terminated ( errors = [ \"Length of progress bar must be more than 0.\" ], metadata = call_metadata , ) return contracts . ContractCheck . done ( metadata = call_metadata , ) @typing . overload def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : typing . Literal [ False ], ) -> typing . NoReturn : # Will raise any error. ... @typing . overload def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : typing . Literal [ True ], ) -> IO [ None ]: # Will print any errors/warnings in console. ... @typing . overload def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : ... @impure def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : # << inherited docstring for multibar.api.contracts.ContractAware >> if raise_errors : raise errors . TerminatedContractError ( check ) self_module = self . __module__ + \".\" + \"WriteProgressContract\" output . print_heading ( f \" { self_module } was broken\" , level = 1 , indent = False ) output . print ( f \"Warnings: { len ( check . warnings ) } \" , bold = True ) for warning in check . warnings : output . print_warning ( warning ) output . print ( f \"Errors: { len ( check . errors ) } \" , bold = True ) for error in check . errors : output . print_error ( error ) return IO ( None ) check ( * args , ** kwargs ) \u00a4 Source code in multibar\\impl\\contracts.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> contracts . ContractCheck : # << inherited docstring for multibar.api.contracts.ContractAware >> call_metadata = meta = typing . cast ( typing . MutableMapping [ typing . Any , typing . Any ], kwargs . pop ( \"metadata\" , {}) ) if not call_metadata : return contracts . ContractCheck . terminated ( errors = [ \"Needs metadata argument.\" ], metadata = call_metadata , ) start , end , length = meta [ \"start_value\" ], meta [ \"end_value\" ], meta [ \"length\" ] if start > end : return contracts . ContractCheck . terminated ( errors = [ \"Start value cannot be more than end value.\" ], metadata = call_metadata , ) if length <= 0 : return contracts . ContractCheck . terminated ( errors = [ \"Length of progress bar must be more than 0.\" ], metadata = call_metadata , ) return contracts . ContractCheck . done ( metadata = call_metadata , ) render_terminated_contract ( check , / , * , raise_errors ) \u00a4 Source code in multibar\\impl\\contracts.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 @impure def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : # << inherited docstring for multibar.api.contracts.ContractAware >> if raise_errors : raise errors . TerminatedContractError ( check ) self_module = self . __module__ + \".\" + \"WriteProgressContract\" output . print_heading ( f \" { self_module } was broken\" , level = 1 , indent = False ) output . print ( f \"Warnings: { len ( check . warnings ) } \" , bold = True ) for warning in check . warnings : output . print_warning ( warning ) output . print ( f \"Errors: { len ( check . errors ) } \" , bold = True ) for error in check . errors : output . print_error ( error ) return IO ( None )","title":"Contracts"},{"location":"docs/impl/contracts/#multibar.impl.contracts","text":"","title":"contracts"},{"location":"docs/impl/contracts/#multibar.impl.contracts.WRITE_PROGRESS_CONTRACT","text":"","title":"WRITE_PROGRESS_CONTRACT"},{"location":"docs/impl/contracts/#multibar.impl.contracts.__all__","text":"","title":"__all__"},{"location":"docs/impl/contracts/#multibar.impl.contracts.ContractManager","text":"Bases: contracts . ContractManagerAware Source code in multibar\\impl\\contracts.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class ContractManager ( contracts . ContractManagerAware ): __slots__ = ( \"_contracts\" , \"_raise_errors\" ) def __init__ ( self , * , raise_errors : bool = True ) -> None : self . _contracts : list [ contracts . ContractAware ] = [] self . _raise_errors = raise_errors def _agreed_with_manager ( self , contract : contracts . ContractAware , / ) -> bool : return contract in self . _contracts def set_raise_errors ( self , value : bool , / ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _raise_errors = value def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> for contract in self . _contracts : self . check_contract ( contract , * args , ** kwargs ) def check_contract ( self , contract : contracts . ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> if not self . _agreed_with_manager ( contract ): raise errors . UnsignedContractError ( f \"Contract { type ( contract ) . __name__ } is unsigned.\" ) contract_check = contract . check ( * args , ** kwargs ) if not contract_check . kept : contract . render_terminated_contract ( contract_check , raise_errors = self . _raise_errors , ) def subscribe ( self , contract : contracts . ContractAware , / ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _contracts . append ( contract ) def terminate ( self , contract : contracts . ContractAware , / ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _contracts . remove ( contract ) def terminate_all ( self ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _contracts . clear () @property def contracts ( self ) -> list [ contracts . ContractAware ]: # << inherited docstring for multibar.api.contracts.ContractManagerAware >> return self . _contracts @property def raise_errors ( self ) -> bool : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> return self . _raise_errors","title":"ContractManager"},{"location":"docs/impl/contracts/#multibar.impl.contracts.ContractManager.__slots__","text":"","title":"__slots__"},{"location":"docs/impl/contracts/#multibar.impl.contracts.ContractManager.__init__","text":"Source code in multibar\\impl\\contracts.py 20 21 22 def __init__ ( self , * , raise_errors : bool = True ) -> None : self . _contracts : list [ contracts . ContractAware ] = [] self . _raise_errors = raise_errors","title":"__init__()"},{"location":"docs/impl/contracts/#multibar.impl.contracts.ContractManager.check_contract","text":"Source code in multibar\\impl\\contracts.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def check_contract ( self , contract : contracts . ContractAware , / , * args : typing . Any , ** kwargs : typing . Any , ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> if not self . _agreed_with_manager ( contract ): raise errors . UnsignedContractError ( f \"Contract { type ( contract ) . __name__ } is unsigned.\" ) contract_check = contract . check ( * args , ** kwargs ) if not contract_check . kept : contract . render_terminated_contract ( contract_check , raise_errors = self . _raise_errors , )","title":"check_contract()"},{"location":"docs/impl/contracts/#multibar.impl.contracts.ContractManager.check_contracts","text":"Source code in multibar\\impl\\contracts.py 31 32 33 34 def check_contracts ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> for contract in self . _contracts : self . check_contract ( contract , * args , ** kwargs )","title":"check_contracts()"},{"location":"docs/impl/contracts/#multibar.impl.contracts.ContractManager.contracts","text":"Source code in multibar\\impl\\contracts.py 66 67 68 69 @property def contracts ( self ) -> list [ contracts . ContractAware ]: # << inherited docstring for multibar.api.contracts.ContractManagerAware >> return self . _contracts","title":"contracts()"},{"location":"docs/impl/contracts/#multibar.impl.contracts.ContractManager.raise_errors","text":"Source code in multibar\\impl\\contracts.py 71 72 73 74 @property def raise_errors ( self ) -> bool : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> return self . _raise_errors","title":"raise_errors()"},{"location":"docs/impl/contracts/#multibar.impl.contracts.ContractManager.set_raise_errors","text":"Source code in multibar\\impl\\contracts.py 27 28 29 def set_raise_errors ( self , value : bool , / ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _raise_errors = value","title":"set_raise_errors()"},{"location":"docs/impl/contracts/#multibar.impl.contracts.ContractManager.subscribe","text":"Source code in multibar\\impl\\contracts.py 54 55 56 def subscribe ( self , contract : contracts . ContractAware , / ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _contracts . append ( contract )","title":"subscribe()"},{"location":"docs/impl/contracts/#multibar.impl.contracts.ContractManager.terminate","text":"Source code in multibar\\impl\\contracts.py 58 59 60 def terminate ( self , contract : contracts . ContractAware , / ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _contracts . remove ( contract )","title":"terminate()"},{"location":"docs/impl/contracts/#multibar.impl.contracts.ContractManager.terminate_all","text":"Source code in multibar\\impl\\contracts.py 62 63 64 def terminate_all ( self ) -> None : # << inherited docstring for multibar.api.contracts.ContractManagerAware >> self . _contracts . clear ()","title":"terminate_all()"},{"location":"docs/impl/contracts/#multibar.impl.contracts.WriteProgressContract","text":"Bases: contracts . ContractAware Source code in multibar\\impl\\contracts.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 class WriteProgressContract ( contracts . ContractAware ): def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> contracts . ContractCheck : # << inherited docstring for multibar.api.contracts.ContractAware >> call_metadata = meta = typing . cast ( typing . MutableMapping [ typing . Any , typing . Any ], kwargs . pop ( \"metadata\" , {}) ) if not call_metadata : return contracts . ContractCheck . terminated ( errors = [ \"Needs metadata argument.\" ], metadata = call_metadata , ) start , end , length = meta [ \"start_value\" ], meta [ \"end_value\" ], meta [ \"length\" ] if start > end : return contracts . ContractCheck . terminated ( errors = [ \"Start value cannot be more than end value.\" ], metadata = call_metadata , ) if length <= 0 : return contracts . ContractCheck . terminated ( errors = [ \"Length of progress bar must be more than 0.\" ], metadata = call_metadata , ) return contracts . ContractCheck . done ( metadata = call_metadata , ) @typing . overload def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : typing . Literal [ False ], ) -> typing . NoReturn : # Will raise any error. ... @typing . overload def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : typing . Literal [ True ], ) -> IO [ None ]: # Will print any errors/warnings in console. ... @typing . overload def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : ... @impure def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : # << inherited docstring for multibar.api.contracts.ContractAware >> if raise_errors : raise errors . TerminatedContractError ( check ) self_module = self . __module__ + \".\" + \"WriteProgressContract\" output . print_heading ( f \" { self_module } was broken\" , level = 1 , indent = False ) output . print ( f \"Warnings: { len ( check . warnings ) } \" , bold = True ) for warning in check . warnings : output . print_warning ( warning ) output . print ( f \"Errors: { len ( check . errors ) } \" , bold = True ) for error in check . errors : output . print_error ( error ) return IO ( None )","title":"WriteProgressContract"},{"location":"docs/impl/contracts/#multibar.impl.contracts.WriteProgressContract.check","text":"Source code in multibar\\impl\\contracts.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def check ( self , * args : typing . Any , ** kwargs : typing . Any ) -> contracts . ContractCheck : # << inherited docstring for multibar.api.contracts.ContractAware >> call_metadata = meta = typing . cast ( typing . MutableMapping [ typing . Any , typing . Any ], kwargs . pop ( \"metadata\" , {}) ) if not call_metadata : return contracts . ContractCheck . terminated ( errors = [ \"Needs metadata argument.\" ], metadata = call_metadata , ) start , end , length = meta [ \"start_value\" ], meta [ \"end_value\" ], meta [ \"length\" ] if start > end : return contracts . ContractCheck . terminated ( errors = [ \"Start value cannot be more than end value.\" ], metadata = call_metadata , ) if length <= 0 : return contracts . ContractCheck . terminated ( errors = [ \"Length of progress bar must be more than 0.\" ], metadata = call_metadata , ) return contracts . ContractCheck . done ( metadata = call_metadata , )","title":"check()"},{"location":"docs/impl/contracts/#multibar.impl.contracts.WriteProgressContract.render_terminated_contract","text":"Source code in multibar\\impl\\contracts.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 @impure def render_terminated_contract ( self , check : contracts . ContractCheck , / , * , raise_errors : bool , ) -> typing . Any : # << inherited docstring for multibar.api.contracts.ContractAware >> if raise_errors : raise errors . TerminatedContractError ( check ) self_module = self . __module__ + \".\" + \"WriteProgressContract\" output . print_heading ( f \" { self_module } was broken\" , level = 1 , indent = False ) output . print ( f \"Warnings: { len ( check . warnings ) } \" , bold = True ) for warning in check . warnings : output . print_warning ( warning ) output . print ( f \"Errors: { len ( check . errors ) } \" , bold = True ) for error in check . errors : output . print_error ( error ) return IO ( None )","title":"render_terminated_contract()"},{"location":"docs/impl/hooks/","text":"multibar.impl.hooks \u00a4 WRITER_HOOKS = Hooks () module-attribute \u00a4 __all__ = ( 'Hooks' , 'WRITER_HOOKS' ) module-attribute \u00a4 Hooks \u00a4 Bases: hooks . HooksAware Source code in multibar\\impl\\hooks.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class Hooks ( hooks . HooksAware ): __slots__ = ( \"_on_error_hooks\" , \"_pre_execution_hooks\" , \"_post_execution_hooks\" ) def __init__ ( self ) -> None : self . _on_error_hooks : list [ HookSignatureType ] = [] self . _pre_execution_hooks : list [ HookSignatureType ] = [] self . _post_execution_hooks : list [ HookSignatureType ] = [] def __len__ ( self ) -> int : # << inherited docstring for multibar.api.hooks.HooksAware >> return len ( self . _on_error_hooks + self . _pre_execution_hooks + self . _post_execution_hooks ) def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> if not client . hooks : client . set_hooks ( self ) else : client . update_hooks ( self ) return self def update ( self , other : hooks . HooksAware , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _on_error_hooks . extend ( other . on_error_hooks ) self . _post_execution_hooks . extend ( other . post_execution_hooks ) self . _pre_execution_hooks . extend ( other . pre_execution_hooks ) return self def add_pre_execution ( self , callback : HookSignatureType , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _pre_execution_hooks . append ( callback ) return self def add_post_execution ( self , callback : HookSignatureType , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _post_execution_hooks . append ( callback ) return self def add_on_error ( self , callback : HookSignatureType , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _on_error_hooks . append ( callback ) return self def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.hooks.HooksAware >> for hook in self . _post_execution_hooks : hook ( * args , ** kwargs ) def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.hooks.HooksAware >> for hook in self . _pre_execution_hooks : hook ( * args , ** kwargs ) def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.hooks.HooksAware >> if not self . _on_error_hooks : raise else : for hook in self . _on_error_hooks : hook ( * args , ** kwargs ) @property def pre_execution_hooks ( self ) -> list [ HookSignatureType ]: # << inherited docstring for multibar.api.hooks.HooksAware >> return self . _pre_execution_hooks @property def post_execution_hooks ( self ) -> list [ HookSignatureType ]: # << inherited docstring for multibar.api.hooks.HooksAware >> return self . _post_execution_hooks @property def on_error_hooks ( self ) -> list [ HookSignatureType ]: # << inherited docstring for multibar.api.hooks.HooksAware >> return self . _on_error_hooks __slots__ = ( '_on_error_hooks' , '_pre_execution_hooks' , '_post_execution_hooks' ) class-attribute \u00a4 __init__ () \u00a4 Source code in multibar\\impl\\hooks.py 21 22 23 24 def __init__ ( self ) -> None : self . _on_error_hooks : list [ HookSignatureType ] = [] self . _pre_execution_hooks : list [ HookSignatureType ] = [] self . _post_execution_hooks : list [ HookSignatureType ] = [] __len__ () \u00a4 Source code in multibar\\impl\\hooks.py 26 27 28 def __len__ ( self ) -> int : # << inherited docstring for multibar.api.hooks.HooksAware >> return len ( self . _on_error_hooks + self . _pre_execution_hooks + self . _post_execution_hooks ) add_on_error ( callback ) \u00a4 Source code in multibar\\impl\\hooks.py 56 57 58 59 def add_on_error ( self , callback : HookSignatureType , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _on_error_hooks . append ( callback ) return self add_post_execution ( callback ) \u00a4 Source code in multibar\\impl\\hooks.py 51 52 53 54 def add_post_execution ( self , callback : HookSignatureType , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _post_execution_hooks . append ( callback ) return self add_pre_execution ( callback ) \u00a4 Source code in multibar\\impl\\hooks.py 46 47 48 49 def add_pre_execution ( self , callback : HookSignatureType , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _pre_execution_hooks . append ( callback ) return self add_to_client ( client ) \u00a4 Source code in multibar\\impl\\hooks.py 30 31 32 33 34 35 36 37 def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> if not client . hooks : client . set_hooks ( self ) else : client . update_hooks ( self ) return self on_error_hooks () property \u00a4 Source code in multibar\\impl\\hooks.py 90 91 92 93 @property def on_error_hooks ( self ) -> list [ HookSignatureType ]: # << inherited docstring for multibar.api.hooks.HooksAware >> return self . _on_error_hooks post_execution_hooks () property \u00a4 Source code in multibar\\impl\\hooks.py 85 86 87 88 @property def post_execution_hooks ( self ) -> list [ HookSignatureType ]: # << inherited docstring for multibar.api.hooks.HooksAware >> return self . _post_execution_hooks pre_execution_hooks () property \u00a4 Source code in multibar\\impl\\hooks.py 80 81 82 83 @property def pre_execution_hooks ( self ) -> list [ HookSignatureType ]: # << inherited docstring for multibar.api.hooks.HooksAware >> return self . _pre_execution_hooks trigger_on_error ( * args , ** kwargs ) \u00a4 Source code in multibar\\impl\\hooks.py 71 72 73 74 75 76 77 78 def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.hooks.HooksAware >> if not self . _on_error_hooks : raise else : for hook in self . _on_error_hooks : hook ( * args , ** kwargs ) trigger_post_execution ( * args , ** kwargs ) \u00a4 Source code in multibar\\impl\\hooks.py 61 62 63 64 def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.hooks.HooksAware >> for hook in self . _post_execution_hooks : hook ( * args , ** kwargs ) trigger_pre_execution ( * args , ** kwargs ) \u00a4 Source code in multibar\\impl\\hooks.py 66 67 68 69 def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.hooks.HooksAware >> for hook in self . _pre_execution_hooks : hook ( * args , ** kwargs ) update ( other ) \u00a4 Source code in multibar\\impl\\hooks.py 39 40 41 42 43 44 def update ( self , other : hooks . HooksAware , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _on_error_hooks . extend ( other . on_error_hooks ) self . _post_execution_hooks . extend ( other . post_execution_hooks ) self . _pre_execution_hooks . extend ( other . pre_execution_hooks ) return self","title":"Hooks"},{"location":"docs/impl/hooks/#multibar.impl.hooks","text":"","title":"hooks"},{"location":"docs/impl/hooks/#multibar.impl.hooks.WRITER_HOOKS","text":"","title":"WRITER_HOOKS"},{"location":"docs/impl/hooks/#multibar.impl.hooks.__all__","text":"","title":"__all__"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks","text":"Bases: hooks . HooksAware Source code in multibar\\impl\\hooks.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class Hooks ( hooks . HooksAware ): __slots__ = ( \"_on_error_hooks\" , \"_pre_execution_hooks\" , \"_post_execution_hooks\" ) def __init__ ( self ) -> None : self . _on_error_hooks : list [ HookSignatureType ] = [] self . _pre_execution_hooks : list [ HookSignatureType ] = [] self . _post_execution_hooks : list [ HookSignatureType ] = [] def __len__ ( self ) -> int : # << inherited docstring for multibar.api.hooks.HooksAware >> return len ( self . _on_error_hooks + self . _pre_execution_hooks + self . _post_execution_hooks ) def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> if not client . hooks : client . set_hooks ( self ) else : client . update_hooks ( self ) return self def update ( self , other : hooks . HooksAware , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _on_error_hooks . extend ( other . on_error_hooks ) self . _post_execution_hooks . extend ( other . post_execution_hooks ) self . _pre_execution_hooks . extend ( other . pre_execution_hooks ) return self def add_pre_execution ( self , callback : HookSignatureType , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _pre_execution_hooks . append ( callback ) return self def add_post_execution ( self , callback : HookSignatureType , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _post_execution_hooks . append ( callback ) return self def add_on_error ( self , callback : HookSignatureType , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _on_error_hooks . append ( callback ) return self def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.hooks.HooksAware >> for hook in self . _post_execution_hooks : hook ( * args , ** kwargs ) def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.hooks.HooksAware >> for hook in self . _pre_execution_hooks : hook ( * args , ** kwargs ) def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.hooks.HooksAware >> if not self . _on_error_hooks : raise else : for hook in self . _on_error_hooks : hook ( * args , ** kwargs ) @property def pre_execution_hooks ( self ) -> list [ HookSignatureType ]: # << inherited docstring for multibar.api.hooks.HooksAware >> return self . _pre_execution_hooks @property def post_execution_hooks ( self ) -> list [ HookSignatureType ]: # << inherited docstring for multibar.api.hooks.HooksAware >> return self . _post_execution_hooks @property def on_error_hooks ( self ) -> list [ HookSignatureType ]: # << inherited docstring for multibar.api.hooks.HooksAware >> return self . _on_error_hooks","title":"Hooks"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks.__slots__","text":"","title":"__slots__"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks.__init__","text":"Source code in multibar\\impl\\hooks.py 21 22 23 24 def __init__ ( self ) -> None : self . _on_error_hooks : list [ HookSignatureType ] = [] self . _pre_execution_hooks : list [ HookSignatureType ] = [] self . _post_execution_hooks : list [ HookSignatureType ] = []","title":"__init__()"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks.__len__","text":"Source code in multibar\\impl\\hooks.py 26 27 28 def __len__ ( self ) -> int : # << inherited docstring for multibar.api.hooks.HooksAware >> return len ( self . _on_error_hooks + self . _pre_execution_hooks + self . _post_execution_hooks )","title":"__len__()"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks.add_on_error","text":"Source code in multibar\\impl\\hooks.py 56 57 58 59 def add_on_error ( self , callback : HookSignatureType , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _on_error_hooks . append ( callback ) return self","title":"add_on_error()"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks.add_post_execution","text":"Source code in multibar\\impl\\hooks.py 51 52 53 54 def add_post_execution ( self , callback : HookSignatureType , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _post_execution_hooks . append ( callback ) return self","title":"add_post_execution()"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks.add_pre_execution","text":"Source code in multibar\\impl\\hooks.py 46 47 48 49 def add_pre_execution ( self , callback : HookSignatureType , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _pre_execution_hooks . append ( callback ) return self","title":"add_pre_execution()"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks.add_to_client","text":"Source code in multibar\\impl\\hooks.py 30 31 32 33 34 35 36 37 def add_to_client ( self , client : clients . ProgressbarClientAware , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> if not client . hooks : client . set_hooks ( self ) else : client . update_hooks ( self ) return self","title":"add_to_client()"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks.on_error_hooks","text":"Source code in multibar\\impl\\hooks.py 90 91 92 93 @property def on_error_hooks ( self ) -> list [ HookSignatureType ]: # << inherited docstring for multibar.api.hooks.HooksAware >> return self . _on_error_hooks","title":"on_error_hooks()"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks.post_execution_hooks","text":"Source code in multibar\\impl\\hooks.py 85 86 87 88 @property def post_execution_hooks ( self ) -> list [ HookSignatureType ]: # << inherited docstring for multibar.api.hooks.HooksAware >> return self . _post_execution_hooks","title":"post_execution_hooks()"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks.pre_execution_hooks","text":"Source code in multibar\\impl\\hooks.py 80 81 82 83 @property def pre_execution_hooks ( self ) -> list [ HookSignatureType ]: # << inherited docstring for multibar.api.hooks.HooksAware >> return self . _pre_execution_hooks","title":"pre_execution_hooks()"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks.trigger_on_error","text":"Source code in multibar\\impl\\hooks.py 71 72 73 74 75 76 77 78 def trigger_on_error ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.hooks.HooksAware >> if not self . _on_error_hooks : raise else : for hook in self . _on_error_hooks : hook ( * args , ** kwargs )","title":"trigger_on_error()"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks.trigger_post_execution","text":"Source code in multibar\\impl\\hooks.py 61 62 63 64 def trigger_post_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.hooks.HooksAware >> for hook in self . _post_execution_hooks : hook ( * args , ** kwargs )","title":"trigger_post_execution()"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks.trigger_pre_execution","text":"Source code in multibar\\impl\\hooks.py 66 67 68 69 def trigger_pre_execution ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : # << inherited docstring for multibar.api.hooks.HooksAware >> for hook in self . _pre_execution_hooks : hook ( * args , ** kwargs )","title":"trigger_pre_execution()"},{"location":"docs/impl/hooks/#multibar.impl.hooks.Hooks.update","text":"Source code in multibar\\impl\\hooks.py 39 40 41 42 43 44 def update ( self , other : hooks . HooksAware , / ) -> Hooks : # << inherited docstring for multibar.api.hooks.HooksAware >> self . _on_error_hooks . extend ( other . on_error_hooks ) self . _post_execution_hooks . extend ( other . post_execution_hooks ) self . _pre_execution_hooks . extend ( other . pre_execution_hooks ) return self","title":"update()"},{"location":"docs/impl/math_operations/","text":"multibar.impl.calculation_service \u00a4 __all__ = ( 'ProgressbarCalculationService' ) module-attribute \u00a4 ProgressbarCalculationService \u00a4 Bases: calculation_service . AbstractCalculationService Source code in multibar\\impl\\calculation_service.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class ProgressbarCalculationService ( calculation_service . AbstractCalculationService ): def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> filled_range = range ( round ( self . progress_percents / ( 100 / self . _length ))) return iter ( filled_range ) def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> filled_range_len = len ( tuple ( self . calculate_filled_indexes ())) unfilled_range = range ( self . _length - filled_range_len ) return map ( lambda i : i + filled_range_len , unfilled_range ) @property def progress_percents ( self ) -> float : # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> return self . get_progress_percentage ( self . _start_value , self . _end_value ) @staticmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> return ( start / end ) * 100 calculate_filled_indexes () \u00a4 Source code in multibar\\impl\\calculation_service.py 10 11 12 13 def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> filled_range = range ( round ( self . progress_percents / ( 100 / self . _length ))) return iter ( filled_range ) calculate_unfilled_indexes () \u00a4 Source code in multibar\\impl\\calculation_service.py 15 16 17 18 19 def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> filled_range_len = len ( tuple ( self . calculate_filled_indexes ())) unfilled_range = range ( self . _length - filled_range_len ) return map ( lambda i : i + filled_range_len , unfilled_range ) get_progress_percentage ( start , end ) staticmethod \u00a4 Source code in multibar\\impl\\calculation_service.py 26 27 28 29 @staticmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> return ( start / end ) * 100 progress_percents () property \u00a4 Source code in multibar\\impl\\calculation_service.py 21 22 23 24 @property def progress_percents ( self ) -> float : # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> return self . get_progress_percentage ( self . _start_value , self . _end_value )","title":"Math operations"},{"location":"docs/impl/math_operations/#multibar.impl.calculation_service","text":"","title":"calculation_service"},{"location":"docs/impl/math_operations/#multibar.impl.calculation_service.__all__","text":"","title":"__all__"},{"location":"docs/impl/math_operations/#multibar.impl.calculation_service.ProgressbarCalculationService","text":"Bases: calculation_service . AbstractCalculationService Source code in multibar\\impl\\calculation_service.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class ProgressbarCalculationService ( calculation_service . AbstractCalculationService ): def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> filled_range = range ( round ( self . progress_percents / ( 100 / self . _length ))) return iter ( filled_range ) def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> filled_range_len = len ( tuple ( self . calculate_filled_indexes ())) unfilled_range = range ( self . _length - filled_range_len ) return map ( lambda i : i + filled_range_len , unfilled_range ) @property def progress_percents ( self ) -> float : # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> return self . get_progress_percentage ( self . _start_value , self . _end_value ) @staticmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> return ( start / end ) * 100","title":"ProgressbarCalculationService"},{"location":"docs/impl/math_operations/#multibar.impl.calculation_service.ProgressbarCalculationService.calculate_filled_indexes","text":"Source code in multibar\\impl\\calculation_service.py 10 11 12 13 def calculate_filled_indexes ( self ) -> collections . abc . Iterator [ int ]: # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> filled_range = range ( round ( self . progress_percents / ( 100 / self . _length ))) return iter ( filled_range )","title":"calculate_filled_indexes()"},{"location":"docs/impl/math_operations/#multibar.impl.calculation_service.ProgressbarCalculationService.calculate_unfilled_indexes","text":"Source code in multibar\\impl\\calculation_service.py 15 16 17 18 19 def calculate_unfilled_indexes ( self ) -> collections . abc . Iterator [ int ]: # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> filled_range_len = len ( tuple ( self . calculate_filled_indexes ())) unfilled_range = range ( self . _length - filled_range_len ) return map ( lambda i : i + filled_range_len , unfilled_range )","title":"calculate_unfilled_indexes()"},{"location":"docs/impl/math_operations/#multibar.impl.calculation_service.ProgressbarCalculationService.get_progress_percentage","text":"Source code in multibar\\impl\\calculation_service.py 26 27 28 29 @staticmethod def get_progress_percentage ( start : typing . Union [ int , float ], end : typing . Union [ int , float ], / ) -> float : # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> return ( start / end ) * 100","title":"get_progress_percentage()"},{"location":"docs/impl/math_operations/#multibar.impl.calculation_service.ProgressbarCalculationService.progress_percents","text":"Source code in multibar\\impl\\calculation_service.py 21 22 23 24 @property def progress_percents ( self ) -> float : # << inherited docstring for multibar.api.calculation_service.AbstractCalculationService >> return self . get_progress_percentage ( self . _start_value , self . _end_value )","title":"progress_percents()"},{"location":"docs/impl/progressbars/","text":"multibar.impl.progressbars \u00a4 SectorT = typing . TypeVar ( 'SectorT' , bound = abc_sectors . AbstractSector ) module-attribute \u00a4 __all__ = ( 'Progressbar' ) module-attribute \u00a4 Progressbar \u00a4 Bases: SupportsKind1 [ Any] , SectorT ] , abc_progressbars . ProgressbarAware [ SectorT ] Source code in multibar\\impl\\progressbars.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class Progressbar ( SupportsKind1 [ \"Progressbar[typing.Any]\" , SectorT ], abc_progressbars . ProgressbarAware [ SectorT ] ): __slots__ = ( \"_storage\" ,) def __init__ ( self ) -> None : self . _storage : typing . MutableSequence [ SectorT ] = [] def __len__ ( self ) -> int : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return len ( self . _storage ) def __getitem__ ( self , item : typing . Any ) -> typing . Any : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> if not isinstance ( item , ( int , slice )): return NotImplemented return self . _storage [ item ] def __reversed__ ( self ) -> typing . Iterator [ SectorT ]: \"\"\"Returns reversed progressbar.\"\"\" self . _storage . reverse () return iter ( self . _storage ) def __repr__ ( self ) -> str : \"\"\"Returns string representation of progressbar.\"\"\" return \"\" . join ( s . name for s in self . _storage ) def map ( self : Kind1 [ _InstanceKind , SectorT ], callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return self . set_new_sectors ( callback ( s ) for s in self . _storage ) @classmethod def set_new_sectors ( cls , new_value : typing . Iterable [ _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> # Alternative to cls[_NewValueType](), to avoid mypy \"is not indexable\" error. bar = typing . cast ( Progressbar [ _NewValueType ], cls ()) for new_sector in new_value : bar . add_sector ( new_sector ) return bar def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : for sector in self . _storage : consumer ( sector ) def add_sector ( self : _InstanceKind , sector : abc_sectors . AbstractSector , / ) -> _InstanceKind : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> self . _storage . append ( sector ) return self def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> Progressbar [ SectorT ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> self . _storage [ sector_pos ] . change_name ( new_display_name ) return self @property def length ( self ) -> int : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return len ( self . _storage ) @property def sectors ( self ) -> typing . MutableSequence [ SectorT ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return self . _storage __slots__ = ( '_storage' ) class-attribute \u00a4 __getitem__ ( item ) \u00a4 Source code in multibar\\impl\\progressbars.py 29 30 31 32 33 def __getitem__ ( self , item : typing . Any ) -> typing . Any : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> if not isinstance ( item , ( int , slice )): return NotImplemented return self . _storage [ item ] __init__ () \u00a4 Source code in multibar\\impl\\progressbars.py 22 23 def __init__ ( self ) -> None : self . _storage : typing . MutableSequence [ SectorT ] = [] __len__ () \u00a4 Source code in multibar\\impl\\progressbars.py 25 26 27 def __len__ ( self ) -> int : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return len ( self . _storage ) __repr__ () \u00a4 Returns string representation of progressbar. Source code in multibar\\impl\\progressbars.py 40 41 42 def __repr__ ( self ) -> str : \"\"\"Returns string representation of progressbar.\"\"\" return \"\" . join ( s . name for s in self . _storage ) __reversed__ () \u00a4 Returns reversed progressbar. Source code in multibar\\impl\\progressbars.py 35 36 37 38 def __reversed__ ( self ) -> typing . Iterator [ SectorT ]: \"\"\"Returns reversed progressbar.\"\"\" self . _storage . reverse () return iter ( self . _storage ) add_sector ( sector ) \u00a4 Source code in multibar\\impl\\progressbars.py 69 70 71 72 def add_sector ( self : _InstanceKind , sector : abc_sectors . AbstractSector , / ) -> _InstanceKind : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> self . _storage . append ( sector ) return self for_each ( consumer ) \u00a4 Source code in multibar\\impl\\progressbars.py 65 66 67 def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : for sector in self . _storage : consumer ( sector ) length () property \u00a4 Source code in multibar\\impl\\progressbars.py 79 80 81 82 @property def length ( self ) -> int : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return len ( self . _storage ) map ( callback ) \u00a4 Source code in multibar\\impl\\progressbars.py 44 45 46 47 48 49 50 def map ( self : Kind1 [ _InstanceKind , SectorT ], callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return self . set_new_sectors ( callback ( s ) for s in self . _storage ) replace_display_name_for ( sector_pos , new_display_name ) \u00a4 Source code in multibar\\impl\\progressbars.py 74 75 76 77 def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> Progressbar [ SectorT ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> self . _storage [ sector_pos ] . change_name ( new_display_name ) return self sectors () property \u00a4 Source code in multibar\\impl\\progressbars.py 84 85 86 87 @property def sectors ( self ) -> typing . MutableSequence [ SectorT ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return self . _storage set_new_sectors ( new_value ) classmethod \u00a4 Source code in multibar\\impl\\progressbars.py 52 53 54 55 56 57 58 59 60 61 62 63 @classmethod def set_new_sectors ( cls , new_value : typing . Iterable [ _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> # Alternative to cls[_NewValueType](), to avoid mypy \"is not indexable\" error. bar = typing . cast ( Progressbar [ _NewValueType ], cls ()) for new_sector in new_value : bar . add_sector ( new_sector ) return bar","title":"Progressbars"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars","text":"","title":"progressbars"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.SectorT","text":"","title":"SectorT"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.__all__","text":"","title":"__all__"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.Progressbar","text":"Bases: SupportsKind1 [ Any] , SectorT ] , abc_progressbars . ProgressbarAware [ SectorT ] Source code in multibar\\impl\\progressbars.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class Progressbar ( SupportsKind1 [ \"Progressbar[typing.Any]\" , SectorT ], abc_progressbars . ProgressbarAware [ SectorT ] ): __slots__ = ( \"_storage\" ,) def __init__ ( self ) -> None : self . _storage : typing . MutableSequence [ SectorT ] = [] def __len__ ( self ) -> int : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return len ( self . _storage ) def __getitem__ ( self , item : typing . Any ) -> typing . Any : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> if not isinstance ( item , ( int , slice )): return NotImplemented return self . _storage [ item ] def __reversed__ ( self ) -> typing . Iterator [ SectorT ]: \"\"\"Returns reversed progressbar.\"\"\" self . _storage . reverse () return iter ( self . _storage ) def __repr__ ( self ) -> str : \"\"\"Returns string representation of progressbar.\"\"\" return \"\" . join ( s . name for s in self . _storage ) def map ( self : Kind1 [ _InstanceKind , SectorT ], callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return self . set_new_sectors ( callback ( s ) for s in self . _storage ) @classmethod def set_new_sectors ( cls , new_value : typing . Iterable [ _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> # Alternative to cls[_NewValueType](), to avoid mypy \"is not indexable\" error. bar = typing . cast ( Progressbar [ _NewValueType ], cls ()) for new_sector in new_value : bar . add_sector ( new_sector ) return bar def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : for sector in self . _storage : consumer ( sector ) def add_sector ( self : _InstanceKind , sector : abc_sectors . AbstractSector , / ) -> _InstanceKind : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> self . _storage . append ( sector ) return self def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> Progressbar [ SectorT ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> self . _storage [ sector_pos ] . change_name ( new_display_name ) return self @property def length ( self ) -> int : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return len ( self . _storage ) @property def sectors ( self ) -> typing . MutableSequence [ SectorT ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return self . _storage","title":"Progressbar"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.Progressbar.__slots__","text":"","title":"__slots__"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.Progressbar.__getitem__","text":"Source code in multibar\\impl\\progressbars.py 29 30 31 32 33 def __getitem__ ( self , item : typing . Any ) -> typing . Any : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> if not isinstance ( item , ( int , slice )): return NotImplemented return self . _storage [ item ]","title":"__getitem__()"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.Progressbar.__init__","text":"Source code in multibar\\impl\\progressbars.py 22 23 def __init__ ( self ) -> None : self . _storage : typing . MutableSequence [ SectorT ] = []","title":"__init__()"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.Progressbar.__len__","text":"Source code in multibar\\impl\\progressbars.py 25 26 27 def __len__ ( self ) -> int : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return len ( self . _storage )","title":"__len__()"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.Progressbar.__repr__","text":"Returns string representation of progressbar. Source code in multibar\\impl\\progressbars.py 40 41 42 def __repr__ ( self ) -> str : \"\"\"Returns string representation of progressbar.\"\"\" return \"\" . join ( s . name for s in self . _storage )","title":"__repr__()"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.Progressbar.__reversed__","text":"Returns reversed progressbar. Source code in multibar\\impl\\progressbars.py 35 36 37 38 def __reversed__ ( self ) -> typing . Iterator [ SectorT ]: \"\"\"Returns reversed progressbar.\"\"\" self . _storage . reverse () return iter ( self . _storage )","title":"__reversed__()"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.Progressbar.add_sector","text":"Source code in multibar\\impl\\progressbars.py 69 70 71 72 def add_sector ( self : _InstanceKind , sector : abc_sectors . AbstractSector , / ) -> _InstanceKind : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> self . _storage . append ( sector ) return self","title":"add_sector()"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.Progressbar.for_each","text":"Source code in multibar\\impl\\progressbars.py 65 66 67 def for_each ( self , consumer : typing . Callable [[ SectorT ], typing . Any ], / ) -> None : for sector in self . _storage : consumer ( sector )","title":"for_each()"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.Progressbar.length","text":"Source code in multibar\\impl\\progressbars.py 79 80 81 82 @property def length ( self ) -> int : # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return len ( self . _storage )","title":"length()"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.Progressbar.map","text":"Source code in multibar\\impl\\progressbars.py 44 45 46 47 48 49 50 def map ( self : Kind1 [ _InstanceKind , SectorT ], callback : typing . Callable [[ SectorT ], _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return self . set_new_sectors ( callback ( s ) for s in self . _storage )","title":"map()"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.Progressbar.replace_display_name_for","text":"Source code in multibar\\impl\\progressbars.py 74 75 76 77 def replace_display_name_for ( self , sector_pos : int , new_display_name : str , / ) -> Progressbar [ SectorT ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> self . _storage [ sector_pos ] . change_name ( new_display_name ) return self","title":"replace_display_name_for()"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.Progressbar.sectors","text":"Source code in multibar\\impl\\progressbars.py 84 85 86 87 @property def sectors ( self ) -> typing . MutableSequence [ SectorT ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> return self . _storage","title":"sectors()"},{"location":"docs/impl/progressbars/#multibar.impl.progressbars.Progressbar.set_new_sectors","text":"Source code in multibar\\impl\\progressbars.py 52 53 54 55 56 57 58 59 60 61 62 63 @classmethod def set_new_sectors ( cls , new_value : typing . Iterable [ _NewValueType ], / , ) -> Progressbar [ _NewValueType ]: # << inherited docstring for multibar.api.progressbars.ProgressbarAware >> # Alternative to cls[_NewValueType](), to avoid mypy \"is not indexable\" error. bar = typing . cast ( Progressbar [ _NewValueType ], cls ()) for new_sector in new_value : bar . add_sector ( new_sector ) return bar","title":"set_new_sectors()"},{"location":"docs/impl/sectors/","text":"multibar.impl.sectors \u00a4 __all__ = ( 'Sector' ) module-attribute \u00a4 Sector \u00a4 Bases: sectors . AbstractSector Source code in multibar\\impl\\sectors.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Sector ( sectors . AbstractSector ): def add_to_progressbar ( self : Sector , progressbar : progressbars . ProgressbarAware [ Sector ], / ) -> Sector : # << inherited docstring for multibar.api.sectors.AbstractSector >> progressbar . add_sector ( self ) return self def change_name ( self , new_display_name : str , / ) -> Sector : # << inherited docstring for multibar.api.sectors.AbstractSector >> self . _name = new_display_name return self @property def name ( self ) -> str : # << inherited docstring for multibar.api.sectors.AbstractSector >> return self . _name @property def is_filled ( self ) -> bool : # << inherited docstring for multibar.api.sectors.AbstractSector >> return self . _is_filled @property def position ( self ) -> int : # << inherited docstring for multibar.api.sectors.AbstractSector >> return self . _position add_to_progressbar ( progressbar ) \u00a4 Source code in multibar\\impl\\sectors.py 14 15 16 17 def add_to_progressbar ( self : Sector , progressbar : progressbars . ProgressbarAware [ Sector ], / ) -> Sector : # << inherited docstring for multibar.api.sectors.AbstractSector >> progressbar . add_sector ( self ) return self change_name ( new_display_name ) \u00a4 Source code in multibar\\impl\\sectors.py 19 20 21 22 def change_name ( self , new_display_name : str , / ) -> Sector : # << inherited docstring for multibar.api.sectors.AbstractSector >> self . _name = new_display_name return self is_filled () property \u00a4 Source code in multibar\\impl\\sectors.py 29 30 31 32 @property def is_filled ( self ) -> bool : # << inherited docstring for multibar.api.sectors.AbstractSector >> return self . _is_filled name () property \u00a4 Source code in multibar\\impl\\sectors.py 24 25 26 27 @property def name ( self ) -> str : # << inherited docstring for multibar.api.sectors.AbstractSector >> return self . _name position () property \u00a4 Source code in multibar\\impl\\sectors.py 34 35 36 37 @property def position ( self ) -> int : # << inherited docstring for multibar.api.sectors.AbstractSector >> return self . _position","title":"Sectors"},{"location":"docs/impl/sectors/#multibar.impl.sectors","text":"","title":"sectors"},{"location":"docs/impl/sectors/#multibar.impl.sectors.__all__","text":"","title":"__all__"},{"location":"docs/impl/sectors/#multibar.impl.sectors.Sector","text":"Bases: sectors . AbstractSector Source code in multibar\\impl\\sectors.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Sector ( sectors . AbstractSector ): def add_to_progressbar ( self : Sector , progressbar : progressbars . ProgressbarAware [ Sector ], / ) -> Sector : # << inherited docstring for multibar.api.sectors.AbstractSector >> progressbar . add_sector ( self ) return self def change_name ( self , new_display_name : str , / ) -> Sector : # << inherited docstring for multibar.api.sectors.AbstractSector >> self . _name = new_display_name return self @property def name ( self ) -> str : # << inherited docstring for multibar.api.sectors.AbstractSector >> return self . _name @property def is_filled ( self ) -> bool : # << inherited docstring for multibar.api.sectors.AbstractSector >> return self . _is_filled @property def position ( self ) -> int : # << inherited docstring for multibar.api.sectors.AbstractSector >> return self . _position","title":"Sector"},{"location":"docs/impl/sectors/#multibar.impl.sectors.Sector.add_to_progressbar","text":"Source code in multibar\\impl\\sectors.py 14 15 16 17 def add_to_progressbar ( self : Sector , progressbar : progressbars . ProgressbarAware [ Sector ], / ) -> Sector : # << inherited docstring for multibar.api.sectors.AbstractSector >> progressbar . add_sector ( self ) return self","title":"add_to_progressbar()"},{"location":"docs/impl/sectors/#multibar.impl.sectors.Sector.change_name","text":"Source code in multibar\\impl\\sectors.py 19 20 21 22 def change_name ( self , new_display_name : str , / ) -> Sector : # << inherited docstring for multibar.api.sectors.AbstractSector >> self . _name = new_display_name return self","title":"change_name()"},{"location":"docs/impl/sectors/#multibar.impl.sectors.Sector.is_filled","text":"Source code in multibar\\impl\\sectors.py 29 30 31 32 @property def is_filled ( self ) -> bool : # << inherited docstring for multibar.api.sectors.AbstractSector >> return self . _is_filled","title":"is_filled()"},{"location":"docs/impl/sectors/#multibar.impl.sectors.Sector.name","text":"Source code in multibar\\impl\\sectors.py 24 25 26 27 @property def name ( self ) -> str : # << inherited docstring for multibar.api.sectors.AbstractSector >> return self . _name","title":"name()"},{"location":"docs/impl/sectors/#multibar.impl.sectors.Sector.position","text":"Source code in multibar\\impl\\sectors.py 34 35 36 37 @property def position ( self ) -> int : # << inherited docstring for multibar.api.sectors.AbstractSector >> return self . _position","title":"position()"},{"location":"docs/impl/signatures/","text":"multibar.impl.signatures \u00a4 __all__ = ( 'SimpleSignature' , 'SignatureSegment' , 'SquareEmojiSignature' ) module-attribute \u00a4 SignatureSegment dataclass \u00a4 Source code in multibar\\impl\\signatures.py 10 11 12 13 @dataclasses . dataclass class SignatureSegment : on_filled : str on_unfilled : str on_filled : str class-attribute \u00a4 on_unfilled : str class-attribute \u00a4 SimpleSignature dataclass \u00a4 Source code in multibar\\impl\\signatures.py 16 17 18 19 20 @dataclasses . dataclass class SimpleSignature : start : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \"<\" , on_unfilled = \"-\" )) end : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \">\" , on_unfilled = \"-\" )) middle : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \"+\" , on_unfilled = \"-\" )) end : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = '>' , on_unfilled = '-' )) class-attribute \u00a4 middle : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = '+' , on_unfilled = '-' )) class-attribute \u00a4 start : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = '<' , on_unfilled = '-' )) class-attribute \u00a4 SquareEmojiSignature dataclass \u00a4 Source code in multibar\\impl\\signatures.py 23 24 25 26 27 28 29 30 31 32 33 @dataclasses . dataclass class SquareEmojiSignature : start : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \":small_orange_diamond:\" , on_unfilled = \":black_large_square:\" ) ) end : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \":small_orange_diamond:\" , on_unfilled = \":black_large_square:\" ) ) middle : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \":orange_square:\" , on_unfilled = \":black_large_square:\" ) ) end : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = ':small_orange_diamond:' , on_unfilled = ':black_large_square:' )) class-attribute \u00a4 middle : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = ':orange_square:' , on_unfilled = ':black_large_square:' )) class-attribute \u00a4 start : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = ':small_orange_diamond:' , on_unfilled = ':black_large_square:' )) class-attribute \u00a4","title":"Signatures"},{"location":"docs/impl/signatures/#multibar.impl.signatures","text":"","title":"signatures"},{"location":"docs/impl/signatures/#multibar.impl.signatures.__all__","text":"","title":"__all__"},{"location":"docs/impl/signatures/#multibar.impl.signatures.SignatureSegment","text":"Source code in multibar\\impl\\signatures.py 10 11 12 13 @dataclasses . dataclass class SignatureSegment : on_filled : str on_unfilled : str","title":"SignatureSegment"},{"location":"docs/impl/signatures/#multibar.impl.signatures.SignatureSegment.on_filled","text":"","title":"on_filled"},{"location":"docs/impl/signatures/#multibar.impl.signatures.SignatureSegment.on_unfilled","text":"","title":"on_unfilled"},{"location":"docs/impl/signatures/#multibar.impl.signatures.SimpleSignature","text":"Source code in multibar\\impl\\signatures.py 16 17 18 19 20 @dataclasses . dataclass class SimpleSignature : start : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \"<\" , on_unfilled = \"-\" )) end : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \">\" , on_unfilled = \"-\" )) middle : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \"+\" , on_unfilled = \"-\" ))","title":"SimpleSignature"},{"location":"docs/impl/signatures/#multibar.impl.signatures.SimpleSignature.end","text":"","title":"end"},{"location":"docs/impl/signatures/#multibar.impl.signatures.SimpleSignature.middle","text":"","title":"middle"},{"location":"docs/impl/signatures/#multibar.impl.signatures.SimpleSignature.start","text":"","title":"start"},{"location":"docs/impl/signatures/#multibar.impl.signatures.SquareEmojiSignature","text":"Source code in multibar\\impl\\signatures.py 23 24 25 26 27 28 29 30 31 32 33 @dataclasses . dataclass class SquareEmojiSignature : start : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \":small_orange_diamond:\" , on_unfilled = \":black_large_square:\" ) ) end : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \":small_orange_diamond:\" , on_unfilled = \":black_large_square:\" ) ) middle : SignatureSegment = dataclasses . field ( default = SignatureSegment ( on_filled = \":orange_square:\" , on_unfilled = \":black_large_square:\" ) )","title":"SquareEmojiSignature"},{"location":"docs/impl/signatures/#multibar.impl.signatures.SquareEmojiSignature.end","text":"","title":"end"},{"location":"docs/impl/signatures/#multibar.impl.signatures.SquareEmojiSignature.middle","text":"","title":"middle"},{"location":"docs/impl/signatures/#multibar.impl.signatures.SquareEmojiSignature.start","text":"","title":"start"},{"location":"docs/impl/writers/","text":"multibar.impl.writers \u00a4 __all__ = ( 'ProgressbarWriter' ) module-attribute \u00a4 ProgressbarWriter \u00a4 Bases: abc_writers . ProgressbarWriterAware Source code in multibar\\impl\\writers.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class ProgressbarWriter ( abc_writers . ProgressbarWriterAware ): __slots__ = ( \"_signature\" , \"_sector_cls\" , \"_progressbar_cls\" , \"_calculation_service\" ) def __init__ ( self , * , sector_cls : typing . Optional [ typing . Type [ abc_sectors . AbstractSector ]] = None , progressbar_cls : typing . Optional [ typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]] ] = None , signature : typing . Optional [ abc_signatures . ProgressbarSignatureProtocol ] = None , calculation_service : typing . Optional [ typing . Type [ abc_math_operations . AbstractCalculationService ] ] = None , ) -> None : \"\"\" Parameters ---------- sector_cls: typing.Optional[typing.Type[abc_sectors.AbstractSector]] = None, * Progressbar sector cls for writer. progressbar_cls: typing.Optional[typing.Type[ProgressbarT_co]] = None, * Progressbar cls for writer. signature: typing.Optional[abc_signatures.ProgressbarSignatureProtocol] = None, * Progressbar signature for writer. calculation_service: typing.Optional[ typing.Type[abc_math_operations.AbstractCalculationService] ] = None, * Math operations for writer. ) -> None: \"\"\" self . _signature = utils . none_or ( signatures . SimpleSignature (), signature ) self . _sector_cls = utils . none_or ( sectors . Sector , sector_cls ) self . _progressbar_cls = utils . none_or ( progressbars . Progressbar [ abc_sectors . AbstractSector ], progressbar_cls ) self . _calculation_service = utils . none_or ( math_operations . ProgressbarCalculationService , calculation_service ) @classmethod def from_signature ( cls , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return cls ( sector_cls = None , progressbar_cls = None , signature = signature , calculation_service = None , ) @typing . final def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> sig = self . _signature sector_cls = self . _sector_cls progressbar = self . _progressbar_cls () calculation_service = self . _calculation_service ( start_value , end_value , length ) for sector_index in calculation_service . calculate_filled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_filled , True , sector_index )) for sector_index in calculation_service . calculate_unfilled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_unfilled , False , sector_index )) return progressbar def bind_signature ( self , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> self . _signature = signature return self @property def signature ( self ) -> abc_signatures . ProgressbarSignatureProtocol : # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _signature @property def sector_cls ( self ) -> typing . Type [ abc_sectors . AbstractSector ]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _sector_cls @property def progressbar_cls ( self ) -> typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _progressbar_cls @property def calculation_cls ( self ) -> typing . Type [ abc_math_operations . AbstractCalculationService ]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _calculation_service __slots__ = ( '_signature' , '_sector_cls' , '_progressbar_cls' , '_calculation_service' ) class-attribute \u00a4 __init__ ( * , sector_cls = None , progressbar_cls = None , signature = None , calculation_service = None ) \u00a4 Parameters ---------- sector_cls: typing.Optional[typing.Type[abc_sectors.AbstractSector]] = None, * Progressbar sector cls for writer. progressbar_cls: typing.Optional[typing.Type[ProgressbarT_co]] = None, * Progressbar cls for writer. signature: typing.Optional[abc_signatures.ProgressbarSignatureProtocol] = None, * Progressbar signature for writer. calculation_service: typing.Optional[ typing.Type[abc_math_operations.AbstractCalculationService] ] = None, * Math operations for writer. ) -> None: Source code in multibar\\impl\\writers.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def __init__ ( self , * , sector_cls : typing . Optional [ typing . Type [ abc_sectors . AbstractSector ]] = None , progressbar_cls : typing . Optional [ typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]] ] = None , signature : typing . Optional [ abc_signatures . ProgressbarSignatureProtocol ] = None , calculation_service : typing . Optional [ typing . Type [ abc_math_operations . AbstractCalculationService ] ] = None , ) -> None : \"\"\" Parameters ---------- sector_cls: typing.Optional[typing.Type[abc_sectors.AbstractSector]] = None, * Progressbar sector cls for writer. progressbar_cls: typing.Optional[typing.Type[ProgressbarT_co]] = None, * Progressbar cls for writer. signature: typing.Optional[abc_signatures.ProgressbarSignatureProtocol] = None, * Progressbar signature for writer. calculation_service: typing.Optional[ typing.Type[abc_math_operations.AbstractCalculationService] ] = None, * Math operations for writer. ) -> None: \"\"\" self . _signature = utils . none_or ( signatures . SimpleSignature (), signature ) self . _sector_cls = utils . none_or ( sectors . Sector , sector_cls ) self . _progressbar_cls = utils . none_or ( progressbars . Progressbar [ abc_sectors . AbstractSector ], progressbar_cls ) self . _calculation_service = utils . none_or ( math_operations . ProgressbarCalculationService , calculation_service ) bind_signature ( signature ) \u00a4 Source code in multibar\\impl\\writers.py 99 100 101 102 103 104 105 106 def bind_signature ( self , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> self . _signature = signature return self calculation_cls () property \u00a4 Source code in multibar\\impl\\writers.py 123 124 125 126 @property def calculation_cls ( self ) -> typing . Type [ abc_math_operations . AbstractCalculationService ]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _calculation_service from_signature ( signature ) classmethod \u00a4 Source code in multibar\\impl\\writers.py 62 63 64 65 66 67 68 69 70 71 72 73 74 @classmethod def from_signature ( cls , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return cls ( sector_cls = None , progressbar_cls = None , signature = signature , calculation_service = None , ) progressbar_cls () property \u00a4 Source code in multibar\\impl\\writers.py 118 119 120 121 @property def progressbar_cls ( self ) -> typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _progressbar_cls sector_cls () property \u00a4 Source code in multibar\\impl\\writers.py 113 114 115 116 @property def sector_cls ( self ) -> typing . Type [ abc_sectors . AbstractSector ]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _sector_cls signature () property \u00a4 Source code in multibar\\impl\\writers.py 108 109 110 111 @property def signature ( self ) -> abc_signatures . ProgressbarSignatureProtocol : # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _signature write ( start_value , end_value , / , * , length = 20 ) \u00a4 Source code in multibar\\impl\\writers.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @typing . final def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> sig = self . _signature sector_cls = self . _sector_cls progressbar = self . _progressbar_cls () calculation_service = self . _calculation_service ( start_value , end_value , length ) for sector_index in calculation_service . calculate_filled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_filled , True , sector_index )) for sector_index in calculation_service . calculate_unfilled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_unfilled , False , sector_index )) return progressbar","title":"Writers"},{"location":"docs/impl/writers/#multibar.impl.writers","text":"","title":"writers"},{"location":"docs/impl/writers/#multibar.impl.writers.__all__","text":"","title":"__all__"},{"location":"docs/impl/writers/#multibar.impl.writers.ProgressbarWriter","text":"Bases: abc_writers . ProgressbarWriterAware Source code in multibar\\impl\\writers.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class ProgressbarWriter ( abc_writers . ProgressbarWriterAware ): __slots__ = ( \"_signature\" , \"_sector_cls\" , \"_progressbar_cls\" , \"_calculation_service\" ) def __init__ ( self , * , sector_cls : typing . Optional [ typing . Type [ abc_sectors . AbstractSector ]] = None , progressbar_cls : typing . Optional [ typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]] ] = None , signature : typing . Optional [ abc_signatures . ProgressbarSignatureProtocol ] = None , calculation_service : typing . Optional [ typing . Type [ abc_math_operations . AbstractCalculationService ] ] = None , ) -> None : \"\"\" Parameters ---------- sector_cls: typing.Optional[typing.Type[abc_sectors.AbstractSector]] = None, * Progressbar sector cls for writer. progressbar_cls: typing.Optional[typing.Type[ProgressbarT_co]] = None, * Progressbar cls for writer. signature: typing.Optional[abc_signatures.ProgressbarSignatureProtocol] = None, * Progressbar signature for writer. calculation_service: typing.Optional[ typing.Type[abc_math_operations.AbstractCalculationService] ] = None, * Math operations for writer. ) -> None: \"\"\" self . _signature = utils . none_or ( signatures . SimpleSignature (), signature ) self . _sector_cls = utils . none_or ( sectors . Sector , sector_cls ) self . _progressbar_cls = utils . none_or ( progressbars . Progressbar [ abc_sectors . AbstractSector ], progressbar_cls ) self . _calculation_service = utils . none_or ( math_operations . ProgressbarCalculationService , calculation_service ) @classmethod def from_signature ( cls , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return cls ( sector_cls = None , progressbar_cls = None , signature = signature , calculation_service = None , ) @typing . final def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> sig = self . _signature sector_cls = self . _sector_cls progressbar = self . _progressbar_cls () calculation_service = self . _calculation_service ( start_value , end_value , length ) for sector_index in calculation_service . calculate_filled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_filled , True , sector_index )) for sector_index in calculation_service . calculate_unfilled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_unfilled , False , sector_index )) return progressbar def bind_signature ( self , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> self . _signature = signature return self @property def signature ( self ) -> abc_signatures . ProgressbarSignatureProtocol : # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _signature @property def sector_cls ( self ) -> typing . Type [ abc_sectors . AbstractSector ]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _sector_cls @property def progressbar_cls ( self ) -> typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _progressbar_cls @property def calculation_cls ( self ) -> typing . Type [ abc_math_operations . AbstractCalculationService ]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _calculation_service","title":"ProgressbarWriter"},{"location":"docs/impl/writers/#multibar.impl.writers.ProgressbarWriter.__slots__","text":"","title":"__slots__"},{"location":"docs/impl/writers/#multibar.impl.writers.ProgressbarWriter.__init__","text":"Parameters ---------- sector_cls: typing.Optional[typing.Type[abc_sectors.AbstractSector]] = None, * Progressbar sector cls for writer. progressbar_cls: typing.Optional[typing.Type[ProgressbarT_co]] = None, * Progressbar cls for writer. signature: typing.Optional[abc_signatures.ProgressbarSignatureProtocol] = None, * Progressbar signature for writer. calculation_service: typing.Optional[ typing.Type[abc_math_operations.AbstractCalculationService] ] = None, * Math operations for writer. ) -> None: Source code in multibar\\impl\\writers.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def __init__ ( self , * , sector_cls : typing . Optional [ typing . Type [ abc_sectors . AbstractSector ]] = None , progressbar_cls : typing . Optional [ typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]] ] = None , signature : typing . Optional [ abc_signatures . ProgressbarSignatureProtocol ] = None , calculation_service : typing . Optional [ typing . Type [ abc_math_operations . AbstractCalculationService ] ] = None , ) -> None : \"\"\" Parameters ---------- sector_cls: typing.Optional[typing.Type[abc_sectors.AbstractSector]] = None, * Progressbar sector cls for writer. progressbar_cls: typing.Optional[typing.Type[ProgressbarT_co]] = None, * Progressbar cls for writer. signature: typing.Optional[abc_signatures.ProgressbarSignatureProtocol] = None, * Progressbar signature for writer. calculation_service: typing.Optional[ typing.Type[abc_math_operations.AbstractCalculationService] ] = None, * Math operations for writer. ) -> None: \"\"\" self . _signature = utils . none_or ( signatures . SimpleSignature (), signature ) self . _sector_cls = utils . none_or ( sectors . Sector , sector_cls ) self . _progressbar_cls = utils . none_or ( progressbars . Progressbar [ abc_sectors . AbstractSector ], progressbar_cls ) self . _calculation_service = utils . none_or ( math_operations . ProgressbarCalculationService , calculation_service )","title":"__init__()"},{"location":"docs/impl/writers/#multibar.impl.writers.ProgressbarWriter.bind_signature","text":"Source code in multibar\\impl\\writers.py 99 100 101 102 103 104 105 106 def bind_signature ( self , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> self . _signature = signature return self","title":"bind_signature()"},{"location":"docs/impl/writers/#multibar.impl.writers.ProgressbarWriter.calculation_cls","text":"Source code in multibar\\impl\\writers.py 123 124 125 126 @property def calculation_cls ( self ) -> typing . Type [ abc_math_operations . AbstractCalculationService ]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _calculation_service","title":"calculation_cls()"},{"location":"docs/impl/writers/#multibar.impl.writers.ProgressbarWriter.from_signature","text":"Source code in multibar\\impl\\writers.py 62 63 64 65 66 67 68 69 70 71 72 73 74 @classmethod def from_signature ( cls , signature : abc_signatures . ProgressbarSignatureProtocol , / , ) -> ProgressbarWriter : # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return cls ( sector_cls = None , progressbar_cls = None , signature = signature , calculation_service = None , )","title":"from_signature()"},{"location":"docs/impl/writers/#multibar.impl.writers.ProgressbarWriter.progressbar_cls","text":"Source code in multibar\\impl\\writers.py 118 119 120 121 @property def progressbar_cls ( self ) -> typing . Type [ abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _progressbar_cls","title":"progressbar_cls()"},{"location":"docs/impl/writers/#multibar.impl.writers.ProgressbarWriter.sector_cls","text":"Source code in multibar\\impl\\writers.py 113 114 115 116 @property def sector_cls ( self ) -> typing . Type [ abc_sectors . AbstractSector ]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _sector_cls","title":"sector_cls()"},{"location":"docs/impl/writers/#multibar.impl.writers.ProgressbarWriter.signature","text":"Source code in multibar\\impl\\writers.py 108 109 110 111 @property def signature ( self ) -> abc_signatures . ProgressbarSignatureProtocol : # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> return self . _signature","title":"signature()"},{"location":"docs/impl/writers/#multibar.impl.writers.ProgressbarWriter.write","text":"Source code in multibar\\impl\\writers.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @typing . final def write ( self , start_value : int , end_value : int , / , * , length : int = 20 , ) -> abc_progressbars . ProgressbarAware [ abc_sectors . AbstractSector ]: # << inherited docstring for multibar.api.writers.ProgressbarWriterAware >> sig = self . _signature sector_cls = self . _sector_cls progressbar = self . _progressbar_cls () calculation_service = self . _calculation_service ( start_value , end_value , length ) for sector_index in calculation_service . calculate_filled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_filled , True , sector_index )) for sector_index in calculation_service . calculate_unfilled_indexes (): progressbar . add_sector ( sector_cls ( sig . middle . on_unfilled , False , sector_index )) return progressbar","title":"write()"}]}